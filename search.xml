<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《Deep Learning for Image and Point Clound Fusion in Autonomous Driving:A Review》</title>
      <link href="/2020/09/12/pr-review_Image_PointCloud_Fusion/"/>
      <url>/2020/09/12/pr-review_Image_PointCloud_Fusion/</url>
      
        <content type="html"><![CDATA[<p>​ 相机与Lidar点云融合的综述文章。针对点云和图像数据结构特征的差异，提出了目前这两种传感器融合方面的切入点和发展趋势。无人驾驶要求对周围3D环境进行可靠的感知，单目相机原理上不能提供3D几何信息，而双目相机虽然可以提供3D几何信息，但其引入计算量同时探测距离有限对环境条件要求较高，因此在无人驾驶环境下使用的较少。Lidar能够提供高精度的几何信息同时不受光线条件的影响，但是存在采样稀疏，语义信息匮乏的问题。 ​ 为了应对无人驾驶感知任务的挑战，当前许多研究致力于如何有效的融合这两种互补的传感器信息。</p><p><img src="/2020/09/12/pr-review_Image_PointCloud_Fusion/image-20200521161943634.png" alt="image-20200521161943634" style="zoom: 33%;"></p><a id="more"></a><p>深度学习方法在图像中的应用：图像中编码的是可见光信息，目前基于CNN的相关网络结构得到的广泛的研究。 由于点云数据结构(无序，不规则,密度不均衡(近多远少))的特点，直接应用已有的网络结构比较困难，目前针对点云数据的处理方式有：</p><ol type="1"><li>Volumetric representation based(基于体素网格的方法)：将点云划分到3D网格中，从而可以直接应用3D convolution 这种划分方法存在问题：高分辨率的3D体素网格(voxel-space)大幅增加了计算量，同时点云的稀疏性导致了大量的空网格且会随着分辨率的提升立方增长。 <a href="https://arxiv.org/pdf/1711.06396.pdf" target="_blank" rel="noopener">参考:Voxelnet</a> <a href="https://ieeexplore.ieee.org/document/7353481" target="_blank" rel="noopener">参考:Voxnet</a></li><li>Tree-like representation based(基于树状结构的方法)：出发点为了减轻高分辨率带来的高计算量的约束，通过将点云划分到一系列的不平衡树（八叉树），使得低密度的点只有较低的分辨率，减少不必要的空间和计算资源浪费。特征提取采用类卷积的操作。 <a href="https://arxiv.org/abs/1611.05009" target="_blank" rel="noopener">参考:Octnet</a> <a href="https://ieeexplore.ieee.org/document/8784388" target="_blank" rel="noopener">参考:context-based octree</a> <a href="https://arxiv.org/abs/1903.00343" target="_blank" rel="noopener">参考:octree guided cnn</a> <a href="https://arxiv.org/abs/1711.11379" target="_blank" rel="noopener">参考:3dcontextnet</a></li><li>Point representation based: (基于原始点云的表示方法)：该方法采用原始点云，开创工作是<a href="https://arxiv.org/abs/1706.02413" target="_blank" rel="noopener">pointNet</a></li><li>2D view representation based(基于点云投影2D视图的表示方法)：这种方法将点云投影到某个2D平面,2D平面中每个点编码了点云的特征(类似于图像的特征图)，常用的2D投影平面例如鸟瞰图(bird's-eye view,BEW),这种投影方式视角遮挡最小，同时原始的物体朝向和x,y坐标被保留。目前常用的特征表述包括了(average points height,density and intesity)。标准的2D卷积和现有的卷积框架结构可以被直接使用。</li><li>Geometric representation based(基于几何的表示方法)：点云可以表示为图(拓扑)结构，类卷积操作可以实现用于特征提取。 <a href="https://arxiv.org/abs/1905.04571" target="_blank" rel="noopener">参考:graph topology inference</a> <a href="https://arxiv.org/abs/1506.05163" target="_blank" rel="noopener">参考:deep cnn for graph data</a> <a href="https://arxiv.org/abs/1704.02901" target="_blank" rel="noopener">参考:edge-conditioned filters</a></li></ol><p>点云的特征表示方式目前还是一个开放的问题。</p><h2 id="论文总体结构">1. 论文总体结构</h2><p>论文从四个方面(Depth completion , object detection, semantic segmentation, object tracking)概述了图像和点云融合的相关进展。</p><figure><img src="/2020/09/12/pr-review_Image_PointCloud_Fusion/image-20200521161607067.png" alt="image-20200521161607067"><figcaption>image-20200521161607067</figcaption></figure><h2 id="无人驾驶感知的挑战">2. 无人驾驶感知的挑战</h2><h3 id="depth-completion">2.1 Depth Completion</h3><p>深度补全是指通过上采样稀疏不规则的数据到密集规则的数据。Camera-Lidar融合的方法通常利用高分辨率的图像指导上采样，实现pixel-wise层级上的深度图。下图按照时间顺序给出了深度补全模型和对应的融合层级。</p><figure><img src="/2020/09/12/pr-review_Image_PointCloud_Fusion/image-20200524204555123.png" alt="image-20200524204555123"><figcaption>image-20200524204555123</figcaption></figure><h3 id="d-object-detection">2.2 3D object detection</h3><p>​ 3D目标检测方法的目的是在3D空间中定位，分类以及估计障碍物的朝向。目前有两种主流的实现方法： ​ two-step(Sequential)和one-step。two-step(Sequential)包含了两个阶段：proposal和regression。one-step直接并行输出2D和3D信息。</p><p>下图按照时间顺序展示了3D目标检测的相关工作，并标注了相机和lidar对应的融合层级。</p><figure><img src="/2020/09/12/pr-review_Image_PointCloud_Fusion/image-20200526193634386.png" alt="image-20200526193634386"><figcaption>image-20200526193634386</figcaption></figure><ol type="1"><li>2D proposal based sequential models 试图利用2D图像语义信息提供3D proposal的初始区域：利用现有的图像处理框架生成2D region proposal，然后投影到3D空间，2D-&gt;3D的投影过程有两种主要方法，其中之一是将图像平面边界框投影到3D点云空间，结果形成了一个视锥型搜索空间，第二种方法是将点云投影到图像平面，结果是使点云具有2D语义信息。 下面按照融合层级给出这方面的相关工作：<ol type="1"><li>Result-level Fusion:信息融合发生在最后result阶段 这种方法的直接直觉来源是利用现有的2D目标检测方法缩小3D目标检测的搜索区域。最直接的方法就是将2D bbox反投影到3D空间，这样将多个感兴趣的小区域替代整个点云的处理以减少计算量，然而这种方法由于采用了2D bbox的检测结果因此整体性能会受限于2D detector的性能。Result-level Fusion核心思想是不利用多模态的数据进行互补，只是用于减少计算量。 早期的工作有 <a href="https://arxiv.org/abs/1711.08488" target="_blank" rel="noopener">F-PointNet</a>将图像生成的2d bbox反投影得到的视锥体区域点云送入PointNet中。<a href="https://arxiv.org/abs/1803.00387" target="_blank" rel="noopener">A general pipeline for 3d detection of vehicles</a>这篇论文中在2D到3D proposal生成阶段加入了额外的基于模型拟合方法的细化操作，将感兴趣区域内的背景点去除，将过滤后的点送入bbox回归网络中。<a href="https://arxiv.org/abs/1811.03818" target="_blank" rel="noopener">RoarNet</a>将细化操作用神经网络代替。 这些方法存在的问题是：假设得到的seed region仅包含一个目标，这对于拥挤场景和小目标(如行人)是不合理的。 该问题的解决方法有将2D目标检测器替换为2D语义分割网络,这样region-wise级别的提议改为point-wise级别的提议。<a href="https://arxiv.org/abs/1812.05276" target="_blank" rel="noopener">Intensive Point-based Object Detector :IPod</a> 在这个方向上做了相关工作，首先将点云投影到图像中利用2D语义分割信息过滤背景点。</li></ol><p>(2)Multi-level Fusion:结合result-level和feature-level。 典型的工作有<a href="https://arxiv.org/abs/1711.10871" target="_blank" rel="noopener">PointFusion</a>,利用现有2D目标检测器生成2Dbbox，通过将点云投影到图像平面中选择对应在bbox中的点，最终分别通过Resnet和Pointnet基础架构在每一个proposal上融合图像和点云特征 预测3D目标，然而在proposal阶段仅仅利用了图像这一个模态。<a href="https://arxiv.org/abs/1901.02237" target="_blank" rel="noopener">SIFRNet</a>中frustum proposal首先从图像中生成，在frustum proposal中的点云特征与对应的图像特征融合用于最终3d bbox的回归。IPod</p><p>(3)feature-level Fusion:多模态融合 多模态融合的早期尝试是在像素层级pixel-wise上进行的，将3D几何特征通过某些方式(例如鸟瞰图)转换为2D图像格式，然后附加到图像通道上，基本理想是将3D几何特征投影到图像平面上然后利用现有的图像处理框架直接处理，这种方法的输出也是在限制于图像平面中，不是3D空间物体检测的理想方式。<a href="https://arxiv.org/abs/1407.5736" target="_blank" rel="noopener">DepthRCNN</a>编码3D几何信息(HHA，来自RGBD)到相机RGB通道中。<a href="https://ieeexplore.ieee.org/document/7487370" target="_blank" rel="noopener">Fusing lidar and images for pedestrian detection using convolutional neural networks</a>这篇论文中进行了扩展，3D几何信息(HHA)由lidar产生。 为了在3D空间中更准的定位物体，目前常用point-wise层级上的融合，通过这种方式图像与点云中的点一一关联。<a href="https://arxiv.org/abs/1911.10150" target="_blank" rel="noopener">PointPainting</a>将点云投影到2D语义分割图中(利用之前提到过的Ipod)，然而除了利用2D语义过滤点云，2D语义仅简单地附加到点云中作为额外的通道。</p></li><li><p>3D proposal based sequential model</p><p>​ 相较于2D proposal,该方法直接从2D/3D数据生成3D Proposal。消除2D到3D转换的阶段大大缩小了目标检测的3D搜索空间。通用的生成3D proposal的方法有多视角(multi-view)或者点云体素化(voxelization)</p><ul><li>多视角方法(multi-view)利用点云的鸟瞰图(bird'eye view,BEV)进行3D proposal生成。鸟瞰图保留物体的旋转方向和x,y坐标信息。</li><li>点云体素化(voxelization)将原先连续的不规则的数据结构转换为离散的规则的数据结构，这样可以直接利用3D CNN,缺点是损失了空间分辨率。</li></ul><p>​ (1) Feature-level fusion: ​ 从BEV表示生成3D Proposal的重要工作是<a href="https://arxiv.org/abs/1611.07759" target="_blank" rel="noopener">MV3D</a>,利用lidar特征图(包括height,density,intensity)生成3D候选区域，然后将他们投影到前视图(front view)与图像数据融合进行边界框回归。融合发生在Roi pooling阶段，因此是ROI-level层级的融合，这项工作中存在的问题有通过BEV生成3D proposal过程中假设所有的目标都被捕获，针对小目标物体(行人，骑自行车的人)的识别可能表现并不是很好，因为可能被其他大的目标遮挡。其次，小目标在连续的卷积下采样过程中可能丢失。同时，在roipooling过程中进行融合可能会损失细粒度信息。 ​ 为了提升对小目标的检测能力，<a href="https://arxiv.org/abs/1712.02294" target="_blank" rel="noopener">Aggregate View Object Detection network (AVOD)</a>通过同时利用BEV和图像特征提升MV3D中的proposal阶段。图像分支利用auto-encoder结构上采样最终特征图到它原始大小。<a href="http://150.162.46.34:8080/icassp2019/ICASSP2019/pdfs/0001992.pdf" target="_blank" rel="noopener">Scanet</a>中也实现了encoder-decoder并利用了Spatial-Channel Attention(SCA)和Extension Spatial Unsample(ESU)模块。</p><p>​ 上述方法以object为中心在ROI-pooling阶段(roi-wise fusion)进行融合损失了细粒度的几何信息。<a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Ming_Liang_Deep_Continuous_Fusion_ECCV_2018_paper.pdf" target="_blank" rel="noopener">ContFuse</a>通过在point-wise进行融合应对这个问题，这种point-wise融合通过<a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Wang_Deep_Parametric_Continuous_CVPR_2018_paper.pdf" target="_blank" rel="noopener">continuous convolutions</a> 实现。首先提取BEV视图中每一个像素的K个最近邻点，然后将这些点映射到图像平面中以检索对应的图像特征，最终融合的特征向量根据与期望像素的几何偏移加权送入MLP中。 然而这种融合方法由于点云的稀疏性可能不能充分融合高分辨率图像的特征。<a href="http://www.cs.toronto.edu/~byang/papers/mmf.pdf" target="_blank" rel="noopener">Multi-task multisensor fusion for 3d object detection</a>中综合了多个层级的融合策略(signal-level,feature-level,multi-view,depth completion)。上述基于point-wise/pixel-wise层级融合会产生特征模糊(feature blurring)的问题,即可能存在点云中的点对应多个图像中的像素或者反之，这会混淆数据融合。</p><p>​ 直接将RGB图像信息附加作为voxel的额外通道是最简单的组合体素点云和图像的方法，这种方法存在的问题是体素化表示破坏了细粒度局部几何信息，同时由于图像和点云分辨率不一致是的融合过程效率较低。</p></li><li><p>One-step Models 一步模型将proposal generation和bbox回归的过程合为一步。<a href="https://arxiv.org/abs/1904.01649" target="_blank" rel="noopener">MVX-Net</a>介绍了两种方法用于在point-wise和voxel-wise层级融合图像和点云，采用预训练的2D CNN用于图像特征提取，同时采用<a href="https://arxiv.org/abs/1711.06396" target="_blank" rel="noopener">VoxelNet</a>作为框架从融合的点云中预测物体。在point-wise融合方法中，点云首先被映射到图像特征空间用于在VoxelNet网络处理前提取图像特征。在Voxel-wise融合方法中，在将非空的voxel映射到图像特征空间之前首先体素化点云。 <a href="https://arxiv.org/abs/1903.08701" target="_blank" rel="noopener">Lasernet</a>是一个多任务和多模态网络，用于融合点云和图像的3D目标检测和3D语义分割。两个CNN并行处理lidar产生的深度图像和前视图并且通过将点投影到图像平面关联对应的图像特征。特征图送入LaserNet中预测每一个点bbox的分布并生成最终的3D proposal。</p></li></ol><h3 id="d3d-semantic-segmentation">2.3 2D/3D semantic segmentation</h3><p>回顾camera-lidar融合的2D/3D语义分割，实例分割方法，下图按时间顺序给出3D语义分割网络和对应的融合等级。 <img src="/2020/09/12/pr-review_Image_PointCloud_Fusion/image-20200527211057103.png" alt="image-20200527211057103" style="zoom:67%;"></p><ol type="1"><li>2D Semantic Segmentation<ol type="1"><li>Feature-level Fusion: <a href="https://arxiv.org/abs/1808.03833" target="_blank" rel="noopener">Self-supervised model adaptation for multimodal semantic segmentation</a>采用不同深度多阶段特征融合进行语义分割。<a href="https://arxiv.org/abs/1809.07941" target="_blank" rel="noopener">Lidarcamera fusion for road detection using fully convolutional neural networks</a>论文中通过利用上采样的深度图和图像来进行语义分割，通过上采样来自点云的稀疏深度图同时利用相机图像获得密集的深度图。</li></ol></li><li>3D Semantic Segmentation<ol type="1"><li>Feature-level Fusion:</li></ol><p>​ <a href="https://arxiv.org/abs/1803.10409" target="_blank" rel="noopener">3DMV</a>是融合图像语义和点云(RGBD)特征的多视角网络，来自多个视角的图像特对齐后通过2D卷积网络提取特征并映射到3D空间。这种基于体素的方法性能受限于体素的分辨率。针对该问题，<a href="https://arxiv.org/abs/1908.00478" target="_blank" rel="noopener">UPF</a>是基于点的3D语义分割框架，基于根本方法是<a href="https://arxiv.org/abs/1706.02413" target="_blank" rel="noopener">PointNet++</a></p></li><li><p>Instance Segmentation</p><p>略</p></li></ol><blockquote><p>上述各种方法，目前在自动驾驶的实际场景中应用较少，没有细看，如果以后用到，可直接参考论文</p></blockquote><h3 id="d-object-tracking">2.4 3D Object Tracking</h3><p>多目标跟踪是自动驾驶感知不可缺少的环节，针对camera-lidar融合的目标跟踪方法总结如下，性能评价指标参考<a href="http://www.cvlibs.net/publications/Geiger2012CVPR.pdf" target="_blank" rel="noopener">KITTI</a></p><figure><img src="/2020/09/12/pr-review_Image_PointCloud_Fusion/image-20200527220324567.png" alt="image-20200527220324567"><figcaption>image-20200527220324567</figcaption></figure><ol type="1"><li><p>Detection-Based Tracking(DBT)基于检测器的目标跟踪方法</p><p>DBT(Tracking-by-Detection)跟踪框架包含两个阶段：第一步通过检测器检测目标，第二步进行数据关联，将同一目标按照时间轴构成一条跟踪轨迹。<a href="https://arxiv.org/abs/1806.11534" target="_blank" rel="noopener">End-to-end learning of multi-sensor 3d tracking by detection</a>提出了端到端的DBT训练框架，为了实现端到端的学习，检测和匹配通过一个深度结构化模块(DSM)实现。 貌似都是离线跟踪的方法，目前暂时用不到，详细看论文。</p></li><li><p>Detection-Free Tracking(DFT) <a href="https://arxiv.org/abs/1904.07537" target="_blank" rel="noopener">Complexer-YOLO</a>是一个解耦3D目标检测和跟踪的框架。</p></li></ol><h2 id="未来研究方向">3. 未来研究方向</h2><p>感知模块是无人驾驶中下游决策，规划，控制的前提，它的性能和可靠性是整个无人驾驶系统性能优劣的首要因素。因此，利用相机和lidar融合以更好的理解复杂环境。下表给出了提升camera-lidar融合算法的性能，可靠性以及相关工程实践的一些挑战。</p><figure><img src="/2020/09/12/pr-review_Image_PointCloud_Fusion/image-20200527223109666.png" alt="image-20200527223109666"><figcaption>image-20200527223109666</figcaption></figure><p>融合的发展趋势有：</p><ul><li><p>2D to 3D:</p></li><li><p>sing-task ot multi-tasks:考虑到移动平台的计算性能和实时性需求，网络往往需要多任务输出。</p></li><li><p>singal-level to multi-level Fusion:早期的工作集中于输入信号层级的融合，例如将点云投影到图像平面等，最近很多模型视图融合在多个层级上。</p></li></ul><p>深度估计：单目深度估计，融合深度估计</p><p>故障检测：相机在不利环境下(例如重影，光线不足，)</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODYwOTkzNg==&amp;mid=2247500603&amp;idx=1&amp;sn=c8df20167dffe5ba6c4e850555293ad4&amp;chksm=ea070544dd708c5270a1380f95ff52386204a96d1c2b026697ded4e7f9089d6fc114ff62a026&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1586875366394&amp;sharer_shareid=251c7f638257dafd65dd3f515ad533cb&amp;key=0b6318e4d66e8464fd862767da5f8c51c286edb23c13d2df9762e0649316e1f8d9a5a96d352ad1c430a4868e0b78a343a61c26068054087211927f5b411c6fb5db9b716f1c218582b7d9d8347625c14b&amp;ascene=1&amp;uin=MjU0MTcyMzYzNw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=A9Nk8Y3UMCPDtCIcH%2B6a0Lg%3D&amp;pass_ticket=M9LuIPgA%2BNn%2FM1hrwO9oOAOPG2geFBvwMZ15XwJ5RivYEn75h8Qufft2SOni6CDL" target="_blank" rel="noopener">自动驾驶相机-激光雷达深度融合综述及展望</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传感器融合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DS(Dempster-Shafer)多元信息融合证据理论</title>
      <link href="/2020/09/12/DS_evidence_theory/"/>
      <url>/2020/09/12/DS_evidence_theory/</url>
      
        <content type="html"><![CDATA[<p>70年代初，Dempster和Shafer建立的一套数学理论，称为D-S证据理论，是贝叶斯推理方法的推广，广泛应用于多源信息融合，不确定性推理。</p><p>贝叶斯理论通过已知的三个概率推断第四个概率，即在某些已知条件下，推断某事件发生的概率， <span class="math display">\[P(A|B)=\frac{P(B|A)P(A)}{P(B)}\\\]</span> P(A|B)为已知B发生情况下A的后验概率 P(A)时A的先验概率(边缘概率) P(B|A)为以子A发生的情况下B的后验概率 P(B)是B的先验概率，通常表示为<span class="math inline">\(P(B)=\sum_{j}P(B|A_j)P(A_j),A_j为事件几何的各子集\)</span> 也可表述为:**后验概率 = (似然性*先验概率)/标准化常量** 所以A发生的后验概率与A的先验概率和似然度的乘积成正比。</p><p>是否有不需要先验概率直接获得后验概率的方法呢？证据的本质就是基于观测对不同的假设赋予权值的一种方法： (1) 能够处理任意数量的假设 (2) 能够把证据的权值解释为一种函数，而这个函数把假设的先验概率空间映射到基于观测的假设后验概率空间。</p><a id="more"></a><h3 id="ds证据理论的基本概念--mass函数信度函数似真度函数">1. DS证据理论的基本概念--mass函数、信度函数、似真度函数</h3><p><strong>定义1：基本概率分配（BPA）</strong></p><blockquote><p>DS证据理论设空间<span class="math inline">\(H\)</span>表示某个有限集合，称为假设空间；假设<span class="math inline">\(P(H)\)</span>表示<span class="math inline">\(H\)</span>所有子集(若样本空间有N个元素，则所有的子集有<span class="math inline">\(2^N\)</span>个)构成的集类(称为H的幂集)，则映射<span class="math inline">\(m:P(H){\rightarrow}[0,1]\)</span>称为一个基本概率赋值(BPA)或<code>mass</code>函数，需满足下列条件： (1) <span class="math inline">\(m(\phi)=0\)</span> (2) <span class="math inline">\(\sum_{A\subset H}m(A)=1\)</span>（假设空间所有子集的mass之和为1）时 则<code>mass</code>函数实际上是对各种假设的评价权值。注意基本概率赋值不是概率，不满足可列可加性。</p></blockquote><p>实际就是分配给H的每一个子集一个实数，且空集的基本概率数为0，所有子集的概率分配数之和为1，这个实数位于[0,1]之间，同时这个映射关系不是唯一的且概率分配函数与概率是不同的。</p><p>设样本空间<span class="math inline">\(H=\{红，黄，蓝\}\)</span> M({红})=0.3 (认为是红色的信任度为0.3)，M({黄})=0，M({蓝})=0.1，M({红，黄})=0.2，M({红，蓝})=0.2(认为是红色或是蓝色的信息度为0.2)，M({黄，蓝})=0.1，M({红，黄，蓝})=0.1(表示命题不知道是红色，黄色还是蓝色，这0.1的权值不知道怎么分配), M({<span class="math inline">\(\Phi\)</span>})=0,但M({红})+M({黄})+M({蓝})=0.4$$1.0 所以概率分配函数与概率不同。</p><p>参考韩崇昭老师的《多源信息融合》举个栗子： 两个医生同时给一个病人看病，甲医生认为0.9可能性是感冒，0.1可能性是某种病症；乙医生认为0.2可能性<strong>不是</strong>感冒，0.8可能性是某种病症。此时假设空间位<span class="math inline">\(H=\{h,\bar h\}\)</span> ,h是诊断为感冒，<span class="math inline">\(\bar h\)</span>表示诊断为不是感冒。<span class="math inline">\(P(H)=\{\Phi,\{h\},\{\bar h\},H\}\)</span>,<span class="math inline">\(\Phi\)</span>表示为不可能事件：“既是感冒又不是感冒”，<span class="math inline">\(H\)</span>表示事件“可能是感冒，又可能不是感冒”，则构造的mass函数为： <span class="math inline">\(m_1(h)=0.9\)</span> 表示甲医生认为是感冒的可能性； <span class="math inline">\(m_1(H)=0.1\)</span> 表示甲医生认为是某种说不清的病症的可能性 <span class="math inline">\(m_2(\bar h)=0.2\)</span>表示乙医生认为不是感冒的可能性； <span class="math inline">\(m_2(H)=0.8\)</span>表示乙医生认为是某种说不清的病症的可能性 问题是判断患者是感冒的可能性是多少？ 需要注意的是<span class="math inline">\(H=\{h\}\cup\{\bar h\}\)</span>,且<span class="math inline">\(\{h\}\cap\{\bar h\}=\Phi\)</span> 但 <span class="math inline">\(m_1(H)\neq m_1(h)+m_1(\bar h)\)</span> 即mass函数不是表示的概率。</p><p><strong>定义2：信度函数(belief function)</strong></p><blockquote><p>设<span class="math inline">\(H\)</span>表示某个有限集合，<span class="math inline">\(P(H)\)</span>表示<span class="math inline">\(H\)</span>的所有子集构成的集类，映射<span class="math inline">\(Bel:P(H)\rightarrow[0,1]\)</span>称为信度函数， <span class="math inline">\(Bel(A)=\sum_{B\subseteq A }M(B)\)</span>,<span class="math inline">\(\forall A\subseteq H\)</span> ,如果满足： (1) <span class="math inline">\(Bel(\Phi)=0;Bel(H)=1\)</span> (样本空间的信度函数为1) (2) 对<span class="math inline">\(H\)</span>中的任意子集<span class="math inline">\(A_1,A_2,\dots,A_n\)</span>有： <span class="math display">\[Bel(\bigcup_{i=1}^{n}A_i) \ge \sum_{I\subseteq\{1,2,...,n\}\\I\neq\Phi}(-1)^{|I|+1}Bel(\bigcap_{i\in I}A_i)\]</span> 其中,<span class="math inline">\(|I|\)</span>表示集合<span class="math inline">\(I\)</span>中的元素个数。 说明信度函数表示对假设命题A为真的信任程度估计的下限(悲观估计)，假定仅对<span class="math inline">\(H\)</span>中的任意两个子集<span class="math inline">\(A_1,A_2\)</span>有： <span class="math display">\[Bel(A_1 \cup A_2)\ge Bel(A_1)+Bel(A_2)-Bel(A_1\cap A_2)\]</span> 此时称<span class="math inline">\(Bel:P(H)\rightarrow[0,1]\)</span>为弱信度函数(weak belief function)</p></blockquote><p>设样本空间<span class="math inline">\(H=\{红，黄，蓝\}\)</span> M({红})=0.3，M({黄})=0，M({红，黄})=0.2 Bel({红，黄})=M({红})+M({黄})+M({红，黄})=0.3+0+0.2=0.5,即对命题认为是红色或黄色的总信任程度为0.5</p><p><strong>定义3： 似真度函数（plausibility function）</strong></p><blockquote><p>假设<span class="math inline">\(H\)</span>表示某个有限集合，<span class="math inline">\(P(H)\)</span>表示H的所有子集构成的集类，映射<span class="math inline">\(Pl:P(H)\rightarrow[0,1]\)</span>称为似真度函数，如果满足： (1) <span class="math inline">\(Pl(\Phi)=0;Pl(H)=1\)</span> (2) 对H中的任意子集<span class="math inline">\(A_1,A_2,...,A_n\)</span>有 <span class="math display">\[Pl(\bigcap_{i=1}^{n}A_i) \le \sum_{I\subseteq\{1,2,...,n\}\\I\neq\Phi}(-1)^{|I|+1}Pl(\bigcup_{i\in I}A_i)\]</span> 说明似真度函数表示对假设的信任程度估计的上限(乐观估计)。假定仅对H中的任意两个子集<span class="math inline">\(A_1,A_2\)</span>有： <span class="math display">\[Pl(A_1 \cap A_2)\le Pl(A_1)+Pl(A_2)-Pl(A_1\cup A_2)\]</span> 则称<span class="math inline">\(Pl:P(H)\rightarrow[0,1]\)</span>为弱似真度函数。</p></blockquote><p><strong>定理1：</strong></p><blockquote><p><span class="math inline">\(Pl(A)=1-Bel(A^{\lnot}),\forall A\subseteq H\)</span> ，$A $表示A的补集 <span class="math inline">\(Bel(A)=1-Pl(A\lnot)\)</span></p></blockquote><p><strong>定理2：</strong></p><blockquote><p><span class="math inline">\(Bel(A)=\sum_{D\subseteq A}m(D)\)</span> <span class="math inline">\(Pl(A) =\sum_{D\cap A\neq\Phi}m(D)\)</span></p></blockquote><p>例：设样本空间<span class="math inline">\(H=\{红，黄，蓝\}\)</span> M({红})=0.3，M({黄})=0，M({红，黄})=0.2 Bel({红，黄})=M({红})+M({黄})+M({红，黄})=0.5 Pl({蓝})=1-Bel({蓝}<span class="math inline">\(\lnot\)</span>)=1-Bel({红，黄})=1-0.5=0.5 表示</p><p><code>信度函数</code>和<code>似真度函数</code>表征了一个命题不确定性的上下限，两者之间的关系如下： 因为 <span class="math inline">\(Bel(A)+Bel(\lnot A)=\sum_{B\subseteq A}M(B)+\sum_{C\subseteq\lnot A}M(C)\le\sum_{E\subseteq D}M(E)=1\)</span></p><p>所以 <span class="math inline">\(Pl(A)-Bel(A)=1-Bel(\lnot A)-Bel(A)=1-(Bel(\lnot A)+Bel(A))\ge0\)</span></p><p><span class="math inline">\(Pl(A)\ge Bel(A)\)</span> 其中<span class="math inline">\(Bel(A):对命题A为真的信任程度\)</span> <span class="math inline">\(Pl(A):对A为非假的信任程度\)</span> <span class="math inline">\(A(Bel(A),Pl(A))\)</span>为命题A信任程度的下限和上限，下面给出几种特殊情况：</p><table><thead><tr class="header"><th>命题A信任度的上下限</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>A(0,1)</td><td>表示对命题A一无所知</td></tr><tr class="even"><td>A(1,1)</td><td>A为真</td></tr><tr class="odd"><td>A(0,0)</td><td>A为假</td></tr><tr class="even"><td>A(a,1),0&lt;a&lt;1</td><td>对命题A部分信任，信任程度为a</td></tr><tr class="odd"><td>A(0,b),0&lt;b&lt;1</td><td>对命题$A <span class="math inline">\(部分信任，信任程度为b | | A(a,b) | 表示对命题A和\)</span>A$同时信任</td></tr></tbody></table><p>设球的颜色样本空间<span class="math inline">\(H=\{红，黄，蓝\}\)</span> M({红})=0.3 ，M({黄})=0，M({蓝})=0.1，M({红，黄})=0.2，M({红，蓝})=0.2，M({黄，蓝})=0.1，M({红，黄，蓝})=0.1 则球是红色命题的信任度的上下限为A(0.3,0.8)</p><p><strong>定理3：</strong></p><blockquote><p>设H是有限集合，Bel和Pl分别是定义在P(H)上的信度函数和似真度函数，<span class="math inline">\(z_1,z_2,...,z_l\in O\)</span>为<span class="math inline">\(l\)</span>个互斥且完备的观测，即<span class="math inline">\(\mu_(z_i)\)</span>表示<span class="math inline">\(z_i\)</span>发生的概率，满足<span class="math inline">\(z_i \cap z_j=\Phi,\forall i\neq j\)</span>且<span class="math inline">\(\sum_{i=1}^l \mu(z_i)=1\)</span>对于每个<span class="math inline">\(z_i \in O\)</span>,当<span class="math inline">\(m(\centerdot|z_i),Bel(\centerdot|z_i),Pl(\centerdot|z_i)\)</span>分别是H上的mass函数，信度函数，似真度函数时，则： <span class="math display">\[m(A)=\sum_{i=1}^{l}m(A|z_i)\mu(z_i)\\Bel(A)=\sum_{i=1}^{l}Bel(A|z_i)\mu(z_i)\\m(A)=\sum_{i=1}^{l}Pl(A|z_i)\mu(z_i)\]</span> 仍分别是H上的mass函数，信度函数和似真度函数。</p></blockquote><h3 id="dempster-shafer证据的组合">2. Dempster-Shafer证据的组合</h3><p>意义在于两个不同的可能性判断，经过合成变为统一的判断，需要注意的是这是一种集合运算，与概率的数值计算不同。</p><p><strong>定理4：</strong></p><blockquote><p>设<span class="math inline">\(m_1,m_2\)</span>是H上的两个mass函数，则 <span class="math inline">\(m(\Phi)=0\)</span> <span class="math inline">\(m(A)=\frac{1}{N}\sum_{E\cap F=A}m_1(E)m_2(F),A\neq \Phi\)</span> 是mass函数，其中<span class="math inline">\(N=\sum_{E\cap F\neq\Phi}m_1(E)m_2(F)&gt;0\)</span>为归一化系数。 一般记为<span class="math inline">\(m=m_1\oplus m_2\)</span> 扩展到一般情况下：<span class="math inline">\(m(A)=(m_1 \oplus...\oplus m_n)=\frac{1}{N}\sum_{\bigcap _{i=1}^{n}E_i=A}\prod_{i=1}^n m_i(E_i),A\neq \Phi\)</span> 如果<span class="math inline">\(N=0\)</span>，则由于mass函数存在矛盾不能合成。</p></blockquote><p>例： D={黑，白}，且设 <span class="math inline">\(M_2\)</span>({黑}，{白}，{黑，白}，<span class="math inline">\(\Phi\)</span>)=(0.6, 0.3, 0.1, 0) <span class="math inline">\(M_1\)</span>({黑}，{白}，{黑，白}，<span class="math inline">\(\Phi\)</span>)=(0.3, 0.5, 0.2, 0) 则 <span class="math display">\[\begin{align}N&amp;=\sum_{E\cap F\neq\Phi}m_1(E)m_2(F)\\&amp;=1-\sum_{E\cap F=\Phi}m_1(E)m_2(F)\\&amp;=1-[M_1(\{黑\})*M_2(\{白\})+M_1(\{白\})*M_2(\{黑\})]\\&amp;=1-[0.3*0.3+0.5*0.6]=0.61\\ \\M(\{黑\})&amp;=\frac{1}{0.61}[M_1(\{黑\})*M_2(\{黑\})+M_1(\{黑\})*M_2(\{黑,白\})+M_1(\{黑，白\})*M_2(\{黑\})]\\&amp;=\frac{1}{0.61}*[0.3*0.6+0.3*0.1+0.2*0.6]=0.54\end{align}\]</span></p><h3 id="证据推理">3. 证据推理：</h3><p><strong>定理5：</strong></p><blockquote><p>设m是假设空间H上的mass函数， P(H)表示H的所有子集构成的幂集，F是H上的概率分布，则有 <span class="math inline">\(v:p(H)\rightarrow[0,1]\)</span> ,满足<span class="math inline">\(v(\Phi)=0\)</span>，且： <span class="math display">\[v(A)=\frac{m(A)*F(A)}{\sum_{\Phi \neq B\subseteq H}m(B)*F(B)}\]</span> 以及<span class="math inline">\(\gamma:P(H)\rightarrow[0,,1]\)</span>,满足<span class="math inline">\(\gamma(\Phi)=0\)</span>,且 <span class="math display">\[\gamma(A)=\frac{m(A)/F(A)}{\sum_{\Phi\neq B\subseteq H}m(B)/F(B)}\]</span> 仍是H上的mass函数。</p></blockquote><p><strong>定理6：</strong></p><blockquote><p>设H是有限集合，<span class="math inline">\(m_1,m_2\)</span>是定义在P(H)上的mass函数，P是H上的概率分布，则有<span class="math inline">\(v:P(H)\rightarrow[0,1]\)</span> ,满足 <span class="math inline">\(v(\Phi)=0\)</span>,且 <span class="math display">\[v(A)=\frac{(r_1\oplus r_2)(A)*F(A)}{\sum_{\Phi \neq D\subseteq H}(r_1 \oplus r_2)(D)*F(D)},A\in P(H)\]</span> 仍是H上的mass函数，其中： <span class="math display">\[\gamma_i(A)=\frac{m_i(A)/F(A)}{\sum_{\Phi\neq B\subseteq H}m_i(B)/F(B)},i=1,2\]</span> 记为<span class="math inline">\(v(A)=(m_1\otimes m_2)(A)\)</span></p></blockquote><p>证据推理的一般步骤为：</p><ol type="1"><li><p>计算mass函数<span class="math inline">\(m_i(A)\)</span>,即： <span class="math inline">\(m_i(A)=m(A|z_i)\mu_i(z_i)+m(A|\overline{z}_i)\mu_i(\overline{z}_i),i=1,..,l\)</span></p></li><li><p>利用先验概率F,计算mass函数<span class="math inline">\(\gamma_i(A)\)</span> <span class="math display">\[\gamma_i(A)=\frac{m_i(A)/F(A)}{\sum_{\Phi\neq B\subseteq H}m_i(B)/F(B)},i=1,2\]</span></p></li><li><p>利用Dempster-Shafer合成公式，计算mass函数<span class="math inline">\(\gamma(A)\)</span> <span class="math display">\[\gamma(A)=(r_1 \oplus r_2 \oplus ... \oplus r_l)(A)\]</span></p></li><li><p>计算mass函数<span class="math inline">\(v(A)\)</span> <span class="math display">\[v(A)=\frac{\gamma(A)*F(A)}{\sum_{\Phi \neq D\subseteq H}\gamma(D)*F(D)},A\in P(H)\]</span></p></li><li><p>计算信度函数和似真度函数， <span class="math display">\[Bel(A)=\sum_{D\subseteq A}v(D)\\Pl(A) =\sum_{D\cap A\neq\Phi}v(D)\]</span> 得到信任区间<span class="math inline">\([Bel(A),Pl(A)]\)</span></p></li></ol><p>例子： 设有规则： (1) 如果流鼻涕则感冒但非过敏性鼻炎(0.9),或过敏性鼻炎但非感冒(0.1) (2)如果眼发炎则感冒但非过敏性鼻炎(0.8),或过敏性鼻炎但非感冒(0.05)</p><p>有事实（先验概率）： (1) 小王流鼻涕(0.9) (2) 小王眼发炎(0.4) 问：小王患的啥病？</p><blockquote><p>首先取样本空间<span class="math inline">\(H=\{h_1,h_2,h_3\}\)</span> <span class="math inline">\(h_1\)</span>表示感冒但非过敏性鼻炎,<span class="math inline">\(h_2\)</span>表示过敏性鼻炎但非感冒，<span class="math inline">\(h_3\)</span>表示同时得了两种病 取下面的基本概率分配函数： <span class="math display">\[M_1(\{h_1\})=0.9*0.9=0.81\\M_1(\{h_2\})=0.9*0.1=0.09\\M_1(\{h_1,h_2,h_3\})=1-M_1(\{h_1\})-M_1(\{h_2\})=0.1\\M_2(\{h_1\})=0.4*0.8=0.32\\M_2(\{h_2\})=0.4*0.051=0.02\\M_2(\{h_1,h_2,h_3\})=1-M_2(\{h_1\})-M_2(\{h_2\})=0.66\\\]</span> 然后进行概率合成： <span class="math display">\[N=1-[M_1(\{h_1\})M_2(\{h_2\})+M_1(\{h_2\})M_2(\{h_1\})]=1-0.81*0.02-0.09*0.32=0.955\\M(\{h_1\})=\frac{1}{0.955}*[0.81*0.32+0.81*0.66+0.1*0.32]=0.865\\M(\{h_2\})=\frac{1}{0.955}*[0.09*0.02+0.09*0.66+0.1*0.02]=0.066\\M(\{h_1,h_2,h_3\})=1-0.865-0.066=0.069\]</span> 信任度： <span class="math display">\[Bel(\{h_1\})=M(\{h_1\})=0.865\\Bel(\{h_2\})=M(\{h_2\})=0.066\\\]</span> 似真度： <span class="math display">\[Pl(\{h_1\})=M(\{h_1\})+M(\{h_1,h_2,h_3\})=0.934\\Pl(\{h_2\})=M(\{h_2\})+M(\{h_1,h_2,h_3\})=0.066+0.069=0.135\]</span> 则事件<span class="math inline">\(\{h_1\}\)</span>的信任区间为[0.865,0.934],而事件<span class="math inline">\(\{h_2\}\)</span>的信任区间为[0.066,0.135],因此小王应该是感冒了。</p></blockquote><h3 id="mass函数的获取方法">4.mass函数的获取方法</h3><ol type="1"><li>考虑目标类型数和环境加权系数确定mass函数</li><li>基于统计证据的mass函数获取方法</li><li>基于隶属度函数生成mass函数的方法</li></ol><h3 id="证据理论存在的主要问题与发展">5.证据理论存在的主要问题与发展</h3><h3 id="参考">参考</h3><p><a href="https://blog.csdn.net/am45337908/article/details/48832947" target="_blank" rel="noopener">CSDN:D-S证据理论学习笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> 多传感器融合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多传感器融合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo lidar算法--recognition component（一）</title>
      <link href="/2020/05/13/apollo-lidar_tracker/"/>
      <url>/2020/05/13/apollo-lidar_tracker/</url>
      
        <content type="html"><![CDATA[<p>该组件实现lidar的目标跟踪算法，该组件接收segment得到的检测物体信息，然后建立帧与帧之间的联系以实现帧间同一目标速度等动态信息的预测。</p><p><code>Init-&gt;Preprocess-&gt;MapManager-&gt;Segmentaion-&gt;ObjectBuilder-&gt;ObjectFilter-&gt;Classifier-&gt;Tracker</code></p><a id="more"></a><h2 id="一-组件初始化和配置">一、 组件初始化和配置</h2><h3 id="外部参数配置">1. 外部参数配置</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 组件的dag文件配置</span><br><span class="line">components &#123;</span><br><span class="line">    class_name : <span class="string">"RecognitionComponent"</span></span><br><span class="line">    config &#123;</span><br><span class="line">      name: <span class="string">"RecognitionComponent"</span></span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/lidar/recognition_conf.pb.txt"</span></span><br><span class="line">      readers &#123;</span><br><span class="line">          channel: <span class="string">"/perception/inner/SegmentationObjects"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>组件的配置参数：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># `recognition_conf.pb.txt`</span><br><span class="line">main_sensor_name: <span class="string">"velodyne64"</span></span><br><span class="line">output_channel_name: <span class="string">"/perception/inner/PrefusedObjects"</span></span><br></pre></td></tr></table></figure><h3 id="初始化">2. 初始化</h3><p>创建writer的通道名称为<code>/preception/inner/PrefusedObjects</code>，消息类型为:<code>&lt;SensorFrameMessage&gt;</code> 与相机最终的输出预融合类型相同。 然后进行算法组件的初始化： 使用的lidar算法组件类<code>&lt;LidarObstacleTracking&gt;</code></p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>multi_target_tracker</td><td>MlfEngine</td><td>多目标跟踪器的名称</td><td>Class</td></tr><tr class="even"><td>fusion_classifier</td><td>FusedClassifier</td><td>分类器的名称</td><td>Class</td></tr></tbody></table><p><strong>multi_target_tracker（多雷达融合）进行初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> MultiTargetTrackerInitOptions&amp; options =</span></span></span><br><span class="line"><span class="function"><span class="params">              MultiTargetTrackerInitOptions())</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><p>参数：<code>multi_lidar_fusion.config</code> -&gt; <code>multi_lidar_fusion/mlf_engine.conf</code></p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>use_histogram_for_match</td><td>true</td><td></td><td></td></tr><tr class="even"><td>histogram_bin_size</td><td>10</td><td></td><td></td></tr><tr class="odd"><td>output_predict_objects</td><td>false</td><td></td><td></td></tr><tr class="even"><td>reserved_invisible_time</td><td>0.3</td><td></td><td></td></tr><tr class="odd"><td>use_frame_timestamp</td><td>true</td><td></td><td></td></tr></tbody></table><p>参数初始化完成后，进行<code>tracker_</code>,<code>matcher_</code> 的初始化 <code>matcher_</code>的功能实现类为<code>&lt;MlfTrackObjectMatcher&gt;</code></p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>foreground_matcher_method</td><td>&quot;MultiHmBipartiteGraphMatcher&quot;</td><td></td><td></td></tr><tr class="even"><td>background_matcher_method</td><td>&quot;GnnBipartiteGraphMatcher&quot;</td><td></td><td></td></tr><tr class="odd"><td>bound_value</td><td>100</td><td></td><td></td></tr><tr class="even"><td>max_match_distance</td><td>4.0</td><td></td><td></td></tr></tbody></table><p><code>track_object_distance_</code>的功能实现类<code>&lt;MlfTrackObjectDistance&gt;</code></p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>location_dist_weight</td><td>“ ”</td><td></td><td></td></tr><tr class="even"><td>direction_dist_weight</td><td>0</td><td></td><td></td></tr><tr class="odd"><td>bbox_size_dist_weight</td><td>0</td><td></td><td></td></tr><tr class="even"><td>point_num_dist_weight</td><td>0</td><td></td><td></td></tr><tr class="odd"><td>histogram_dist_weight</td><td>0</td><td></td><td></td></tr><tr class="even"><td>centroid_shift_dist_weight</td><td>0</td><td></td><td></td></tr><tr class="odd"><td>bbox_iou_dist_weight</td><td>0</td><td></td><td></td></tr></tbody></table><p><code>tracker_</code>的功能实现类为<code>&lt;MlfTracker&gt;</code></p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>filter_name</td><td>&quot;MlfShapeFilter&quot;</td><td></td><td></td></tr><tr class="even"><td>filter_name</td><td>&quot;MlfMotionFilter&quot;</td><td></td><td></td></tr></tbody></table><p><code>MlfShapeFilter</code>初始化：</p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>bottom_points_ignore_threshold</td><td>0.1</td><td></td><td></td></tr><tr class="even"><td>top_points_ignore_threshold</td><td>1.6</td><td></td><td></td></tr></tbody></table><p><code>MlfMotionFilter</code>初始化：</p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>use_adaptive</td><td>true</td><td></td><td></td></tr><tr class="even"><td>use_breakdown</td><td>true</td><td></td><td></td></tr><tr class="odd"><td>use_convergence_boostup</td><td>true</td><td></td><td></td></tr><tr class="even"><td>init_velocity_variance</td><td>5.0</td><td></td><td></td></tr><tr class="odd"><td>init_acceleration_variance</td><td>0.6</td><td></td><td></td></tr><tr class="even"><td>measured_velocity_variance</td><td>0.6</td><td></td><td></td></tr><tr class="odd"><td>predict_variance_per_sqrsec</td><td>50.0</td><td></td><td></td></tr><tr class="even"><td>boostup_history_size_minimum</td><td>3</td><td></td><td></td></tr><tr class="odd"><td>boostup_history_size_maximum</td><td>6</td><td></td><td></td></tr><tr class="even"><td>converged_confidence_minimum</td><td>0.5</td><td></td><td></td></tr><tr class="odd"><td>noise_maximum</td><td>0.1</td><td></td><td></td></tr><tr class="even"><td>trust_orientation_range</td><td>40</td><td></td><td></td></tr></tbody></table><p><code>&lt;MlfMOtionRefiner&gt;</code>的参数初始化：</p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>claping_acceleration_threshold</td><td>10</td><td></td><td></td></tr><tr class="even"><td>claping_speed_threshold</td><td>1</td><td></td><td></td></tr></tbody></table><p><strong>fusion_classifier 初始化</strong> <code>&lt;FusedClassifier&gt;</code>参数：<code>../data/.../fused_classifier/fused_classifier.conf</code></p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>one_shot_fusion_method</td><td>&quot;CCRFOneShotTypeFusion&quot;</td><td></td><td></td></tr><tr class="even"><td>sequence_fusion_method</td><td>&quot;CCRFSequenceTypeFusion&quot;</td><td></td><td></td></tr><tr class="odd"><td>enable_temporal_fusion</td><td>true</td><td></td><td></td></tr><tr class="even"><td>temporal_window</td><td>20.0</td><td></td><td></td></tr><tr class="odd"><td>use_tracked_objects</td><td>true</td><td></td><td></td></tr></tbody></table><p><code>&lt;CCRFOneShotTypeFusion&gt;</code> 类参数：</p><table><colgroup><col style="width: 34%"><col style="width: 47%"><col style="width: 9%"><col style="width: 9%"></colgroup><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>classifiers_property_file_path</td><td>&quot;../fused_classifier/classifiers.property&quot;</td><td></td><td>数字矩阵</td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>transition_matrix_alpha</td><td>1.8</td><td></td><td></td></tr><tr class="even"><td>confidence_smooth_matrix_</td><td></td><td></td><td></td></tr><tr class="odd"><td>smooth_matrices_</td><td></td><td></td><td></td></tr></tbody></table><p><code>&lt;CCRFSequenceTypeFusion&gt;</code>类参数：</p><table><colgroup><col style="width: 33%"><col style="width: 47%"><col style="width: 9%"><col style="width: 9%"></colgroup><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>参数说明</th><th>参数类型</th></tr></thead><tbody><tr class="odd"><td>transition_property_file_path</td><td>&quot;../fused_classifier/transition.property&quot;</td><td></td><td>数字矩阵</td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr></tbody></table><hr><h2 id="二算法处理流程proc">二、算法处理流程Proc</h2><p>入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LidarProcessResult <span class="title">Process</span><span class="params">(<span class="keyword">const</span> LidarObstacleTrackingOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                           LidarFrame* frame)</span></span>;</span><br></pre></td></tr></table></figure><p>内部主要的两个处理函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi_target_tracker_-&gt;Track(tracker_options, frame);</span><br><span class="line">...</span><br><span class="line">fusion_classifier_-&gt;Classify(fusion_classifier_options, frame);</span><br></pre></td></tr></table></figure><h3 id="track">Track</h3><p>主入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: track segmented objects from multiple lidar sensors</span></span><br><span class="line"><span class="comment">// @params [in]: tracker options</span></span><br><span class="line"><span class="comment">// @params [in/out]: lidar frame</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MlfEngine::Track</span><span class="params">(<span class="keyword">const</span> MultiTargetTrackerOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">           LidarFrame* frame)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><ol type="1"><li><p>modify objects timestamp if necessary 将物体检测的时间戳修改为数据帧frame的时间戳，之前<code>object-&gt;latest_tracked_time</code>为物体点云所有点的平均时间</p></li><li><p>add global offset to pose(only when no track exists)</p></li><li><p>分离前景和背景的物体，并转换为被跟踪物体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: split foreground/background objects and attach to tracked objects</span></span><br><span class="line"><span class="comment">// @params [in]: objects</span></span><br><span class="line"><span class="comment">// @params [in]: sensor info</span></span><br><span class="line"><span class="comment">// @output :background_objects_,foreground_objects_,shape_features,shape_features_full</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfEngine::SplitAndTransformToTrackedObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt;&amp; objects,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> base::SensorInfo&amp; sensor_info)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>向被跟踪列表中添加object：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @brief: add object to tracked list</span><br><span class="line">&#x2F;&#x2F; @params[in]: objectptr,pose(world-&gt;lidar),sensor_info</span><br><span class="line"></span><br><span class="line">tracked_objects[i]-&gt;AttachObject(objects[i], sensor_to_local_pose_,</span><br><span class="line">                               global_to_local_offset_, sensor_info);</span><br></pre></td></tr></table></figure><p>向<code>&lt;TrackedObject&gt;</code>数据类型中传递object的相关属性(朝向,大小,中心,)。 <strong>存疑：这个sensor_to_local_pose_的转换方向不明</strong></p></li><li><p>如果object不是背景且采用直方图匹配方法,则计算物体的外观特征中的<code>histogram_distance</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracked_objects[i]-&gt;ComputeShapeFeatures();</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>​</p><ul><li><p>计算物体的外观特征：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: compute object's shape feature</span></span><br><span class="line">  <span class="comment">// @params[in]: histogram_bin_size default:10</span></span><br><span class="line">  <span class="comment">// @params[out]: object's shape feature</span></span><br><span class="line">  FeatureDescriptor::ComputeHistogram(<span class="keyword">int</span> bin_size, <span class="keyword">float</span>* feature) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>根据object的点云计算特征向量的组成为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...　</span><br><span class="line"> feature[<span class="number">0</span>] = center_pt_.x / <span class="number">10.0f</span>; <span class="comment">//x轴点云中心点</span></span><br><span class="line"> feature[<span class="number">1</span>] = center_pt_.y / <span class="number">10.0f</span>; <span class="comment">//y轴点云中心点</span></span><br><span class="line"> feature[<span class="number">2</span>] = center_pt_.z; <span class="comment">//z轴点云中心点 </span></span><br><span class="line"> feature[<span class="number">3</span>] = xsize; <span class="comment">//x轴点云长度</span></span><br><span class="line"> feature[<span class="number">4</span>] = ysize; <span class="comment">//y轴点云长度</span></span><br><span class="line"> feature[<span class="number">5</span>] = zsize; <span class="comment">//z轴点云长度</span></span><br><span class="line"> feature[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(pt_num); <span class="comment">//点云中点数量</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; stat_feat.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">   feature[i + <span class="number">7</span>] = <span class="comment">//直方图特征,每一个点对应stat_feat中的区间位置</span></span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(stat_feat[i]) / <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(pt_num);</span><br><span class="line"> &#125; <span class="comment">//总共37维</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="4" type="1"><li><p>assign tracked objects to tracks,匹配objects和tracks</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: match tracks and objects and object-track assignment</span></span><br><span class="line"><span class="comment">// @params [in]: match options  default:null</span></span><br><span class="line"><span class="comment">// @params [in]: objects for match :foreground and background separately</span></span><br><span class="line"><span class="comment">// @params [in]: name (foreground or background)</span></span><br><span class="line"><span class="comment">// @params [in/out]: tracks for match and assignment</span></span><br><span class="line"><span class="comment">// @note :分开单独处理前景和背景</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfEngine::TrackObjectMatchAndAssign</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> MlfTrackObjectMatcherOptions&amp; match_options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrackedObjectPtr&gt;&amp; objects, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MlfTrackDataPtr&gt;* tracks)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>二分图</strong>匹配检测到的detected objects和tracks <code>matcher_-&gt;Match(match_options, objects, *tracks, &amp;assignments,                  &amp;unassigned_tracks, &amp;unassigned_objects);</code>　</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: match detected objects to tracks</span></span><br><span class="line"><span class="comment">// @params [in]: new detected objects for matching</span></span><br><span class="line"><span class="comment">// @params [in]: maintaining tracks for matching</span></span><br><span class="line"><span class="comment">// @params [out]: assignment pair of object &amp; track</span></span><br><span class="line"><span class="comment">// @params [out]: tracks without matched object</span></span><br><span class="line"><span class="comment">// @params [out]: objects without matched track</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfTrackObjectMatcher::Match</span><span class="params">(<span class="keyword">const</span> MlfTrackObjectMatcherOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrackedObjectPtr&gt; &amp;objects,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MlfTrackDataPtr&gt; &amp;tracks,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; &gt; *assignments,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; *unassigned_tracks,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; *unassigned_objects)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>前景和背景分开处理,此处仅以前景为例,计算关联的代价矩阵:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: compute association matrix</span></span><br><span class="line"><span class="comment">// @params [in]: maintained tracks for matching</span></span><br><span class="line"><span class="comment">// @params [in]: new detected objects for matching</span></span><br><span class="line"><span class="comment">// @params [out]: matrix of association distance</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfTrackObjectMatcher::ComputeAssociateMatrix</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MlfTrackDataPtr&gt; &amp;tracks,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrackedObjectPtr&gt; &amp;new_objects,</span></span></span><br><span class="line"><span class="function"><span class="params">    common::SecureMat&lt;<span class="keyword">float</span>&gt; *association_mat)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p>计算new detected object 与已存在的track两两之间的匹配程度(距离)<code>track_object_distance</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: compute object track distance</span></span><br><span class="line"><span class="comment">// @params [in]: object</span></span><br><span class="line"><span class="comment">// @params [in]: track data</span></span><br><span class="line"><span class="comment">// @return: distance</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">MlfTrackObjectDistance::ComputeDistance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> TrackedObjectConstPtr&amp; object,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> MlfTrackDataConstPtr&amp; track)</span> <span class="keyword">const</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>关联特征权重表：</p><table><thead><tr class="header"><th style="text-align: center;">关联特征</th><th style="text-align: center;">一致性评估</th><th style="text-align: center;">默认权重(前景,背景)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>location_dist_weight</strong></td><td style="text-align: center;">运动</td><td style="text-align: center;"><strong>0.6</strong> , 0.0</td></tr><tr class="even"><td style="text-align: center;">direction dist weight</td><td style="text-align: center;">运动</td><td style="text-align: center;">0.2 , 0.0</td></tr><tr class="odd"><td style="text-align: center;">bbox size dist weight</td><td style="text-align: center;">外观</td><td style="text-align: center;">0.1 , 0.0</td></tr><tr class="even"><td style="text-align: center;">point num dist weight</td><td style="text-align: center;">外观</td><td style="text-align: center;">0.1 , 0.0</td></tr><tr class="odd"><td style="text-align: center;"><strong>histogram dist weight</strong></td><td style="text-align: center;">外观</td><td style="text-align: center;"><strong>0.5</strong> , 0.0</td></tr><tr class="even"><td style="text-align: center;">centroid shift dist weight</td><td style="text-align: center;">外观</td><td style="text-align: center;">0.0 , 0.2</td></tr><tr class="odd"><td style="text-align: center;">bbox iou dist weight</td><td style="text-align: center;">外观</td><td style="text-align: center;">0.0 , 0.8</td></tr></tbody></table><p>由上表可以看出，在计算关联距离时，重点考虑的是几何距离和两者的形状相似度。</p><ul><li><code>track-&gt;PredictState(current_time)</code>预测状态，包含了位置<code>latest_anchor_point</code>和速度信息<code>latest_velocity</code> 共6个状态。</li></ul><p>根据当前object和track预测的状态信息，分别计算上述7个特征,加权求和，函数实现位于 <code>distace_collection.h</code>中。</p><p>LocationDistance : <span class="math inline">\(\sqrt{\Delta x^2+\Delta y^2+\Delta z^2}\)</span></p><p>DirectionDistance: <span class="math inline">\(-cos(\theta)+1 \in (0,2)\)</span>　,<span class="math inline">\(\theta\)</span>为两个物体方向的夹角 BboxSizeDistance:<span class="math inline">\(min\{\frac{|oldsize\_x-newsize\_x|}{max\{oldsize\_x,newsize\_x\}},\frac{|oldsize\_y-newsize\_y|}{max\{oldsize\_y,newsize\_y\}}\} \in (0,1)\)</span> PointNumDistance:<span class="math inline">\(\frac{|old\_point\_num-new\_point\_num|}{max(old\_point\_num,new\_point\_num)} \in (0,1)\)</span> HistogramDistance: <span class="math inline">\(d+=abs(old\_feature[i]-new\_feature[i]) \in(0,3)\)</span> CentroidShiftDistance: <span class="math inline">\(\sqrt{\Delta x^2+\Delta y^2}\)</span> BboxIouDistance: <span class="math inline">\(dist = (1-iou)*match\_threshold\)</span> 其中match_threshold = 4.0</p></li></ul></li><li><p>然后进行关联,前景关联采用<code>&lt;MultiHmBipartiteGraphMatcher&gt;</code></p><p>背景关联使用<code>&lt;GnnBipartiteGraphMatcher&gt;</code> ,同一继承自<code>&lt;BaseBipartiteGraphMatcher&gt;</code>接口类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: match interface</span></span><br><span class="line"><span class="comment">// @params [in]: match params</span></span><br><span class="line"><span class="comment">// @params [out]: matched pair of objects &amp; tracks</span></span><br><span class="line"><span class="comment">// @params [out]: unmatched rows</span></span><br><span class="line"><span class="comment">// @params [out]: unmatched cols</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Match</span><span class="params">(<span class="keyword">const</span> BipartiteGraphMatcherOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeNodePair&gt; *assignments,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; *unassigned_rows,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; *unassigned_cols)</span></span>;</span><br></pre></td></tr></table></figure><p>实际上调用的是根据计算得到的代价矩阵，根据门控匈牙利算法:<code>&lt;common::GatedHungarianMatcher&gt;</code> ,其中设置参数<code>max_match_distance=4</code>,<code>bound_value=100</code></p></li></ul></li><li><p>对于已关联的object和track,执行下列函数，将object添加到track的缓冲区<code>cached_objects</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// @brief: 将已经与track关联的object添加到缓冲区</span></span><br><span class="line"> <span class="comment">// @param[in]: obj与track关联的新检测物体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfTrackData::PushTrackedObjectToCache</span><span class="params">(TrackedObjectPtr obj)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于未被关联的objects，需要创建新的tracks,更新<code>MlfTrackData</code>中与跟踪相关的状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: initialize new track data and push new object to cache</span></span><br><span class="line"><span class="comment">// @params [in/out]: new track data</span></span><br><span class="line"><span class="comment">// @params [in/out]: new object</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfTracker::InitializeTrack</span><span class="params">(MlfTrackDataPtr new_track_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TrackedObjectPtr new_object)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>创建新的track的过程：从<code>MlfTrackDataPool</code>对象池中创建<code>MlfTrackDataPtr</code>实例<code>track_data</code>,然后通过 <code>&lt;MlfTracker&gt;</code>类中的<code>InitializeTrack</code>对创建的<code>track_data</code>结合提供的<code>object</code>信息，进行相关跟踪属性的赋值，然后将得到的<code>track_data</code>加入到已存在的跟踪列表<code>std::vector&lt;MlfTrackDataPtr&gt;</code>中。</p></li></ul></li><li><p>state filter in tracker if is main sensor (default : Velodyne64)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: filter tracks</span></span><br><span class="line"><span class="comment">// @params [in]: tracks for filter</span></span><br><span class="line"><span class="comment">// @params [in]: frame timestamp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfEngine::TrackStateFilter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MlfTrackDataPtr&gt;&amp; tracks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">double</span> frame_timestamp)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>输入是上一步得到的<code>std::vector&lt;MlfTrackDataPrt&gt;</code></p><ul><li><p>从CachedObjects(latest_tracked_time和object的pair)获取持续时间超过阈值的,同时删除小于时间阈值的object.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: get/clean track objects from cached based trackdata</span></span><br><span class="line"><span class="comment">// @param[in/out]: objects</span></span><br><span class="line"><span class="comment">// @note :每一个跟踪物体都有一个对应的trackdata</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfTrackData::GetAndCleanCachedObjectsInTimeInterval</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrackedObjectPtr&gt;* objects)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这里有两个时间<code>latest_visible_time_</code>(最近一次可见的时间)及<code>latest_cached_time_</code>(上一次被加入到缓冲区的时间)。 <code>catched_object-&gt;timestamp&lt;=latest_visible_time_</code>则删除， <code>catched_object-&gt;timestamp&lt;=latest_cached_time_</code>则将该cached_object添加到objects中</p></li><li><p>根据从<code>catched_objects</code>中获得的objects,更新TrackData</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: update track data with object</span></span><br><span class="line"><span class="comment">// @params [in/out]: history track data</span></span><br><span class="line"><span class="comment">// @params [in/out]: new object</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfTracker::UpdateTrackDataWithObject</span><span class="params">(MlfTrackDataPtr track_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           TrackedObjectPtr new_object)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li><p>state fitler and store belief in new_object ,(filters contain <code>MlfShapeFilter</code> <code>MlfMotionFilter</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: updating shape filter with object</span></span><br><span class="line"><span class="comment">// @params [in]: options for updating</span></span><br><span class="line"><span class="comment">// @params [in]: track data, not include new object</span></span><br><span class="line"><span class="comment">// @params [in/out]: new object for updating</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfShapeFilter::UpdateWithObject</span><span class="params">(<span class="keyword">const</span> MlfFilterOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> MlfTrackDataConstPtr&amp; track_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      TrackedObjectPtr new_object)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>此处未详细看，基本处理包括计算object polygon;方向的滑动平均过滤;更新new object的<code>ouput_center</code>, <code>output_direction</code>,<code>output_size</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: updating motion filter with object</span></span><br><span class="line"><span class="comment">// @params [in]: options for updating</span></span><br><span class="line"><span class="comment">// @params [in]: track data, not include new object</span></span><br><span class="line"><span class="comment">// @params [in/out]: new object for updating</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfMotionFilter::UpdateWithObject</span><span class="params">(<span class="keyword">const</span> MlfFilterOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> MlfTrackDataConstPtr&amp; track_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TrackedObjectPtr new_object)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>此处亦未详细看，过滤方法采用KalmanFilter,此处的基本处理过程包括了: 若object的track_data-&gt;age为0,则初始化状态，若该object为背景则不进行处理，否则 　首先计算相关的测量速度值(anchor_point_velocity,bbox_center_velocity,bbox_corner_velocity),根据运动一致性选取速度<code>selected_measured_velocity</code> 同时根据object点的数量差异和关联分数评估测量的质量 <code>update_quality</code>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> motion_measurer_-&gt;ComputeMotionMeasurment(track_data, new_object);</span><br></pre></td></tr></table></figure><p>　然后使用自适应鲁棒卡尔曼滤波对track的状态估计，并剔除异常数据的影响，相较于传统的卡尔曼滤波，此处的修改包括：</p><blockquote><ul><li><p>在一系列的重复观测中选择速度测量，即滤波算法的输入包括了锚点以为，边界框中心偏移，边界框角点偏移等。卡尔曼滤波更新的观测值为速度，每次观测三个速度值:锚点移位速度，边界框中心偏移速度，边界框角点位移速度，从这三个速度中，根据运动一致性约束，选取和之前观测速度偏差最小的速度作为最终的观测值，并根据最近３次的速度观测值，计算加速度的观测值。</p></li><li>在过滤中使用故障阈值<code>breakdown_threshold_</code>，当更新的增益过大时，用于克服增益的过度估计，其中速度的故障阈值是动态计算的，与速度误差协方差矩阵有关，而加速度的故障阈值是一个定值，默认为２.</li><li><p>更新关联质量，原始的卡尔曼滤波在更新状态时不区分测量的质量，此处使用两种策略来计算更新关联质量，关联分数和前后两个object的点云数量变化,之后取得分小的结果控制滤波器噪声。</p></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> KalmanFilterUpdateWithPartialObservation(track_data, latest_object,</span><br><span class="line">                                           new_object);</span><br></pre></td></tr></table></figure><p>　然后进行convergence估计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> ConvergenceEstimationAndBoostUp(track_data, latest_object, new_object);</span><br></pre></td></tr></table></figure><p>​ 然后object中的belirf属性复制到output属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> BeliefToOutput(new_object);</span><br></pre></td></tr></table></figure><p>​ 然后进行后处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span> motion_refiner_-&gt;Refine(track_data, new_object)</span><br></pre></td></tr></table></figure><p>​ 最后进行在线协方差估计:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span> OnlineCovarianceEstimation(track_data, new_object);</span><br></pre></td></tr></table></figure></li><li><p>push new_object to track_data 更新object成为新的track:</p></li></ol><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfTrackData::PushTrackedObjectToTrack</span><span class="params">(TrackedObjectPtr obj)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p></li></ul></li><li><p>track to object if is main sensor ,因为objects可能来自于多个不同的Lidar传感器，此处是在主传感器上进行汇总。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: collect track results and store in frame tracked objects</span></span><br><span class="line"><span class="comment">// @params [in/out]: lidar frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfEngine::CollectTrackedResult</span><span class="params">(LidarFrame* frame)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>综合前面得到的<code>foreground_track_data_</code>以及<code>background_track_data_</code>通过函数<code>MlfTrackData::ToObject</code>填充<code>&lt;LidarFrame&gt;</code>数据结构</p></li><li><p>remove stale data 删除过期数据(latest_visible_time+reserved_invisible_time &gt;= timestamp)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: remove stale track data for memory management</span></span><br><span class="line"><span class="comment">// @params: name</span></span><br><span class="line"><span class="comment">// @params: timestamp</span></span><br><span class="line"><span class="comment">// @params [in/out]: tracks to be cleaned</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MlfEngine::RemoveStaleTrackData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">double</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MlfTrackDataPtr&gt;* tracks)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol><p>跟踪主要流程总结如下：</p><ul><li>构造跟踪对象并将其转换为世界坐标</li><li>预测现有跟踪列表的状态，并进行匹配</li><li>在更新后的跟踪列表中更新运动窗台，并收集跟踪结果</li></ul><hr><h3 id="classify">Classify</h3><p>主入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: classify object list, and fill type in object.</span></span><br><span class="line"><span class="comment">// @param [in]: options</span></span><br><span class="line"><span class="comment">// @param [in/out]: object list</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FusedClassifier::Classify</span><span class="params">(<span class="keyword">const</span> ClassifierOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LidarFrame* frame)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>首先将objects加入到序列<code>&lt;ObjectSequence&gt;</code>中,序列是track_id与对应object的map</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: add tracked objects to sequence,and remove stale tracks</span></span><br><span class="line"><span class="comment">// @param [in]: objectptr ,timestamp</span></span><br><span class="line"><span class="comment">// @return: true or false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObjectSequence::AddTrackedFrameObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ObjectPtr&gt;&amp; objects, TimeStampKey timestamp)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>物体通用类型包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// @brief general object type</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectType</span> &#123;</span></span><br><span class="line">  UNKNOWN = <span class="number">0</span>,</span><br><span class="line">  UNKNOWN_MOVABLE = <span class="number">1</span>,</span><br><span class="line">  UNKNOWN_UNMOVABLE = <span class="number">2</span>,</span><br><span class="line">  PEDESTRIAN = <span class="number">3</span>,</span><br><span class="line">  BICYCLE = <span class="number">4</span>,</span><br><span class="line">  VEHICLE = <span class="number">5</span>,</span><br><span class="line">  MAX_OBJECT_TYPE = <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果object是背景，则将物体类型置为<code>ObjectType::UNKNOWN_UNMOVABLE</code></p><p>否则，首先获取特定track_id在特定时间段内对应的object列表，即获取一个被跟踪物体的序列：</p><blockquote><p>(Time_1,TrackedObject_1), (Time_1,TrackedObject_2), .... (Time_n,TrackedObject_n),</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 获取特定track_id在到当前时刻的往前window_time时间序列中对应的object组成的列表</span></span><br><span class="line"><span class="comment">// @param[in]: track_id , window_time</span></span><br><span class="line"><span class="comment">// @param[in/out]: track (在window_time时间段内的track_id的object)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObjectSequence::GetTrackInTemporalWindow</span><span class="params">(TrackIdKey track_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TrackedObjects* track,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TimeStampKey window_time)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>然后进行类型融合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CCRFSequenceTypeFusion::TypeFusion</span><span class="params">(<span class="keyword">const</span> TypeFusionOption&amp; option,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        TrackedObjects* tracked_objects)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p>```c++ // <span class="citation" data-cites="brief">@brief</span>: Enter fuse with conditional probability inference // <span class="citation" data-cites="param">@param [in]</span>: TrackedObject with timestamp bool CCRFSequenceTypeFusion::FuseWithConditionalProbabilityInference( TrackedObjects* tracked_objects) {...} <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 对于跟踪序列中的每一个物体，执行&#96;one_shot_fuser_.FuseOneShotTypeProbs&#96;</span><br><span class="line"></span><br><span class="line">  &gt; 整个过程共分两步：</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; - 状态平滑</span><br><span class="line">  &gt; - Viterbi算法推断状态</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;c++</span><br><span class="line">  &#x2F;&#x2F; @brief: fuse on shot prons in sequence</span><br><span class="line">  &#x2F;&#x2F; @param[in]: ObjectPtr(the object in sequence)</span><br><span class="line">  &#x2F;&#x2F; @param[out]: log prob(fused oneshot probs type:a vector [valid_type_num,1])</span><br><span class="line">  </span><br><span class="line">  bool CCRFOneShotTypeFusion::FuseOneShotTypeProbs(const ObjectPtr&amp; object,</span><br><span class="line">                                                   Vectord* log_prob) &#123;...&#125;</span><br></pre></td></tr></table></figure></p><p><code>smooth_matrices_:</code></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DecisionForestClassifier</span><br><span class="line"><span class="number">0.7751</span> <span class="number">0.0298</span> <span class="number">0.0639</span> <span class="number">0.1312</span> <span class="comment">// -&gt; sum = 1.0</span></span><br><span class="line"><span class="number">0.2510</span> <span class="number">0.6802</span> <span class="number">0.0615</span> <span class="number">0.0073</span></span><br><span class="line"><span class="number">0.1904</span> <span class="number">0.0628</span> <span class="number">0.6314</span> <span class="number">0.1155</span></span><br><span class="line"><span class="number">0.1054</span> <span class="number">0.0003</span> <span class="number">0.0038</span> <span class="number">0.8905</span></span><br><span class="line"></span><br><span class="line">CNNSegmentation</span><br><span class="line"><span class="number">0.9095</span> <span class="number">0.0238</span> <span class="number">0.0190</span> <span class="number">0.0476</span></span><br><span class="line"><span class="number">0.3673</span> <span class="number">0.5672</span> <span class="number">0.0642</span> <span class="number">0.0014</span></span><br><span class="line"><span class="number">0.1314</span> <span class="number">0.0078</span> <span class="number">0.7627</span> <span class="number">0.0980</span></span><br><span class="line"><span class="number">0.3383</span> <span class="number">0.0017</span> <span class="number">0.0091</span> <span class="number">0.6508</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对应四种有效类型：UNKNOWN,PEDESTRIAN,BICYCLE,VEHICLE</span></span><br></pre></td></tr></table></figure></p><p><code>confidence_smooth_matrix_:</code></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Confidence</span><br><span class="line"><span class="number">1.00</span> <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">0.00</span></span><br><span class="line"><span class="number">0.40</span> <span class="number">0.60</span> <span class="number">0.00</span> <span class="number">0.00</span></span><br><span class="line"><span class="number">0.40</span> <span class="number">0.00</span> <span class="number">0.60</span> <span class="number">0.00</span></span><br><span class="line"><span class="number">0.50</span> <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">0.50</span></span><br></pre></td></tr></table></figure></p><p>计算不考虑整个序列的单独各个object的概率single_prob: <span class="math display">\[  p(c|x) = p(c|x,o)p(o|x)+p(c|x,\widetilde{o})p(\widetilde{o}|x)  \]</span> 程序表示为, 输入为x条件下类别的概率 = 前景的概率 * 类别概率+（背景的概率）* 类别的置信度平滑矩阵 * 类别概率</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">single_prob = conf * single_prob +</span><br><span class="line">                (<span class="number">1.0</span> - conf) * confidence_smooth_matrix_ * single_prob;</span><br></pre></td></tr></table></figure></p><p>转换为对数概率 <span class="math inline">\(log\_prob=log(single\_prob)\)</span> ,获得该object属于各个类别的对数概率。由此可得到该 TrackedObjects对应序列的每一个object的4种有效类型概率。</p><ul><li><p>通过维特比(Viterbi)算法推断状态：</p><blockquote><p>维特比算法前提是状态链是马尔可夫链，<strong>下一时刻的状态仅仅取决于当前时刻的状态</strong> 假设隐状态数量为m,观测状态的数量为n,隐状态分别为<span class="math inline">\(s_1,s_2,...,s_m\)</span>,可观测状态分别为 <code>o_1,o_2,...,o_n</code>,则有： 状态转移矩阵<span class="math inline">\(P(m\times m):P[i,j]\)</span> 代表状态i到状态j转移的概率,<span class="math inline">\(\sum_{j=0}^mP[i,j]=1\)</span> ,发射概率矩阵 <span class="math inline">\(R(m\times n):R[i,j]\)</span>代表隐状态i能被观测到为j的概率:<span class="math inline">\(\sum_{j=0}^nP[i,j]=1\)</span></p></blockquote><p>添加先验知识用于抑制突然出现的物体类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UNKNOWN,PEDESTRIAN,BICYCLE,VEHICLE</span></span><br><span class="line">    <span class="number">0.34</span>     <span class="number">0.22</span>     <span class="number">0.33</span>    <span class="number">0.11</span> <span class="comment">//UNKNOWN</span></span><br><span class="line">    <span class="number">0.03</span>     <span class="number">0.90</span>     <span class="number">0.05</span>    <span class="number">0.02</span> <span class="comment">//PEDESTRIAN   </span></span><br><span class="line">    <span class="number">0.03</span>     <span class="number">0.05</span>     <span class="number">0.90</span>    <span class="number">0.02</span> <span class="comment">//BICYCLE</span></span><br><span class="line">    <span class="number">0.06</span>     <span class="number">0.01</span>     <span class="number">0.03</span>    <span class="number">0.90</span> <span class="comment">//VEHICLE</span></span><br><span class="line"><span class="comment">//对应四种有效物体类型的先验知识 转移概率矩阵</span></span><br><span class="line">transition_matrix_alpha:<span class="number">1.8</span></span><br></pre></td></tr></table></figure><p>下面程序是根据转移概率矩阵(left-&gt;right)推断当前时刻最大概率的过程： 认为fused_sequence_probs为隐状态，根据上一时刻的隐状态fused_sequence_probs[i-1]和状态转移矩阵求解联合状态矩阵，其中矩阵元素<span class="math inline">\(fused\_sequence\_probs\_[i][j]\)</span>的求解方式为：下列代码中，fused_oneshot_probs_是每个时刻独立的4类概率，经过平滑和log(·)处理。transition_matrix_是状态转移矩阵P，维度为4x4，经过log(·)处理，fused_sequence_probs_为Viterbi算法推理后的修正状态(也就是真实的隐状态)。 <span class="math display">\[p(s_{i,j}, s_{i-1,k}) = p_{prv\_state=s_{i-1,k}} * P(s_j|s_k)\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> right = <span class="number">0</span>; right &lt; VALID_OBJECT_TYPE; ++right) &#123;</span><br><span class="line">    <span class="keyword">double</span> prob = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> max_prob = -DBL_MAX;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> left = <span class="number">0</span>; left &lt; VALID_OBJECT_TYPE; ++left) &#123;</span><br><span class="line">      prob = fused_sequence_probs_[i - <span class="number">1</span>](left) +</span><br><span class="line">             transition_matrix_(left, right) * s_alpha_ +</span><br><span class="line">             fused_oneshot_probs_[i](right);</span><br><span class="line">      <span class="keyword">if</span> (prob &gt; max_prob) &#123;</span><br><span class="line">        max_prob = prob; <span class="comment">//根据转移概率推断得到当前的object (right值)最大概率</span></span><br><span class="line">        id = left;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fused_sequence_probs_[i](right) = max_prob;</span><br><span class="line">    state_back_trace_[i](right) = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取类别概率后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RecoverFromLogProbability(&amp;fused_sequence_probs_.back(), &amp;object-&gt;type_probs,</span><br><span class="line">                          &amp;object-&gt;type); <span class="comment">//将Eigen转换回std::vector得到物体类别</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="参考">参考：</h3><p>类型融合：https://blog.csdn.net/qq_41204464/article/details/102987228</p><p>跟踪：https://mp.weixin.qq.com/s?__biz=MzI1NjkxOTMyNQ==&amp;mid=2247485879&amp;idx=1&amp;sn=d921ab976ebc72c502eb5df1ef7ff548&amp;chksm=ea1e1bc5dd6992d3220bd47c5cd951f38648c060d4f9dc9bfbe5eac1a3076f920fa3e360c038&amp;scene=21#wechat_redirect</p>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lidar目标跟踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo lidar算法--segmentaion component（二）</title>
      <link href="/2020/05/13/apollo-lidar_segmentor/"/>
      <url>/2020/05/13/apollo-lidar_segmentor/</url>
      
        <content type="html"><![CDATA[<p>apollo中lidar的分割模型，接上篇初始化之后，本篇主要总结apollo segmentation component的<code>InternalProc</code>函数内的相关功能实现。从<code>lidar_error_code.h</code>中我们可以一窥lidar处理的主要流程阶段：</p><p><code>Init-&gt;Preprocess-&gt;MapManager-&gt;Segmentaion-&gt;ObjectBuilder-&gt;ObjectFilter-&gt;Classifier-&gt;Tracker</code></p><a id="more"></a><p>入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief:Lidar相关处理算法</span></span><br><span class="line"><span class="comment">// @param[in]:LidarObstaclesSegmentationOptions 包括了传感器名称和lidar2novatel的外参</span></span><br><span class="line"><span class="comment">// @param[in]:PointCloud 接收的原始点云输入数据</span></span><br><span class="line"><span class="comment">// @param[out]:LidarFrame lidar输出帧信息，包含障碍物识别 跟踪等信息</span></span><br><span class="line"><span class="function">LidarProcessResult <span class="title">LidarObstacleSegmentation::Process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> LidarObstacleSegmentationOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::PointCloud <span class="keyword">const</span>&gt;&amp; message,</span></span></span><br><span class="line"><span class="function"><span class="params">      LidarFrame* frame)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="一预处理">一、预处理：</h3><p>功能实现类<code>&lt;PointCloudPreprocessor&gt;</code> 接口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: preprocess point cloud</span></span><br><span class="line"><span class="comment">// @param [in]: options 包含lidar到novatel的外参变换矩阵</span></span><br><span class="line"><span class="comment">// @param [in]: point cloud message</span></span><br><span class="line"><span class="comment">// @param [in/out]: frame</span></span><br><span class="line"><span class="comment">// cloud should be filled, required,</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Preprocess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> PointCloudPreprocessorOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::PointCloud <span class="keyword">const</span>&gt;&amp; message,</span></span></span><br><span class="line"><span class="function"><span class="params">    LidarFrame* frame)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>PointCloudPreprocessor::Preprocess()</p><p>主要就是过滤点云，增加鲁棒性，过滤的选项有以下几个：</p><p><strong>filter_naninf_points</strong>:过滤点云的坐标为nan 或者超过一定值(kPointInfThreshold=1e3)的点云 <strong>filter_nearby_box_points</strong>:将离传感器很近的点云过滤掉，注意此处的坐标由各个lidar坐标系转换到novatel坐标系进行同一度量，默认配置的参数范围为：<span class="math inline">\(-2&lt;x&lt;2,-5&lt;y&lt;3\)</span> 。 <strong>filter_high_z_points:</strong> 将高度大于一定阈值的点云过滤掉(z_threshold_=5.0m)</p><p>上述三个过滤选项可在配置文件中根据需要选择，同时可在配置文件中配置器对应的参数。</p><p>然后将消息帧中过滤后的点云存储到<code>LidarFrame::cloud</code>数据结构中，包含点云坐标，时间戳，高度，点的索引，标签等信息。</p><ul><li><p><code>PointCloudPreprocessor::TransformCloud()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransformCloud(frame-&gt;cloud, frame-&gt;lidar2world_pose, frame-&gt;world_cloud)</span><br></pre></td></tr></table></figure><p>将局部lidar坐标系下的点云坐标转换到世界坐标系下，并存储到<code>LidarFrame::world_cloud</code>数据结构中。</p></li></ul></li></ul><hr><h3 id="二地图管理器mapmanger">二、地图管理器MapManger</h3><p>功能实现类：<code>&lt;MapManager&gt;</code></p><p>入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: update map structure and lidar2world pose</span></span><br><span class="line"><span class="comment">// @param [in]: options</span></span><br><span class="line"><span class="comment">// @param [in/out]: frame：the LidarFrame data structure after Preprocess</span></span><br><span class="line"><span class="comment">// hdmap_struct should be filled, required,</span></span><br><span class="line"><span class="comment">// lidar2world_pose can be updated, optional,</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Update</span><span class="params">(<span class="keyword">const</span> MapManagerOptions&amp; options, LidarFrame* frame)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>map_manager_.Update(map_manager_options, frame)</code> 通过参数配置文件中的<code>update_pose</code>决定是否进行lidar-&gt;world姿态的更新。然后通过GetRoiHDMapStruct函数获取当前位置对应的roi区域内的hdmap信息</p><ul><li><p><code>hdmap_input_-&gt;GetRoiHDMapStruct(point, roi_search_distance_,frame-&gt;hdmap_struct)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 获取roi区域内的hdmap结构 包括road polygonss juction_polygons,road_boundary</span></span><br><span class="line"><span class="comment">// @param [in]: pointd(lidar到世界坐标系的位移向量)，</span></span><br><span class="line"><span class="comment">// @param [in]: roi_search_distance_(配置参数，roi搜索距离：默认120m)</span></span><br><span class="line"><span class="comment">// @parma [out]: hdmap_struct_ptr:从hdmap中获取感兴趣区域</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HDMapInput::GetRoiHDMapStruct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> base::PointD&amp; pointd, <span class="keyword">const</span> <span class="keyword">double</span> distance,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::HdmapStruct&gt; hdmap_struct_ptr)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>首先获取原始的hdmap中指定范围内的道路和道路交叉点的边界:</p><ul><li><p><code>hdmap_-&gt;GetRoadBoundaries(point, distance, &amp;road_boundary_vec,&amp;junctions_vec)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @brief get all road and junctions boundaries within certain range</span></span><br><span class="line"><span class="comment"> * @param point the target position</span></span><br><span class="line"><span class="comment"> * @param radius the search radius</span></span><br><span class="line"><span class="comment"> * @param road_boundaries the roads' boundaries</span></span><br><span class="line"><span class="comment"> * @param junctions the junctions' boundaries</span></span><br><span class="line"><span class="comment"> * @return 0:success, otherwise failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetRoadBoundaries</span><span class="params">(<span class="keyword">const</span> apollo::common::PointENU&amp; <span class="built_in">point</span>, <span class="keyword">double</span> radius,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RoadROIBoundaryPtr&gt;* road_boundaries,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;JunctionBoundaryPtr&gt;* junctions)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></li></ul>然后融合两者的结果存入到ROI多边形中，该区域内所有的点均位于世界坐标系下。<ul><li><p><code>MergeBoundaryJunction()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 融合各个道路和道路交叉点的边界</span></span><br><span class="line"><span class="comment">// @param[in]: boundary(道路边界)，junctions(交叉点边界)</span></span><br><span class="line"><span class="comment">// @param[out]: road_boundaries_ptr(道路边界) road_polygons_ptr(道路平面区域)junction_polyjons(路口区域) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HDMapInput::MergeBoundaryJunction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;apollo::hdmap::RoadRoiPtr&gt;&amp; boundary,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;apollo::hdmap::JunctionInfoConstPtr&gt;&amp; junctions,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::RoadBoundary&gt;* road_boundaries_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::PolygonDType&gt;* road_polygons_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::PolygonDType&gt;* junction_polygons_ptr)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据交叉点过滤道路边界。 <code>GetRoadBoundaryFilteredByJunctions()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: </span></span><br><span class="line"><span class="comment">// @param[in]: road_boundaries(带过滤的道路边界) junctions_polygons(交叉点区域)</span></span><br><span class="line"><span class="comment">// @param[out]: flt_road_boundaries_ptr（根据junctions的边界过滤后道路边界）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HDMapInput::GetRoadBoundaryFilteredByJunctions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::RoadBoundary&gt;&amp; road_boundaries,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::PointCloud&lt;PointD&gt;&gt;&amp; junctions,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::RoadBoundary&gt;* flt_road_boundaries_ptr)</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><h3 id="三-分割segment">三、 分割Segment</h3><p>功能实现类：继承<code>&lt;BaseSegmentation&gt;</code>接口类的<code>&lt;CNNSegmentation&gt;</code>类 入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: segment point cloud and get objects.</span></span><br><span class="line"><span class="comment">// @param [in]: options</span></span><br><span class="line"><span class="comment">// @param [in/out]: frame</span></span><br><span class="line"><span class="comment">// segmented_objects should be filled, required,</span></span><br><span class="line"><span class="comment">// label field of point cloud can be filled, optional,</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Segment</span><span class="params">(<span class="keyword">const</span> SegmentationOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                     LidarFrame* frame)</span></span>;</span><br></pre></td></tr></table></figure><p>经过preprocessor和map_manager-&gt;update已获得预处理的点云(<code>cloud</code>和<code>world_cloud</code>)和地图边界信息<code>HdmapStruct</code>,此处将填充点云数据帧中的<code>segmented_objects</code>，方法是通过聚类点云形成障碍物。</p><ul><li><p><strong>首先</strong>将3d点云映射到2d图像网格中<code>MapPointToGrid(orginal_cloud_)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: map original point to 2d grid</span></span><br><span class="line"><span class="comment">// @param [in]: original point</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CNNSegmentation::MapPointToGrid</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;AttributePointCloud&lt;PointF&gt;&gt;&amp; pc_ptr)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p>遍历原始点云中的每一个点，然后将高度在-5到5m之内的点进行如下处理： <code>GroupPc2Pixel(pt.x, pt.y, inv_res_x, range_, &amp;pos_x, &amp;pos_y);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for axis rotated case</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GroupPc2Pixel</span><span class="params">(<span class="keyword">float</span> pc_x, <span class="keyword">float</span> pc_y, <span class="keyword">float</span> scale, <span class="keyword">float</span> range,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">float</span> fx = (range - (<span class="number">0.707107f</span> * (pc_x + pc_y))) * scale; <span class="comment">//旋转45度并平移range</span></span><br><span class="line">  <span class="keyword">float</span> fy = (range - (<span class="number">0.707107f</span> * (pc_x - pc_y))) * scale;</span><br><span class="line">  *x = fx &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(fx);</span><br><span class="line">  *y = fy &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(fy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据参数配置文件中的相关信息，俯视图以Lidar为中心范围为(-range=90m,range=90m),对应的网格数为(864,864),这样可得每米对应的格数为inv_res_x=864/180=4.8格/米，由此可以计算每个点云的点对应在哪个格中，上述函数返回了分别对应pc_x,pc_y网格索引，然后将网格索引存储到一维向量中： <code>std::vector&lt;int&gt; point2grid_=pos_y * width_ + pos_x</code>存储点云中点在网格中的一维索引</p></li></ul></li><li><p><strong>更近一步</strong>，以网格为基准生成输入到神经网络中计算所需的特征图</p><p>功能实现类<code>&lt;FeatureGenerator&gt;</code> <code>feature_generator_-&gt;Generate(original_cloud_, point2grid_);</code> 该部分的函数实现可以通过cpu或者cuda实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 生成特征图</span></span><br><span class="line"><span class="comment">// @param[in]: original_cloud_ 原始lidar点云,point2grid_(点云中的点对应网格的一维索引) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Generate</span><span class="params">(<span class="keyword">const</span> base::PointFCloudPtr&amp; pc_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; point2grid)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PERCEPTION_CPU_ONLY</span></span><br><span class="line">    GenerateGPU(pc_ptr, point2grid);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    GenerateCPU(pc_ptr, point2grid);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该部分用于提取输入到网络模型中的特征图，特征图信息通过以下几个步骤获取：</p><ul><li><p>初始化特征属性： 最大高度(max_height)，平均高度(mean_height)，最高点对应的强度(top_intensity)，平均强度(mean_intensity),以及网格中点云的密度(count)，以及对应该网格是否为空的nonempty_data,</p></li><li><p>计算特征属性：</p><p>遍历点云，根据point2grid_可获得点云对应的网格一维索引，获取网格对应所有点云的最大高度以及平均高度，若配置参数中启用intensity作为特征（<code>use_intensity_feature=Ture</code>）则同时获取最大高度对应的强度和平均强度特征，同时记录每个网格中对应的点的个数,若是网格中没有点，则用最大高度记为0</p></li><li><p>每个网格的点的个数取对数(归一化)作为网格密度的特征，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">LogCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(log_table_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> log_table_[count]; <span class="comment">//查询log查询表</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> logf(<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span> + count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将提取的特征属性分别存放以下指针中，注意指针指向<code>feature_blob</code>对应的数据地址 <code>max_height_data_,mean_height_data_,top_intensity_data_,mean_intensity_data,count_data_,nonempty_data</code></p><p><strong>此处计算的特征图通道数最多为6，再加上初始化时已经填充的<code>distance_data</code>和<code>direction_data</code>则最多有8个通道的输入特征图，注意max_height,mean_height,count_data，nonempty_data必须之外，在程序中其余特征是通过配置文件参数决定是否使用,程序默认只使用四个必须的通道</strong> 计算的8个统计量：</p><ol type="1"><li>单元格中点的最大高度</li><li>单元格中最高点的强度</li><li>单元格中点的平均高度</li><li>单元格中点的平均强度</li><li>单元格中的点数</li><li>单元格中心相对于原点的角度</li><li>单元格中心与原点之间的距离</li><li>二进制值标示单元格是空还是被占用</li></ol></li></ul><blockquote><p>参考论文 [MV3D][https://www.baidu.com/link?url=Ly_VMVTyYOUZVTepDik7Lt6L8YVF1eZjGAYdxX4VsXZH0RRs3jVs3QrLaxGk8W6H&amp;wd=&amp;eqid=ac4db69d0000b034000000025e97375a]中Bird’s Eye View Representation.章节的相关描述，MV3D中以<span class="math inline">\(min(1.0,\frac{log(N+1)}{log(64)})\)</span>作为网格密度特征的衡量方式。</p></blockquote></li><li><p><strong>然后</strong>，在获得了对应的输入特征图<code>(1*4*864*864)</code>之后，就可以进行模型的前向推断啦 <code>inference_-&gt;Infer()</code> 网络模型的输出包括： 类别得分<code>class_pt_blob:&quot;class_score&quot;</code>，置信度得分<code>confidence_pt_blob:&quot;confidence_score&quot;</code> 偏移<code>instace_pt_blob:&quot;instace_pt&quot;</code>,分类<code>category_pt_blob:&quot;category_score&quot;</code>,朝向<code>heading_py_blob:&quot;heading_pt&quot;</code> 障碍物高度<code>height_pt_blob:&quot;height_pt&quot;</code> <strong>通过神经网络输出，可以得到每个单元格的CNN预测属性</strong> 基于FCNN的预测，Apollo获取了每个单元格的四个预测信息，分别用于之后的障碍物聚类和后处理：</p><table><thead><tr class="header"><th>单元格属性</th><th>单元格属性</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>中心偏移</td><td>center offset</td><td>障碍物聚类</td></tr><tr class="even"><td>对象性(是否为object)</td><td>objectness</td><td>障碍物聚类</td></tr><tr class="odd"><td>可信度(positiveness)</td><td>positiveness</td><td>后处理</td></tr><tr class="even"><td>对象高度</td><td>object height</td><td>后处理</td></tr></tbody></table></li><li><p><strong>最后</strong> 进行后处理聚类： <code>GetObjectsFromSppEngine(&amp;frame-&gt;segmented_objects);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 后处理实现点云聚类</span></span><br><span class="line"><span class="comment">// @param[out]: objects (点云数据帧中的segmented_objects数据)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CNNSegmentation::GetObjectsFromSppEngine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt;&gt;* objects)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>功能实现类：<code>&lt;SppEngine&gt;</code></p><ol type="1"><li><p>向<code>SppEngine</code>的数据结构<code>&lt;SppData&gt;</code>中传入点云对应的一维网格索引<code>grid_indices</code>，即特征图。</p></li><li><p>进行前景分割,对点云进行聚类得到各个物体的cluster</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: process foreground segmentation</span></span><br><span class="line"><span class="comment">// @param [in]: point cloud (原始点云数据)</span></span><br><span class="line"><span class="comment">// @return: size of foreground clusters</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ProcessForegroundSegmentation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> base::PointFCloudConstPtr point_cloud)</span></span>;</span><br></pre></td></tr></table></figure><p>此处 处理的数据结构类为：<code>&lt;CloudMask&gt;</code></p><ul><li><p>调用私有函数在输入网格特征图上进行聚类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: process clustering on input feature map</span></span><br><span class="line"><span class="comment">// @param [in]: point cloud</span></span><br><span class="line"><span class="comment">// @param [in]: point cloud mask</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ProcessConnectedComponentCluster</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> base::PointFCloudConstPtr point_cloud, <span class="keyword">const</span> CloudMask&amp; mask)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>在该函数中，通过<code>&lt;SppCCDetector&gt;</code>这个功能类检测cluster。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: detect clusters</span></span><br><span class="line"><span class="comment">// @param [out]: label image</span></span><br><span class="line"><span class="comment">// @return: label number 检测到的物体类别标签的数量</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">SppCCDetector::Detect</span><span class="params">(SppLabelImage* labels)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>其中参数 labels 为数据结构类<code>&lt;SppLabelImage&gt;</code></p><ul><li><code>BuildNodes(0,rows_)</code> 通过给定特征图行数创建<code>node</code>矩阵 ，根据网络输出的 <code>category_pt_blob</code>对应每一个节点是否是object的概率，<code>instance_pt_blob</code>对应着每个节点在行和列方向上的偏移（网络的输出为米，需根据scale转换为偏移的网格数），创建节点并设置节点的<code>is_object</code>状态。<strong>这里的偏离center offset实际有两层，分别是行方向上的偏移和列方向上的偏移，最终将二者合并成整个特征图的一维索引保存到对应节点的center_node属性中</strong></li></ul><blockquote><p>这里的<code>&lt;Node&gt;</code>数据结构类型包含的是一个16位的数据状态status,表示一个网格节点的状态，将 <code>node_bank,traversed,is_center,is_object</code>等属性压缩到这一个uint16数据中,排列如下 <code>|is_center(1bit)|is_object(1bit)|traversed(3bit)|node_rank(11bit)|</code></p></blockquote><ul><li><p><code>TraverseNodes()</code> 遍历创建的节点矩阵，如果节点对应的is_object = 1,构建节点之间的对应关系： 遍历is_object=1的节点，根据该节点的center_node偏移不断往下遍历直到遇到已经遍历过的点则停止，将这些点的is_center属性赋值为true。然后将各个遍历过程中经过的节点的traversed属性置为1，并将各个节点的parent属性统一设置为最终(遍历停止)节点的parent(即为网格一维索引)</p></li><li><p><code>UnionNodes()</code>将相邻的节点进行组合。采用压缩的联合查找算法(Union Find algorithm)有效查找连接组件，每个组件都是候选障碍物集群。</p><p><img src="/2020/05/13/apollo-lidar_segmentor/disjoint.jpeg" style="zoom:67%;"></p><blockquote><p>参考算法”并查集“ ，可参考如下链接 https://cloud.tencent.com/developer/news/362302</p></blockquote></li><li><p><code>ToLabelMap(labels)</code> 将障碍物cluster收集到<code>&lt;SppLabelImage&gt;</code>中的数据存储结构<code>&lt;SppCluster&gt;</code>中，设置label image中各个cluster的标签id，从1开始，将相同根节点的网格(<strong>程序中称为pixel</strong>)添加到同一个cluster中。</p></li></ul></li><li><p>然后对获取的到的cluster进行过滤(根据网络输出的confidence_pt_blob,category_pt_blob,以及 confidence的阈值默认0.1，objectness的阈值0.5进行判断)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: filter clusters, given confidence map</span></span><br><span class="line"><span class="comment">// @param [in]: confidence_map of the same size</span></span><br><span class="line"><span class="comment">// @param [in]: confidence threshold</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SppLabelImage::FilterClusters</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>* confidence_map,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">float</span>* category_map,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">float</span> confidence_threshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">float</span> category_threshold)</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>通过将cluster中所有的pixel对应的confidence或者category的分数和取平均作为cluster的置信度，根据阈值判断是否有效，并对clusters_ 进行过滤，并更新labels_ 中的标签，将无效的cluster的标签置为0(背景)</p><ul><li><p>根据网络输出的class map计算每个cluster的类别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// @brief: calculate class for each cluster, given class map</span></span><br><span class="line">    <span class="comment">// @param [in]: class_map of the same size</span></span><br><span class="line"><span class="comment">// @param [in]: class number default:5</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SppLabelImage::CalculateClusterClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>* class_map, <span class="keyword">size_t</span> class_num)</span></span>;</span><br></pre></td></tr></table></figure><p>默认类别数量是有5类：<code>UNKNOWN,SAMLLMOT,BIGMOT,NONMOT,PEDESTRIAN</code> 网络的输出<code>class_map</code>共有class_num层,每一层大小为width*height(网格大小)</p></li><li><p>根据网络输出的heading_data计算每个cluster的朝向</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// @brief: calculate heading (yaw) for each cluster, given heading map</span></span><br><span class="line"><span class="comment">// @param [in]: heading_map of the same size</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SppLabelImage::CalculateClusterHeading</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>* heading_map)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>网络输出的heading_map 是由x朝向和y朝向两层组成，根据x方向和y方向的位置朝向通过arctan(y/x)计算得到yaw轴角度。</p><ul><li><p>根据网络输出的top_z_map计算cluster的高度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// @brief: calculate top_z for each cluster, given top_z map</span></span><br><span class="line"><span class="comment">// @param [in]: top_z_map of the same size</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SppLabelImage::CalculateClusterTopZ</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>* top_z_map)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>根据label_image计算的clusters_ 对齐spp_cluster_list中的clusters_，然后向cluster中添加点云中的点的点的信息，即2d-&gt;3d</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// @brief: add an 3d point sample</span></span><br><span class="line">    <span class="comment">// @param [in]: cluster id</span></span><br><span class="line">    <span class="comment">// @param [in]: 3d point</span></span><br><span class="line">    <span class="comment">// @param [in]: point height above ground</span></span><br><span class="line">    <span class="comment">// @param [in]: point id</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SppClusterList::AddPointSample</span><span class="params">(<span class="keyword">size_t</span> cluster_id, <span class="keyword">const</span> base::PointF&amp; <span class="built_in">point</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">float</span> <span class="built_in">height</span>, <span class="keyword">uint32_t</span> point_id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>清除空的cluster</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: remove empty cluster from clusters</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SppClusterList::RemoveEmptyClusters</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>进行<strong>背景分割</strong>，首先需要同步线程，然后将roi点云中的高度拷贝到原始点云中，并将原始点云中的标签修改为对应roi_id的<code>LidarPointLabel::GROUND</code>，然后移除ground对应的点points。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: remove ground points in foreground cluster</span></span><br><span class="line"><span class="comment">// @param [in]: point cloud</span></span><br><span class="line"><span class="comment">// @param [in]: roi indices of point cloud</span></span><br><span class="line"><span class="comment">// @param [in]: non ground indices in roi of point cloud</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">SppEngine::RemoveGroundPointsInForegroundCluster</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> base::PointFCloudConstPtr full_point_cloud,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> base::PointIndices&amp; roi_indices,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> base::PointIndices&amp; roi_non_ground_indices)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>将clusters的相关属性添加到<code>&lt;object&gt;</code>数据结构中，例如cluster各个类别的概率和对应的object类型： object中的<code>UNKNOWN,PEDESTRIAN,BICYLE,VEHICLE</code> 分别对应cluster中的<code>META_UNKNOW,META_PEDESTRIAN,META_NOMOT,META_SMALLMOT+META_BIGMOT</code> 然后将cluster的朝向信息复制到<code>&lt;object&gt;</code>的<code>theta</code>,<code>direction</code>属性。</p></li></ol></li></ul><p><img src="/2020/05/13/apollo-lidar_segmentor/v2-271a10503da886feee8f6e4752a58901_720w.jpg" style="zoom:67%;"></p><hr><h3 id="四-障碍物边框构建">四、 障碍物边框构建</h3><p>对象构建器组件为检测到的障碍物建立一个边界框。 接口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: calculate and fill object size, center, directions.</span></span><br><span class="line"><span class="comment">// @param [in]: ObjectBuilderOptions.</span></span><br><span class="line"><span class="comment">// @param [in/out]: LidarFrame*.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObjectBuilder::Build</span><span class="params">(<span class="keyword">const</span> ObjectBuilderOptions&amp; options, LidarFrame* frame)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>首先对每一个检测得到的物体计算2D多边形凸包：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: calculate 2d polygon.</span></span><br><span class="line"><span class="comment">//         and fill the convex hull vertices in object-&gt;polygon.</span></span><br><span class="line"><span class="comment">// @param [in/out]: ObjectPtr.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputePolygon2D</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::perception::base::Object&gt; object)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>计算物体包含点云的最小最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: calculate 3D min max point</span></span><br><span class="line"><span class="comment">// @param [in]: point cloud.</span></span><br><span class="line"><span class="comment">// @param [in/out]: min and max points.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectBuilder::GetMinMax3D</span><span class="params">(<span class="keyword">const</span> apollo::perception::base::PointCloud&lt;</span></span></span><br><span class="line"><span class="function"><span class="params">                     apollo::perception::base::PointF&gt;&amp; cloud,</span></span></span><br><span class="line"><span class="function"><span class="params">                 Eigen::Vector3f* min_pt, Eigen::Vector3f* max_pt)</span></span>;</span><br></pre></td></tr></table></figure><p>根据该物体包含的点云，得到该点云中x,y,z方向向最小值<code>min_pt</code>和最大值<code>max_pt</code>。</p></li><li><p>根据x,y,z方向上的最大值和最小值，计算和填充默认的多边形的属性值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: calculate and fill default polygon value.</span></span><br><span class="line"> <span class="comment">// @param [in]: min and max point.</span></span><br><span class="line"> <span class="comment">// @param [in/out]: ObjectPtr.</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ObjectBuilder::SetDefaultValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> Eigen::Vector3f&amp; min_pt, <span class="keyword">const</span> Eigen::Vector3f&amp; max_pt,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::perception::base::Object&gt; object)</span></span>;</span><br></pre></td></tr></table></figure><p>根据min_pt和max_pt计算默认的<code>center,size(LWH),direction,polygon(4)</code></p></li><li><p>判断输入的点云是否位于一条直线上，如果是的话加入轻微扰动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: decide whether input cloud is on the same line.</span></span><br><span class="line"><span class="comment">//         if ture, add perturbation.</span></span><br><span class="line"><span class="comment">// @param [in/out]: pointcloud.</span></span><br><span class="line"><span class="comment">// @param [out]: is line: true, not line: false.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObjectBuilder::LinePerturbation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    apollo::perception::base::PointCloud&lt;apollo::perception::base::PointF&gt;*</span></span></span><br><span class="line"><span class="function"><span class="params">        cloud)</span></span>;</span><br></pre></td></tr></table></figure><p>判断三点是否共线，<span class="math inline">\(x_1y_2=x_2y_1\)</span> ，若共线则在坐标上添加一个小扰动0.001</p></li><li><p>根据输入点云得到多边形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: main interface to get polygon from input point cloud</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetConvexHull</span><span class="params">(<span class="keyword">const</span> CLOUD_IN_TYPE&amp; in_cloud,</span></span></span><br><span class="line"><span class="function"><span class="params">                   CLOUD_OUT_TYPE* out_polygon)</span> </span>&#123;</span><br><span class="line">  SetPoints(in_cloud);<span class="comment">//将点云复制到类内成员变量</span></span><br><span class="line">  <span class="keyword">if</span> (!GetConvexHullMonotoneChain(out_polygon)) &#123;</span><br><span class="line">    <span class="keyword">return</span> MockConvexHull(out_polygon);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>利用二维凸包算法 计算凸包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compute convex hull using Andrew's monotone chain algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">common::GetConvexHullMonotoneChain</span><span class="params">(CLOUD_OUT_TYPE* out_polygon)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>排序，根据某个坐标轴为主进行排序</li><li>从x最小的点开始</li><li>利用类似Graham’s Scan算法，利用栈去寻找下半包</li><li>从x最大的点开始</li><li>利用类似Graham’s Scan算法，利用栈去寻找上半包</li><li>两个半包结合，即是整个凸包 （上半包和下半包可以合并成一个while函数）</li></ol></blockquote><p>针对一些退化的情况，例如点云中的点小于3等情况，通过以下方式获取凸包：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mock a polygon for some degenerate cases</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MockConvexHull</span><span class="params">(CLOUD_OUT_TYPE* out_polygon)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>计算凸包中心和大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: calculate the size, center of polygon.</span></span><br><span class="line"><span class="comment">// @param [in/out]: ObjectPtr.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputePolygonSizeCenter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::perception::base::Object&gt; object)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>计算边界框的大小和中心点,输入包括点云，物体方向，输出边界框的大小和中心点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief calculate the size and center of the bounding-box of a point cloud</span></span><br><span class="line"><span class="comment">// old name: compute_bbox_size_center_xy</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointCloudT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalculateBBoxSizeCenter2DXY</span><span class="params">(<span class="keyword">const</span> PointCloudT &amp;cloud,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> Eigen::Vector3f &amp;dir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Eigen::Vector3f *<span class="built_in">size</span>, Eigen::Vector3d *center,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">float</span> minimum_edge_length = FLT_EPSILON)</span> </span>&#123;</span><br></pre></td></tr></table></figure></li><li><p>计算并填充其余的一些物体多边形信息，如时间戳和anchor_point</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: calculate and fill timestamp and anchor_point.</span></span><br><span class="line"><span class="comment">// @param [in/out]: ObjectPtr.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputeOtherObjectInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::perception::base::Object&gt; object)</span></span>;</span><br></pre></td></tr></table></figure><p>将object的中心作为anchor_point,object所包含点云所有点的平均时间作为物体的最新测量时间。 更新<code>object-&gt;anchor_point</code>,<code>object-&gt;latest_tracked_time</code></p></li></ul></li></ul><hr><h3 id="五过滤检测得到的object">五、过滤检测得到的object</h3><p>接口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: filter objects</span></span><br><span class="line"><span class="comment">// @param [in]: options</span></span><br><span class="line"><span class="comment">// @param [in/out]: frame</span></span><br><span class="line"><span class="comment">// segmented_objects should be valid, and will be filtered,</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObjectFilterBank::Filter</span><span class="params">(<span class="keyword">const</span> ObjectFilterOptions&amp; options, LidarFrame* frame)</span></span>;</span><br></pre></td></tr></table></figure><p>通过<code>FilterBank</code>中存在的filter过滤器对检测得到的object进行过滤，注意此处filterbank中可能存在不止一种过滤器,此处在初始化配置是添加的过滤器名称为:<code>ROIBoundaryFilter</code> 通过高精度地图中感兴趣的区域进行过滤。</p><p>如果高精度地图中没有对应的roi polygons，则跳过该步骤，并令object中的： <code>object-&gt;lidar_supplement.is_in_roi=true</code> 否则则进行过滤：</p><ol type="1"><li><p>首先，<code>FillObjectRoiFlag(options, frame);</code>确定object是否位于roi的交界处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: fill is_in_roi in lidar object supplement</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ROIBoundaryFilter::FillObjectRoiFlag</span><span class="params">(<span class="keyword">const</span> ObjectFilterOptions&amp; options, LidarFrame* frame)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>然后，在世界坐标系中构建polygon(将原lidar坐标系中的polygon中的点转换到世界坐标系中的点)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: given input objects, build polygon in world frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ROIBoundaryFilter::BuildWorldPolygons</span><span class="params">(<span class="keyword">const</span> ObjectFilterOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> LidarFrame&amp; frame)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>然后，过滤在道路边界之外的object：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: filter outside objects based on distance to boundary</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterObjectsOutsideBoundary</span><span class="params">(<span class="keyword">const</span> ObjectFilterOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  LidarFrame* frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;* objects_valid_flag)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>然后，过滤在道路边界内的object,置信度&lt;=0.11。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: filter inside objects based on distance to boundary</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterObjectsInsideBoundary</span><span class="params">(<span class="keyword">const</span> ObjectFilterOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 LidarFrame* frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;* objects_valid_flag)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>最后，通过confidence对在roi边界处 或者roi外部的object的confidence&lt;0.5进行过滤：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: filter objects based on position and confidence</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterObjectsByConfidence</span><span class="params">(<span class="keyword">const</span> ObjectFilterOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LidarFrame* frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;* objects_valid_flag)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>最后将检测结果通过通道<code>&quot;/perception/inner/SegmentationObjects&quot;</code>输出该部分得到的障碍物检测信息，对应的消息类型是：<code>&lt;LidarFrameMessage&gt;</code>（位于lidar_inner_component_message.h中 即内部消息类型定义）</strong></p><h3 id="参考资料">参考资料</h3><blockquote><p>CnnSeg网络的相关解析可以参考：https://zhuanlan.zhihu.com/p/35034215</p><p>https://www.jianshu.com/p/95a51214959b https://github.com/ApolloAuto/apollo/blob/master/docs/specs/3d_obstacle_perception_cn.md</p></blockquote><p>扫描线算法：https://www.jianshu.com/p/d9be99077c2b</p><p>lidar 分割： https://cloud.tencent.com/developer/news/362302</p>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lidar目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo Hungarian算法</title>
      <link href="/2020/05/13/apollo-KM_Hungarian/"/>
      <url>/2020/05/13/apollo-KM_Hungarian/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol type="1"><li>从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。<ol type="1"><li>如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。</li><li>如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。</li></ol></li><li>由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 <code>prev</code> 数组。</li></ol>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lidar目标跟踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo 融合算法--fusion component</title>
      <link href="/2020/05/13/apollo-fusion/"/>
      <url>/2020/05/13/apollo-fusion/</url>
      
        <content type="html"><![CDATA[<p>多传感器融合将各种传感器进行多层次，多空间的信息互补和优化组合处理，最终产生对观测环境的一致性解释。在自动驾驶平台中稳定可靠的感知算法仍然是有待解决的问题，多个传感器信息融合无疑成为提升自动驾驶安全性的趋势。</p><p><img src="/2020/05/13/apollo-fusion/sensorfusion.png" alt="sensorfusion" style="zoom: 33%;"></p><a id="more"></a><h2 id="一组件初始化和相关配置">一、组件初始化和相关配置</h2><h3 id="外部配置文件">1. 外部配置文件</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">components &#123;</span><br><span class="line">  class_name: <span class="string">"FusionComponent"</span></span><br><span class="line">  config &#123;</span><br><span class="line">    name: <span class="string">"SensorFusion"</span></span><br><span class="line">    config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/fusion/fusion_component_conf.pb.txt"</span></span><br><span class="line">    readers &#123;</span><br><span class="line">        channel: <span class="string">"/perception/inner/PrefusedObjects"</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件的配置文件：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#../productrion/conf/preception/fusion/fusion_component_conf.pb.txt</span><br><span class="line">fusion_method: <span class="string">"ProbabilisticFusion"</span></span><br><span class="line">fusion_main_sensor: <span class="string">"velodyne128"</span></span><br><span class="line">object_in_roi_check: <span class="literal">true</span></span><br><span class="line">radius_for_roi_object_check: <span class="number">120</span></span><br><span class="line">output_obstacles_channel_name: <span class="string">"/apollo/perception/obstacles"</span></span><br><span class="line">output_viz_fused_content_channel_name: <span class="string">"/perception/inner/visualization/FusedObjects"</span></span><br></pre></td></tr></table></figure><p>接收来自<code>fusion_camera_detection_component</code> ,<code>recognition_component</code>,<code>radar_detection_component</code>三个相关组件输出的<code>/percepiton/inner/PrefusedObjects</code>通道信息，信息格式位于<code>inner_component_messages.h</code>的<code>&lt;SensorFrameMessage&gt;</code></p><p>该组件的输出通道为<code>&quot;/apollo/perception/obstacles&quot;</code> 信息格式为<code>&lt;PerceptionObstacles&gt;</code>位于 <code>modules/perception/proto/preception_obstacle.proto</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message PerceptionObstacles &#123;</span><br><span class="line">  repeated PerceptionObstacle perception_obstacle = <span class="number">1</span>;  <span class="comment">// An array of obstacles</span></span><br><span class="line">  optional common.Header header = <span class="number">2</span>;                    <span class="comment">// Header</span></span><br><span class="line">  optional common.ErrorCode error_code = <span class="number">3</span> [<span class="keyword">default</span> = OK];</span><br><span class="line">  optional LaneMarkers lane_marker = <span class="number">4</span>;</span><br><span class="line">  optional CIPVInfo cipv_info = <span class="number">5</span>;  <span class="comment">// Closest In Path Vehicle (CIPV)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="功能初始化">2. 功能初始化</h3><p>功能类<code>&lt;fusion::ObstacleMultiSensorFusion&gt;</code>初始化: 根据配置文件中的<code>fusion_method</code>创建接口类<code>BaseFusionSystem</code>的实例化对象指针并初始化<code>fusion_-&gt;Init()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ProbabilisticFusion::Init</span><span class="params">(<span class="keyword">const</span> FusionInitOptions&amp; init_options)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><p>由<code>ConfigManager</code>管理的该功能类的相关参数为：</p><table><thead><tr class="header"><th style="text-align: center;">参数名称</th><th style="text-align: center;">默认值</th><th style="text-align: center;">参数说明</th><th style="text-align: center;">参数类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">use_lidar</td><td style="text-align: center;">true</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">use_radar</td><td style="text-align: center;">true</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">use_camera</td><td style="text-align: center;">true</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">tracked_method</td><td style="text-align: center;">PbfTracker</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">data_association_method</td><td style="text-align: center;">HMAssociation</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">gate_keeper_method</td><td style="text-align: center;">PbfGatekeeper</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">prohibition_sensors</td><td style="text-align: center;">radar_front</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">max_lidar_invisible_period</td><td style="text-align: center;">0.25</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">max_radar_invisible_period</td><td style="text-align: center;">0.50</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">max_camera_invisible_period</td><td style="text-align: center;">0.75</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">max_cached_frame_num</td><td style="text-align: center;">50</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p><strong>创建初始化<code>scenes_</code>,<code>matcher_</code>,<code>gate_keeper_</code>分别对应<code>&lt;Scene&gt;</code>,<code>&lt;HMtrakersObjectsAssociation&gt;</code>,<code>&lt;PbfGatekeeper&gt;</code></strong></p><ul><li><p><code>matcher_-&gt;Init()</code></p><table><thead><tr class="header"><th style="text-align: center;">参数名称</th><th style="text-align: center;">默认值</th><th style="text-align: center;">参数说明</th><th style="text-align: center;">参数类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">s_match_distance_thresh_</td><td style="text-align: center;">4.0</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">s_match_distance_bound_</td><td style="text-align: center;">100.0</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">s_association_center_dist_threshold_</td><td style="text-align: center;">30.0</td><td style="text-align: center;">单位：米</td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p><code>s_association_center_dist_threshold_</code> 参数说明： 对于相机与(lidar/radar)的关联，考虑到2d-to-3d的平均误差为7%,30m是200m的15%,是两倍的平均误差。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HMTrackersObjectsAssociation::Init</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    track_object_distance_.set_distance_thresh(</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(s_match_distance_thresh_));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>gate_keeper_-&gt;Init()</code></p><p>ConfigManager管理的参数：</p><table><thead><tr class="header"><th style="text-align: center;">参数名称</th><th style="text-align: center;">默认值</th><th style="text-align: center;">参数说明</th><th style="text-align: center;">参数类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">publish_if_has_lidar</td><td style="text-align: center;">true</td><td style="text-align: center;"></td><td style="text-align: center;">bool</td></tr><tr class="even"><td style="text-align: center;">publish_if_has_radar</td><td style="text-align: center;">true</td><td style="text-align: center;"></td><td style="text-align: center;">bool</td></tr><tr class="odd"><td style="text-align: center;">publish_if_has_camera</td><td style="text-align: center;">true</td><td style="text-align: center;"></td><td style="text-align: center;">bool</td></tr><tr class="even"><td style="text-align: center;">use_camera_3d</td><td style="text-align: center;">true</td><td style="text-align: center;"></td><td style="text-align: center;">bool</td></tr><tr class="odd"><td style="text-align: center;">min_radar_confident_distance</td><td style="text-align: center;">40</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">max_radar_confident_angle</td><td style="text-align: center;">20</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">min_camera_publish_distance</td><td style="text-align: center;">50</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">invisible_period_threshold</td><td style="text-align: center;">0.001</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">toic_threshold</td><td style="text-align: center;">0.8</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">use_track_time_pub_strategy</td><td style="text-align: center;">true</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">pub_track_time_thresh</td><td style="text-align: center;">3</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">existance_threshold</td><td style="text-align: center;">0.7</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">radar_existance_threshold</td><td style="text-align: center;">0.9</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table></li></ul><p><strong>最后进行数据融合的初始化，包括了三个方面：</strong></p><blockquote><ul><li>TypeFusion</li><li>ExistanceFusion</li><li>PbfTracker</li></ul></blockquote><ol type="1"><li><code>TypeFusion::Init()</code></li></ol><p>ConfigManager管理的参数，对应各lidar和camera的检测结果的可信度。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#注这里是.pt文件 实际通过GetProtoFromFile加载</span><br><span class="line">camera_params &#123;</span><br><span class="line">  name: <span class="string">"front_6mm"</span></span><br><span class="line">  valid_dist: <span class="number">110</span></span><br><span class="line">  reliability: <span class="number">0.95</span></span><br><span class="line">  reliability_for_unknown: <span class="number">0.2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">camera_params &#123;</span><br><span class="line">  name: <span class="string">"front_12mm"</span></span><br><span class="line">  valid_dist: <span class="number">150</span></span><br><span class="line">  reliability: <span class="number">0.5</span></span><br><span class="line">  reliability_for_unknown: <span class="number">0.2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lidar_params &#123;</span><br><span class="line">  name: <span class="string">"velodyne64"</span></span><br><span class="line">  reliability: <span class="number">0.5</span></span><br><span class="line">  reliability_for_unknown: <span class="number">0.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应修改<code>&lt;DstTypeFusionOpitons&gt;</code>配置参数,默认如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DstTypeFusionOptions</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">double</span>&gt; camera_max_valid_dist_ = &#123;</span><br><span class="line">      &#123;<span class="string">"camera_smartereye"</span>, <span class="number">110</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"camera_front_obstacle"</span>, <span class="number">110</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"front_6mm"</span>, <span class="number">110</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"camera_front_narrow"</span>, <span class="number">150</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">double</span>&gt; sensor_reliability_ = &#123;</span><br><span class="line">      &#123;<span class="string">"velodyne64"</span>, <span class="number">0.5</span>&#125;,          &#123;<span class="string">"velodyne_64"</span>, <span class="number">0.5</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"velodyne128"</span>, <span class="number">0.5</span>&#125;,         &#123;<span class="string">"camera_smartereye"</span>, <span class="number">0.95</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"front_6mm"</span>, <span class="number">0.95</span>&#125;,          &#123;<span class="string">"camera_front_obstacle"</span>, <span class="number">0.95</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"camera_front_narrow"</span>, <span class="number">0.5</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">double</span>&gt; sensor_reliability_for_unknown_ = &#123;</span><br><span class="line">      &#123;<span class="string">"velodyne64"</span>, <span class="number">0.5</span>&#125;,          &#123;<span class="string">"velodyne_64"</span>, <span class="number">0.5</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"velodyne128"</span>, <span class="number">0.5</span>&#125;,         &#123;<span class="string">"camera_smartereye"</span>, <span class="number">0.2</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"front_6mm"</span>, <span class="number">0.2</span>&#125;,           &#123;<span class="string">"camera_front_obstacle"</span>, <span class="number">0.2</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"camera_front_narrow"</span>, <span class="number">0.2</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在TypeFusion初始化的最后一步通过一个单例类<code>&lt;DstManager&gt;</code>管理各个子节点和它们之间的相互关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// brief: app initialization</span></span><br><span class="line"><span class="comment">// param [in]: app_name (now it is TypeFusion)</span></span><br><span class="line"><span class="comment">// param [in]: fod_subsets, hypotheses sets</span></span><br><span class="line"><span class="comment">// param [in]: fod_subset_names</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DstManager::AddApp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;app_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; &amp;fod_subsets,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;fod_subset_names)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中fod_subsets为<code>&lt;DstTypeFusion::DstMaps&gt;</code>中的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; fod_subsets_ = &#123;</span><br><span class="line">    PEDESTRIAN=<span class="number">1</span>,     BICYCLE=<span class="number">2</span>, VEHICLE=<span class="number">4</span>, OTHERS_MOVABLE=<span class="number">8</span>,</span><br><span class="line">    OTHERS_UNMOVABLE=<span class="number">16</span>, OTHERS=<span class="number">24</span>,  UNKNOWN=<span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure><p>对应的fod_subset_names为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; subset_names_ = &#123;</span><br><span class="line">    <span class="string">"PEDESTRIAN"</span>,       <span class="string">"BICYCLE"</span>, <span class="string">"VEHICLE"</span>, <span class="string">"OTHERS_MOVABLE"</span>,</span><br><span class="line">    <span class="string">"OTHERS_UNMOVABLE"</span>, <span class="string">"OTHERS"</span>,  <span class="string">"UNKNOWN"</span>&#125;;</span><br></pre></td></tr></table></figure><p>用二进制每一位表示一个类型，若是多个类型的复合则将对应位置为1</p></blockquote><p><code>&lt;DstManager&gt;</code>类主要管理的数据结构为：<code>&lt;DstCommonData&gt;</code> 将其与各个<code>app_name</code>作为一个map</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DstCommonData</span> &#123;</span></span><br><span class="line">  <span class="comment">// ensure initialize DSTEvidence once</span></span><br><span class="line">  <span class="keyword">bool</span> init_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// fods</span></span><br><span class="line">  <span class="keyword">size_t</span> fod_loc_ = <span class="number">0</span>; <span class="comment">//the indice of fod</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; fod_subsets_;</span><br><span class="line">  <span class="comment">// for transforming to probability effectively</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; fod_subset_cardinalities_; <span class="comment">//对应fod_subset中各个值对应二进制1的个数</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fod_subset_names_;</span><br><span class="line">  <span class="comment">// for combining two bbas effectively. 对应inter_relation的subsets两两之间索引值</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt;&gt;&gt; combination_relations_;<span class="comment">//</span></span><br><span class="line">  <span class="comment">// for computing support vector effectively</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt;&gt; subset_relations_; <span class="comment">//对应subsets含有包含关系的subset索引</span></span><br><span class="line">  <span class="comment">// for computing plausibility vector effectively</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt;&gt; inter_relations_; <span class="comment">//对应subsets含有相同值的各subset索引</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint64_t</span>, <span class="keyword">size_t</span>&gt; subsets_ind_map_; <span class="comment">// pair(subset,indice )</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述各值通过<code>&lt;DstManager::AddMap&gt;</code>进行初值的填充，此处不展开。 inter_relations: <img src="/2020/05/13/apollo-fusion/image-20200429223959318.png" alt="image-20200429223959318">subset_relations:<img src="/2020/05/13/apollo-fusion/image-20200429224301475.png"></p><ol start="2" type="1"><li><code>DstExistanceFusion::Init()</code></li></ol><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">track_object_max_match_distance: <span class="number">4.0</span></span><br><span class="line"></span><br><span class="line">camera_valid_dist &#123;</span><br><span class="line">  camera_name: <span class="string">"camera_front_obstacle"</span></span><br><span class="line">  valid_dist: <span class="number">110</span></span><br><span class="line">&#125;</span><br><span class="line">camera_valid_dist &#123;</span><br><span class="line">  camera_name: <span class="string">"camera_front_narrow"</span></span><br><span class="line">  valid_dist: <span class="number">150</span></span><br><span class="line">&#125;</span><br><span class="line">camera_valid_dist &#123;</span><br><span class="line">  camera_name: <span class="string">"front_6mm"</span></span><br><span class="line">  valid_dist: <span class="number">110</span></span><br><span class="line">&#125;</span><br><span class="line">camera_valid_dist &#123;</span><br><span class="line">  camera_name: <span class="string">"front_12mm"</span></span><br><span class="line">  valid_dist: <span class="number">150</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样最后根据以下maps添加APP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ToicDstMaps</span> &#123;</span></span><br><span class="line">  <span class="comment">// for (N)TOIC: (not)target of interest in camera judgement</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; TOIC = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>), NTOIC = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>), TOICUNKOWN = (TOIC | NTOIC) &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; fod_subsets_ = &#123;TOIC, NTOIC, TOICUNKOWN&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; subset_names_ = &#123;<span class="string">"TOIC"</span>, <span class="string">"NTOIC"</span>, <span class="string">"TOICUNKOWN"</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExistanceDstMaps</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; EXIST = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>), NEXIST = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>), EXISTUNKOWN = (EXIST | NEXIST) &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; fod_subsets_ = &#123;EXIST, NEXIST, EXISTUNKOWN&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; subset_names_ = &#123;<span class="string">"EXIST"</span>, <span class="string">"NEXIST"</span>, <span class="string">"EXISTUNKOWN"</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处通过<code>DstManager::Instance()-&gt;AddApp</code>添加两个名称为<code>DstExistanceFusion</code> 和<code>DstToicFusion</code>的App</p><blockquote><p><strong>toic</strong> means :target of interest in camera judgement</p></blockquote><ol start="3" type="1"><li><code>PbfTracker::InitParams()</code></li></ol><table><thead><tr class="header"><th style="text-align: center;">参数名称</th><th style="text-align: center;">默认值</th><th style="text-align: center;">参数说明</th><th style="text-align: center;">参数类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">type_fusion_method</td><td style="text-align: center;">DstTypeFusion</td><td style="text-align: center;">融合方法类名称</td><td style="text-align: center;">string</td></tr><tr class="even"><td style="text-align: center;">motion_fusion_method</td><td style="text-align: center;">KalmanMotionFusion</td><td style="text-align: center;"></td><td style="text-align: center;">string</td></tr><tr class="odd"><td style="text-align: center;">shape_fusion_method</td><td style="text-align: center;">PbfShapeFusion</td><td style="text-align: center;"></td><td style="text-align: center;">string</td></tr><tr class="even"><td style="text-align: center;">existance_fusion_method</td><td style="text-align: center;">DstExistanceFusion</td><td style="text-align: center;"></td><td style="text-align: center;">string</td></tr></tbody></table><h2 id="二算法处理">二、算法处理</h2><p>多个传感器发布的<code>&lt;SensorFrameMessage&gt;</code>传递到Proc处理函数中，调用内部处理函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: multi sensor fusion entry function</span></span><br><span class="line"><span class="comment">// @param[in]: in_menssage (the received message)</span></span><br><span class="line"><span class="comment">// @param[out]: out_message (the ouyput message)</span></span><br><span class="line"><span class="comment">// @param[out]: viz_message (for visualizing)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FusionComponent::InternalProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage <span class="keyword">const</span>&gt;&amp; in_message,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PerceptionObstacles&gt; out_message,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; viz_message)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="消息序列化">2.1 消息序列化</h3><p><code>Msgserializer::SerializeMsg</code></p><h3 id="融合处理process">2.2融合处理Process( )</h3><p><code>fusion_-&gt;Process(frame, &amp;fused_objects)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: Process MultiSensorFusion</span></span><br><span class="line"><span class="comment">// @param[in]: frame (SensorFrameMessage-&gt;frame_)</span></span><br><span class="line"><span class="comment">// @param[out]: objects (To obtain the fused objects)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObstacleMultiSensorFusion::Process</span><span class="params">(<span class="keyword">const</span> base::FrameConstPtr&amp; frame,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt;* objects)</span></span>;</span><br></pre></td></tr></table></figure><p><code>fusion_-&gt;Fuse(options, frame, objects)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: func inteface</span></span><br><span class="line"><span class="comment">// @param[in]: options (FusionOptions ,default null) </span></span><br><span class="line"><span class="comment">// @param[in]: sensor_frame (SensorFrameMessage-&gt;frame_)</span></span><br><span class="line"><span class="comment">// @param[out]: objects (To obtain the fused objects)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ProbabilisticFusion::Fuse</span><span class="params">(<span class="keyword">const</span> FusionOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> base::FrameConstPtr&amp; sensor_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt;* fused_objects)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><ol type="1"><li><p><strong>Save frame data</strong> 这里用到了单例类<code>&lt;SensorDataManager&gt;</code>用于管理各个传感器帧数据，首先判断传感器是否是<code>publish_sensor</code>，即是否是主传感器（用于最用发布融合信息的基准,apollo默认是velodyne128）,从第一次接收主传感器数据开始，添加各传感器测量信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: add sensor frame message to &lt;Sensor&gt; datastructure</span></span><br><span class="line"><span class="comment">// @param[in]: frame_ptr (sensor frame)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SensorDataManager::AddSensorMeasurements</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> base::FrameConstPtr&amp; frame_ptr)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>Sensor::AddFrame(const base::FrameConstPtr&amp; frame_ptr)</code>将传感器数据存储到<code>&lt;SensorFrame&gt;</code>数据结构中 这里主要分两步：</p><ul><li>找到传感器(对应<code>&lt;Sensor&gt;</code>数据结构)，如果没有就创建</li><li>然后向对应传感器中添加数据帧frame，存储到<code>&lt;Sensor&gt;</code>的<code>frames_</code>中(对应的数据存储结构为<code>&lt;SensorFrame&gt;</code>) 这里暗含将原<code>&lt;frame&gt;</code>数据结构转换为<code>&lt;SensorFrame&gt;</code>数据结构</li></ul></li><li><p><strong>query related sensor_frames for fusion</strong> 数据融合的前期数据准备阶段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: get latest frame of each sensor</span></span><br><span class="line"><span class="comment">// @param[in]: timestamp(the timestamp of frame)</span></span><br><span class="line"><span class="comment">// @param[out]: frames (the realted frames)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SensorDataManager::GetLatestFrames</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> timestamp, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SensorFramePtr&gt;* frames)</span> <span class="keyword">const</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>以timestamp为依据，遍历当前的所有传感器<code>&lt;Sensor&gt;</code>,查询数据帧<code>&lt;SensorFrame&gt;</code> 范围 (_lastest_fused_time_stamp,time_stamp) 即上一次查询(融合)的时间到当前查询的时间范围内最新帧，并按照时间顺序由早到晚排序。</p></li><li><p><strong>preform fusion on realted frames</strong> 对于related frames中的每一帧，执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: perform fusion</span></span><br><span class="line"><span class="comment">// @param[in]: frame (each frame of the realted frames)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProbabilisticFusion::FuseFrame</span><span class="params">(<span class="keyword">const</span> SensorFramePtr&amp; frame)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>融合过程有三个步骤，每一个步骤又分为关联，更新，创建新的Track，注意下方函数均是对单一数据帧中的objects和tracks而言：</p><ul><li><p>ProbabilisticFusion::FusedForegroundTrack 前景融合</p><ul><li><p>HMTrackersObjectsAssociation::Associate (<code>sensor_objects &lt;----&gt; fusion_tracks</code>) 得到 <code>association_result</code></p><ul><li><p>HMTrackersObjectsAssociation::IdAssign() 得到assignments,unassigned_tracks,unassigned_measurements ； sensor_objects与相同传感器的tracks进行匹配，匹配依据是base_object-&gt;track_id</p></li><li><p>HMTrackersObjectsAssociation::ComputeAssociationDistanceMat() 得到association_mat 关联距离矩阵(unassigned_tracks,unassigned_measurements)</p><ul><li><p>TrackObjectDistance::Compute() 计算fused track 和 sensor object之间的距离，结合阈值判断当前检测sensor_object与各传感器对应的fused track中的object的距离(polygon distance)度量，然后其中的最小值作为最终的度量添加到关联矩阵中。 <strong>1</strong> 当新检测的sensor_object是<strong>Lidar</strong>时，计算与fused_track各个传感器的最新object的距离度量：</p><ul><li><p>TrackObjectDistance::ComputeLidarLidar(）</p><p>sensor_object(lidar检测)与fused_object(lidar检测)之间距离小于10m，计算Polygon中心之间的欧氏距离，否则返回<code>std::numeric_limits&lt;float&gt;::max</code>，即不进行匹配</p></li><li><p>TrackObjectDistance::ComputeLidarRadar(）</p><p>sensor_object(lidar检测)与fused_object(radar检测)之间距离小于10m,计算Polygon中心之间的欧式距离，否则返回<code>std::numeric_limits&lt;float&gt;::max</code> 即不进行匹配</p></li><li><p>TrackObjectDistance::ComputeLidarCamera(） lidar与camera的匹配距离计算则稍显复杂，首先先判断是否lidar自身传感器的跟踪连续，若不连续则判断sensor_object(lidar检测)与fused_object(camera检测)是否大于<strong>动态阈值</strong>，若是则直接返回<code>distance_thresh_=4.0</code>,否则，计算sensor_object(lidar)点云在相机图像平面的投影object与fused_object(camera检测)的相似性：</p><ul><li><p>ComputePtsBoxSimilarity()</p><p>计算点云的2d投影box和相机的2d投影box之间的相似性,取值范围[0,1]，方式是通过计算位置的相似性和形状的相似性，然后进行将这两个相似性融合。</p><ul><li><p>ComputePtsBoxLocationSimilarity()</p><p>计算点云和相机box的位置相似性，首先计算IOU(此处将box扩大一定尺寸再计算 IOU)，若没有交集则返回最小相似性1e-6，然后按照如下步骤：</p><ol type="1"><li>计算lidar投影的2d点位于camera box之外的各个点与camera box边界的平均距离</li><li>根据camera box的大小归一化这个距离，然后假设归一化后的距离服从高斯分布</li><li>假设归一化后的x,y方向像素差值服从正态分布，则它们转化为标准正太分布后的平方和服从卡方分布，通过卡方分布，得到相似性： <img src="/2020/05/13/apollo-fusion/chi_squared.png" alt="img"></li></ol></li><li><p>ComputePtsBoxShapeSimilarity() 计算点云和相机box的形状的相似性[0,1]:</p><ol type="1"><li>首先计算box尺寸的差异，针对点云只检测到一个点的，此处限制sensor_object(点云检测)的尺寸不能低于camera box的十分之一</li><li>将随机变量标准化(根据先验的标准差)，使其服从标准正态分布</li><li>同样根据卡方分布得到相似度</li></ol></li><li><p>FuseTwoProbabilities()</p><p>将上述两个概率融合(即相似度),当两概率之和大于1，融合概率大于0.5，否则小于0.5，得到的相似性[0,1]乘以距离阈值<code>distance_thresh_=4.0</code>即可得到最终的距离度量 <span class="math display">\[tmp=\frac{p1}{1-p1}*\frac{p2}{1-p2}\\prob = \frac{tmp}{tmp+1}\]</span></p></li></ul></li><li><p>QueryProjectedVeloCtOnCamera()</p><p>如果lidar检测目标的cloud为空(<strong>此处疑问：为啥有检测目标还会为空</strong>)，则将lidar检测的物体中心投影到相机图像坐标系中，计算中心点之间的距离(单位为像素)。</p></li></ul><p><strong>综上，通过计算lidar camera物体的相似性或者中心的距离得到lidar检测目标和camera目标之间的距离度量(此处最大值由distance_thresh_=4.0限定范围)</strong></p></li></ul><p><strong>2</strong> 当新检测到的sensor_object是radar时，基本与lidar时同样的操作，计算lidar 与radar之间的距离度量(与上面的相似)和camera与radar之间的距离度量：</p><ul><li>TrackObjectDistance::ComputeRadarCamera(） 与lidar和camera的距离度量相似，首先计算camera可用的信息：包括camera检测的2d box，物体的中心点以及box的宽和高；radar可用的信息：radar的检测物体的3d中心点以及8个顶点，将8个顶点的高度修改为相机检测物体的高度，然后都投影到2d图像平面。 紧接着计算相似性，若radar检测的物体在相机的视场内，相似性度量方式如下：<ul><li>ComputeRadarCameraXSimilarity() 计算中心点在x方向上的差异，并进行通过camera box size_x进行归一化 通过<code>WelshVarLossFun</code>计算相似性，然后限制最大概率(相似度)为(0.9)(进行缩放)，下图为 welshvarlossfun示意图，以0.5为阈值分为两段,横轴为距离，纵轴为概率。 <img src="/2020/05/13/apollo-fusion/image-20200508214807548.png" alt="image-20200508214807548" style="zoom:30%;"></li><li>ComputeRadarCameraYSimilarity() 计算2dbox中心点在y方向上的差异(单位为像素)，然后根据给定的标准差进行normalize,同样通过卡方分布获取相似性，最后根据给定的范围缩放概率到区间(0.5,0.6)</li><li>ComputeRadarCameraLocSimilarity() 计算物体3D center的位置差异(单位为米)，通过<code>WelshVarLossFun</code>获取相似性，然后进行缩放概率区间为(0,0.7) <img src="/2020/05/13/apollo-fusion/image-20200508222547038.png" alt="image-20200508222547038" style="zoom:30%;"></li><li>ComputeRadarCameraVelocitySimilarity() 当camera或者radar的速度大于2.0时，计算速度差值，并通过卡方分布得到相似性分数，然后限制缩放(&gt;0.5，即positive)的概率为最大0.9</li><li>FuseMultipleProbabilities() 最后将这多个概率融合，作为最终的相似度距离度量，融合过程概率先取对数，将乘法变为加法，然后再取指数。</li></ul></li><li>TrackObjectDistance::BuildProjectionCacheObject() 由于一般Lidar是360度视角，而相机视角有限，在进行距离计算时，需要判断lidar的点是否位于相机的视锥体(Frustum)中，此处采用的方式是将lidar点云投影到相机坐标系的图像平面中2d点中并判断是否超出了图像边界，将在相机视场内时，将lidar点的图像平面投影点保存到数据结构 <code>&lt;ProjectCache&gt;</code>中，该数据结构存储各数据帧各个物体lidar 2d图像投影点(注：前提是这些点的原3d点位于相机视场内)<code>&lt;ProjectionCacheObject&gt;</code> 为各个物体的基本存储单位，保存该物体的投影点的索引和2d边界框。</li></ul><p><strong>3</strong> 当新检测到的sensor_object是camera时，只计算与跟踪列表中lidar的检测目标的相似性，关于相机和相机本身的已经在相机检测组件中进行了融合。</p></li></ul></li><li><p>HMTrackersObjectsAssociation::MinimizeAssignment() 根据上一步得到的距离矩阵通过匈牙利算法<code>common::GatedHungarianMatcher&lt;float&gt; optimizer_</code>进行二分图最优匹配，距离阈值4.0(用于判断连接是否有效),距离bound为100，得到<code>assignments</code>,<code>unassigned</code> <code>_tracks,unassigned_measurements</code></p></li><li><p>HMTrackersObjectsAssociation::PostIdAssign() 进行Id的后分配，得到<code>post_assignments</code>,相机检测得到的<code>unassigned_sensor_objects</code>在此处进行id分配，得到<code>post_assignment</code>,并添加到前面得到的<code>assignments</code>中</p></li><li><p>HMTrackersObjectsAssociation::GenerateUnassignedData(） 剔除<code>assignments</code>从而获取未被分配的unassigned_tracks和unassigned_measurements</p></li><li><p>HMTrackersObjectsAssociation::ComputeDistance() 填充<code>&lt;AssociationReult&gt;</code>数据结构中的<code>track2measurements_dist</code>和<code>measurement2track_dist</code></p></li></ul></li><li><p>ProbabilisticFusion::UpdateAssignedTracks 对于每个track根据当前已匹配的新的测量object更新track的状态，此处有一个参数<code>match_distance</code>用于在<code>ExistanceFusion</code>中计算<code>toic score</code>,由于此处track 和 object已经匹配，直接设置为0与实际的 match_distance差距不大，因此此处设为0</p><ul><li><p>PbfTracker::UpdateWithMeasurement() 更新包括4个融合方法：类型融合<code>DstTypeFusion</code>,运动状态融合<code>KalmanMotionFusion</code>,存在性融合 <code>DstExistanceFuison</code>以及形状外观融合<code>PbfShapeFusion</code></p><ul><li><p>DstExistanceFusion::UpdateWithMeasurement(） 基于证据的方法更新track存在的可能性</p></li><li><p>DstExistanceFusion::GetExistReliability() 根据测量物体的类型(是否是UNKNOWN)以及测量传感器的类型判断获取存在因子(这里对于lidar,camera,radar的权重依次为0.9,0.8,0.6,radar可信度较低)</p></li><li><p>DstExistanceFusion::ComputeDistDecay(） 将检测物体的中心坐标由世界坐标系转换到传感器坐标系下，并计算距离，若距离大于60m，则设置衰减率为0.8,否则1.0</p></li><li><p>Dst::SetBba(） 设置bba_vec_,根据存在的可信度</p></li><li><p>DstExistanceFusion::GetExistanceProbability() 通过初始化时预先设置的<code>combination_relations</code>和上步设置的<code>bba_vec_</code>计算 <code>probability_vec_</code>,然后返回<code>EXIST</code>对应的概率，计算详细过程见附录。</p></li><li><p><code>fused_existance_ =   fused_existance_ + existance_evidence * exist_fused_w * association_prob;</code> 通过重构的加法和乘法运算符融合更新<code>bba_vec_</code></p></li><li><p>DstExistanceFusion::UpdateToicWithCameraMeasurement(） 针对测量传感器是相机的情况，基本方法同Existance，先设置<code>bba_vec_</code></p><ul><li>ObjectInCameraView() 获取物体在相机视野中的可视率in_view_ratio，用于融合更新<code>bba_vec_</code> ,三种方法： 根据与该相机检测物体相匹配的track中的最近检测到的lidar或radar物体点云中的点出现在相机视野中的比例；当没有点云信息时，则根据物体3d边界框的顶点投影到相机图像平面的二维边界框在相机视野中所占的比例确定可视率；若边界框也无效的话，则根据物体三维中心点投影到相机图像平面的二维中心点，判断中心点是否位于相机的视野中，是则可视率直接设为1，否则为0。 由于相机检测物体随着距离的增加准确率会降低，因此根据下图所示的类sigmoid函数得到检测距离对应的权重(图中所示以150作为相机最大有效检测距离，0.25表示曲线的斜率),距离越远对应的值越小，用该值乘以上面得到的可视率作为最终的结果。 <img src="/2020/05/13/apollo-fusion/image-20200512151919053.png" alt="image-20200512151919053" style="zoom:30%;"></li></ul></li><li><p>DstExistanceFusion::UpdateExistanceState() 根据各自更新的<code>bba_vec_</code>，分别得到对应的概率值<code>GetToicProbability</code>和 <code>GetExistanceProbability</code>，并赋值到<code>track</code>的相关属性中。</p><p>更新<code>track-&gt;toic_prob_</code>和<code>track-&gt;existance_prob_</code></p></li><li><p>KalmanMotionFusion::UpdateWithMeasurement(） 基于Kalman Filter更新track的运动信息:</p></li><li><p>KalmanMotionFusion::InitFilter() 初始化滤波器的相关状态和不确定性矩阵，全局状态有 $[center(2),velocity(2),acceleration(2)]$6个。</p><ul><li>KalmanMotionFusion::UpdateSensorHistory(） <code>std::deque&lt;base::SensorType&gt; history_sensor_type_</code>中存储了过去物体测量值对应的传感器类型，存储容量为20，<code>history_velocity_</code>,<code>history_timestamp_</code>同理，分别存储过去测量值的速度和检测时间戳，用途是计算加速度和pseudo measurement，注意radar和lidar各自的最长追溯值为3个。</li><li>KalmanFilter::Init() 初始化状态矩阵，观测矩阵，状态转移矩阵，状态不确定性，观测不确定性， gain_break,value_break,kalman_gain</li><li>KalmanFilter::SetGainBreakdownThresh() <code>gain_break_down={0,0,0,0,1,1}  gain_break_down_threshold = 2.0f</code> 用于校正不合理的加速度增益</li><li>KalmanFilter::SetValueBreakdownThresh() <code>value_break_down={0,0,1,1,0,0} value_break_down_threshold = 0.05f</code> 用于校正不合理的速度</li></ul></li><li><p>KalmanMotionFusion::MotionFusionWithMeasurement()</p><ul><li><p>KalmanFilter::Predict(） 预测状态X(k+1|k)和协方差阵P <code>global_state,global_uncertainty</code></p></li><li><p>KalmanMotionFusion::ComputeAccelerationMeasurement() 计算加速度，当measurement传感器类型为camera时利用kalman滤波当前推断的加速度状态，当measurement传感器类型为lidar或radar利用<code>history_velocity</code></p></li><li><p>根据measurement object的中心位置和速度的不确定性更新测量协方差矩阵R</p></li><li><p>KalmanMotionFusion::ComputePseudoMeasurement()</p><p>计算伪测量值，根据lidar和radar，camera的原始测量值,以lidar为例，如果给定lidar的测量值能够在短时间内较好的估计radar的测量值，则将radar的测量值投影到给定的lidar测量值，具体如下：</p><ul><li><p>KalmanMotionFusion::ComputePseudoLidarMeasurement()</p><p>以lidar为例,首先追溯radar的测量历史<code>history_velocity_</code> ,试图通过找到好的radar测量值用于获得更加精确的lidar测量值(radar传感器本身速度测量较准)，如何算好的radar历史测量值？给出如下标准：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> radar速度的长度(标量)应与lidar速度的长度差值小于阈值<span class="number">5</span></span><br><span class="line"><span class="number">2.</span> radar测量速度矢量与lidar测量速度矢量的夹角(认为时角速度)小于阈值pi/<span class="number">20</span></span><br><span class="line"><span class="number">3.</span> radar速度矢量在lidar速度方向上的投影向量与lidar速度向量的差值矢量与加速度矢量的夹角(认为是角加速度)小于阈值</span><br><span class="line"><span class="number">4.</span> 上述投影差值矢量也应小于一定阈值</span><br></pre></td></tr></table></figure></p><p>满足条件，则将radar速度矢量的在lidar方向的投影值作为pseudo_measurement</p></li></ul></li><li><p>KalmanMotionFusion::RewardRMatrix()</p><p>根据传感器类型和速度是否收敛(object-&gt;velocity_converged)调整测量协方差阵R，</p></li><li><p>KalmanFilter::DeCorrelation() 去相关</p></li><li><p>KalmanFilter::Correct(）根据测量值和测量的不确定性矩阵R校正</p></li><li><p>KalmanFilter::CorrectionBreakdown()</p><p>判断加速度和速度状态的变化是否小于一定阈值，否则速度设为0，加速度的根据阈值进行设置。</p></li><li><p>卡尔曼滤波更新之后进行形状和位置的融合，如果测量传感器是lidar：使用lidar的anchor point和fused velocity。如果测量传感器是radar，同时没有历史的lidar跟踪目标，使用fused anchor point 和fused velocity。如果测量传感器是camera,同时有历史的lidar跟踪目标，使用fused position和fused velocity(滤波器估计值)；测量传感器是camera，同时没有历史lidar跟踪目标但是有radar跟踪目标，位置采用radar的anchor_point,速度采用滤波器的结果fused_velocity()；既没有lidar有没有radar，直接使用测量值作为fused_velocity和fused_anchor_point_。 加速度的更新因为没有传感器测量直接采用卡尔曼滤波器的状态输出结果。</p></li><li><p>KalmanMotionFusion::UpdateMotionState() 更新<code>track-&gt;fused_object</code>的运动状态，包括<code>velocity,acceleration,center_uncertainty,velocity_uncertainty,</code> ,acceleration_uncertainty`,不确定性目前是直接根据measurement赋值</p></li></ul></li><li><p>PbfShapeFusion::UpdateWithMeasurement(）</p><ul><li>PbfShapeFusion::UpdateState(）<ul><li>PbfShapeFusion::UpdateShape(） 更新<code>track-&gt;fused_object</code>的DstTypeFusion::UpdateWithMeasurement(形状信息,包括<code>size,direction,theta,polygon</code></li><li>PbfShapeFusion::UpdateCenter(） 更新<code>track-&gt;fused_object</code>的中心坐标，包括<code>center,anchor_point</code>,均直接根据测量值更新，没有中间处理</li></ul></li></ul></li><li><p>DstTypeFusion::UpdateWithMeasurement() 创建测量值对应的<code>Dst</code></p><ul><li><p>DstTypeFusion::TypeProbsToDst() 将物体<code>object-&gt;type_probs</code>转换为Dst。</p><ul><li><p>DstTypeFusion::TypToHyp() 将物体原检测类型转换为<code>Dst hypothesis types</code>,映射关系为:</p><table><thead><tr class="header"><th>origin object type</th><th>value</th><th>dst hypothesis types</th><th>value</th></tr></thead><tbody><tr class="odd"><td>UNKNOWN</td><td>0</td><td>OTHERS</td><td>0001 1000 (24)</td></tr><tr class="even"><td>UNKNOWN_MOVABLE</td><td>1</td><td>OTHERS_MOVABLE</td><td>0000 1000 (8)</td></tr><tr class="odd"><td>UNKNOWN_UNMOVABLE</td><td>2</td><td>OTHERS_UNMOVABLE</td><td>0001 0000 (16)</td></tr><tr class="even"><td>PEDESTRIAN</td><td>3</td><td>PEDESTRIAN</td><td>0000 0001 (1)</td></tr><tr class="odd"><td>BICYCLE</td><td>4</td><td>BICYCLE</td><td>0000 0010 (2)</td></tr><tr class="even"><td>VEHICLE</td><td>5</td><td>VEHICLE</td><td>0000 0100 (4)</td></tr><tr class="odd"><td></td><td></td><td>UNKNOWN</td><td>0001 1111 (31)</td></tr></tbody></table><p>将<code>origin object type</code>的检测概率值分别赋值到对应的<code>dst type</code>中构成<code>res_bba_map</code></p></li><li><p>Dst::SetBba() 设置<code>bba_vec_</code>根据当前检测类别概率值构造的<code>res_bba_map</code>,<code>fod_subsets_</code>包括: <code>{PEDESTRIAN, BICYCLE, VEHICLE, OTHERS_MOVABLE, OTHERS_UNMOVABLE, OTHERS,  UNKNOWN}</code></p></li></ul></li><li><p>根据 当前测量值设置<code>bba_vec_</code> 的<code>measurement_dst</code>对之前存在的<code>fused_dst_</code>进行更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fused_dst_ =</span><br><span class="line">      fused_dst_ + measurement_dst * GetReliability(measurement-&gt;GetSensorId());</span><br></pre></td></tr></table></figure></li><li><p>DstTypeFusion::GetReliability() 获取当前检测传感器对于物体类别的可靠程度： <code>velodyne64:0.5,front_6mm:0.95,front_12mm:0.5,....</code>等等,相机的类别检测的置信度较高</p></li><li><p>如果当前测量值对应的传感器是相机，则将测量值对应的<code>object-&gt;sub_type</code>赋值到 <code>fused_object-&gt;sub_type</code></p></li><li><p>DstTypeFusion::UpdateTypeState() 根据融合后的<code>bba_vec_</code>更新<code>fused_object</code>的类型概率。</p><ul><li><p>DstTypeFusion::HypToTyp() 将<code>hypothesis type</code>映射回原物体类型，这里将最大概率(bba_vec_中最大值索引)的<code>hypothesis</code>映射回<code>origin object type</code>并设置为<code>fused_object-&gt;type</code></p></li><li><p>修正<code>fused_object-&gt;subtype</code> 之前<code>fused_object-&gt;sub_type</code>由测量的物体的<code>sub_type</code>直接赋值，此处在更新了<code>type</code>之后，需要判断该子类型对应的<code>type</code>是否和更新的<code>type</code>相等，不相等将<code>fused-&gt;subtype</code>设置为<code>base::ObjectSubType::UNKNOWN</code></p></li><li><p>更新<code>fused_object-&gt;type_probs</code></p><p>根据<code>fused_subset</code>与原<code>type</code>的映射，将<code>bba_vec_</code>中的值复制到<code>type_probs</code>中</p></li></ul></li></ul></li><li><p>Track::UpdateWithSensorObject() 更新track对应的<code>SensorObject</code>,添加带有传感器id标记的object到对应的<code>lidar_objects_</code>,<code>radar_objects_</code>或<code>camera_objects_</code>的map中进行覆盖。然后将map中超时未被测量值匹配的object删除。同时需要更新最近一次被跟踪的时间戳为当前测量值的时间戳，更新对应传感器类型的补充属性，设置<code>is_alive_=True</code>，表明该track为活跃的。</p><ul><li>Track::UpdateSensorObject() 更新测量值对应传感器类型的objects中对应sensor_id(用于区分同一类传感器)的object,注意此处为直接覆盖。</li><li>Track::UpdateSensorObjectWithMeasurement() 根据传感器最大容忍的invisible时间间隔(lidar 0.25s radar 0.5s camera 0.75s),超出该时间间隔(即在这段时间内没有新的测量值进行匹配)则从objects中将对应的object删除 对track中的<code>lidar_objects</code>,<code>radar_objects</code>,<code>camera_objects</code>分别执行上述过程。</li><li>更新<code>fused_object_-&gt;latest_tracked_time</code>为当前测量物体的时间戳。</li><li>Track::UpdateSupplementState() 将测量值<code>object</code>的补充属性直接赋值到<code>fused_object</code>的补充属性中。同时对于track中 <code>lidar_objects_</code>,<code>radar_objects_</code>或<code>camera_objects_</code>谁为空(目前该传感器还没有匹配的测量值)就将谁对应的<code>fused_object</code>中对应的<code>lidar_supplement</code>,<code>camera_supplement</code>或 <code>camera_supplement</code>重置</li><li>Track::UpdateUnfusedState() 更新未融合的<code>fused_object</code>剩下的相关状态，对于lidar更新<code>fused_object-&gt;confidence</code>和<code>fused_object-&gt;velocity_converged</code>,对于radar没有啥还需要更新的，对于camera需要更新<code>fused_object-&gt;confidence</code></li></ul></li></ul></li></ul></li><li><p>ProbabilisticFusion::UpdateUnassignedTracks() 更新未被当前帧测量值匹配的track的状态,与函数<code>UpdateAssignedTracks()</code>类似，此处有一个参数<code>match_distance</code>用于在<code>ExistanceFusion</code>中计算<code>toic score</code>,由于此处track没有对应的测量值进行匹配，由于没有用到，临时设置match_dsitance为0。</p><ul><li><p>PbfTracker::UpdateWithoutMeasurement() 更新track的状态同样也包含四类融合：类型融合<code>DstTypeFusion</code>,运动状态融合<code>KalmanMotionFusion</code>,存在性融合<code>DstExistanceFuison</code>以及形状外观融合<code>PbfShapeFusion</code>,基本方法同有测量值的更新，此处简述：</p><ul><li><p>DstExistanceFusion::UpdateWithoutMeasurement() 输入:包括sensor_id,测量时间戳(当前检测数据帧的时间戳),<code>min_match_dist</code>(输入时的临时值为0) 输出:<code>track-&gt;toic_prob</code>,<code>track-&gt;existance_prob</code></p><ul><li>DstExistanceFusion::UpdateToicWithoutCameraMeasurement() 虽然当前帧没有匹配的测量值,但是利用历史track最近匹配lidar或radar检测物体进行可视程度的判断,用于更新<code>toic_</code></li></ul></li><li><p>KalmanMotionFusion::UpdateWithoutMeasurement() 就是根据时间差异进行一个简单的预测，由于没有测量因此也就没有校正阶段,但预测的前提是要求该track已经的kalman_filter已经初始化过同时有过匹配的测量值,更新fused_object的相关属性如下： <code>track-&gt;fused_object-&gt;velocity</code>,<code>acceleration</code>,<code>center_uncertainty</code>, <code>velocity_uncertainty</code>,<code>acceleration_uncertainty</code></p></li><li><p>PbfShapeFusion::UpdateWithoutMeasurement() do nothing!</p></li><li><p>DstTypeFusion::UpdateWithoutMeasurement() 仅对当前帧的测量传感器是相机的情况进行处理,比较特殊的是相机在计算不可信度时，采用了时间信息，根据当前测量的时间戳转换到小时，判断是否是晚上以此获得更新的权重比例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">double</span>&gt; sensor_reliability_for_unknown_ = &#123;</span><br><span class="line">  &#123;<span class="string">"velodyne64"</span>, <span class="number">0.5</span>&#125;,          &#123;<span class="string">"velodyne_64"</span>, <span class="number">0.5</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"velodyne128"</span>, <span class="number">0.5</span>&#125;,         &#123;<span class="string">"camera_smartereye"</span>, <span class="number">0.2</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"front_6mm"</span>, <span class="number">0.2</span>&#125;,           &#123;<span class="string">"camera_front_obstacle"</span>, <span class="number">0.2</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"camera_front_narrow"</span>, <span class="number">0.2</span>&#125;,</span><br></pre></td></tr></table></figure><p>更新track的相关属性如下: <code>track-&gt;fused_object-&gt;type_probs</code></p></li><li><p>Track::UpdateWithoutSensorObject()</p><ul><li>Track::UpdateSensorObjectWithoutMeasurement() 根据当前测量时刻的时间戳对track目前存在的历史<code>lidar_objects</code>,<code>radar_objects</code> ,<code>camera_objects</code>的<code>invisible_period</code>进行更新。对于<code>invisible_period</code>大于阈值的 objects进行清除。 根据track当前的<code>lidar_objects,radar_objects</code>,<code>camera_objects</code>是否全部为空来判断track是否是alive。</li></ul></li></ul></li></ul></li><li><p>ProbabilisticFusion::CreateNewTracks</p><p>根据未进行匹配当前帧测量物体,创建新的跟踪序列。</p><ul><li>Track::Initialize() 从并发对象池中获取track实例，并进行初始化，初始化过程主要由以下几步：<ol type="1"><li>重置<code>lidar_objects_,radar_objects_,camera_objects_</code>, 将fused_object设置为当前测量值并分配新的全局track_id。</li><li>Track::UpdateWithSensorObject()根据测量值对应的sensor_id将相应值添加到<code>lidar_objects_</code>或 <code>radar_objects</code>或<code>camera_objects</code>中</li></ol></li><li>Scene::AddForegroundTrack(TrackPtr track) 将该<code>track_</code>添加到<code>foreground_tracks_</code>列表中。</li><li>PbfTracker::Init(TrackPtr track, SensorObjectPtr measurement) 创建<code>&lt;PbfTracker&gt;</code>实例<code>tracker</code>，并通过<code>track_</code>和测量值进行初始化,首先通过<code>InitMethods</code>初始化跟踪融合的相关方法<code>type_fuison,shape_fusion,existance_fusion,motion_fusion</code>,创建他们的方法类实例。</li><li>将创建的<code>tracker</code>添加到<code>ProbabilisticFusion::trackers_</code>列表中</li></ul></li></ul></li><li>ProbabilisticFusion::FusebackgroundTrack(const SensorFramePtr&amp; frame) 背景物体跟踪,注意只有lidar传感器检测背景类物体。<ul><li>首先进行background_tracks和background_objects的关联，关联依据是track-&gt;fused_object-&gt;track_id(即该track目前对应的object的局部track_id)与当前检测物体的局部<code>track_id</code>相等，则进行关联</li><li>然后对已经匹配的track和object进行状态更新: Track::UpdateWithSensorObject(const SensorObjectPtr&amp; obj) 更新<code>track</code>中的sensor_objects (此处应该为<code>lidar_objects</code>)<ul><li>Track::UpdateWithSensorObjectForBackground() 根据测量值的BaseObject更新<code>fused_object_</code>的BaseObject,但是保留原<code>fused_object_</code>的track_id</li></ul></li><li>然后对未匹配的track进行状态更新: Track::UpdateWithoutSensorObject()</li><li>对未匹配的object创建新的跟踪序列: 从对象池中获取<code>track</code>实例，进行初始化<code>track-&gt;Initialize(...);</code>分配新的track_id。<ul><li>Scene::AddBackgroundTrack() 将新创建的track加入到背景跟踪列表<code>background_tracks_</code>中。</li></ul></li></ul></li><li><p>ProbabilisticFusion::RemoveLostTrack() 对应前景类，移除<code>track</code>和track对应的处理类<code>tracker</code>(仅前景类foreground存在该tracker处理) 查看<code>track-&gt;is_alive_</code>是否为true(本质上为track的lidar_objects_,radar_objects,camera_objects是否全为空), 对于背景类，仅需要移除<code>track</code></p></li></ul></li><li><p><strong>collect fused objects</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 收集融合的检测目标</span></span><br><span class="line"><span class="comment">// @params[in]: timestamp 当前传感器帧的时间戳</span></span><br><span class="line"><span class="comment">// @params[out]: fused_objects 融合的objects</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProbabilisticFusion::CollectFusedObjects</span><span class="params">(<span class="keyword">double</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt;* fused_objects)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>PbfGatekeeper::AbleToPublish(const TrackPtr &amp;track) 对于前景物体跟踪的各个track查询各个类别传感器对应的<code>invisible_period_</code>,下列三个函数返回各类传感器是否是Visible</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">track-&gt;IsLidarVisible() <span class="comment">//(note:lidar类别传感器有不同的id,例如64线,32线等等)</span></span><br><span class="line">track-&gt;IsRadarVisible() <span class="comment">//相机和radar同理</span></span><br><span class="line">track-&gt;IsCameraVisible()</span><br></pre></td></tr></table></figure><p>判断<code>invisible_period&lt; 1.0e-6</code>(要求一类传感器中的所有object) 即判断该传感器是否存在跟踪的中断。 下面三个函数分别判断传感器数据能否发布,若三种传感器都不能发布则返回False。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求lidar is visible 同时参数params_.publish_if_has_lidar为true时返回True</span></span><br><span class="line">PbfGatekeeper::LidarAbleToPublish()</span><br><span class="line"><span class="comment">//要求radar is visible 同时参数params_.publish_if_has_radar为true时,若track-&gt;radar_object</span></span><br><span class="line"><span class="comment">// 为"radar_front" ,返回false;若为"radar_rear",则满足：</span></span><br><span class="line"><span class="comment">// track-&gt;radar_object.range &gt; 40; track-&gt;radar_object.velocity&gt;4.0,</span></span><br><span class="line"><span class="comment">// track-&gt;existance_prob_&gt;0.9 时返回true.</span></span><br><span class="line">PbfGatekeeper::RadarAbleToPublish()</span><br><span class="line"><span class="comment">//　要求camera is visible 同时params_.publish_if_has_camera为true,is_night=False(白天)。</span></span><br><span class="line"><span class="comment">//  当subtype=TRAFFICCONE无视range大小及进行发布；若subtype=UNKNOWN_UNMOVABLE则还要求物体的</span></span><br><span class="line"><span class="comment">//  距离相机的距离&gt;50</span></span><br><span class="line"><span class="comment">//　track-&gt;existance_prob_&gt;0.7</span></span><br><span class="line">PbfGatekeeper::CameraAbleToPublish()</span><br></pre></td></tr></table></figure><ul><li>AddTrackedTimes() ++tracked_times_　增加该track被跟踪次数。 前提是上述条件满足。</li><li>GetTrackedTimes() 紧接着查询正常跟踪的次数，如果大于预设参数<code>params_.pub_track_time_thresh=3</code>表明该track已经超过3次被正常跟踪，可以进行发布了。</li></ul></li><li><p>ProbabilisticFusion::CollectObjectsByTrack() 从跟踪tracks中收集objects的相关属性,引入数据类型<code>&lt;SensorObjectMeasurement&gt;</code>位于object-&gt;fusion_supplement中:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sensor_id = <span class="string">"unknown_sensor"</span>;</span><br><span class="line"><span class="keyword">double</span> timestamp = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">int</span> track_id = <span class="number">-1</span>;</span><br><span class="line">Eigen::Vector3d center = Eigen::Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">float</span> theta = <span class="number">0.0f</span>;</span><br><span class="line">Eigen::Vector3f <span class="built_in">size</span> = Eigen::Vector3f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Eigen::Vector3f velocity = Eigen::Vector3f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ObjectType type = ObjectType::UNKNOWN;</span><br><span class="line"><span class="comment">// @brief only for camera measurement</span></span><br><span class="line">BBox2D&lt;<span class="keyword">float</span>&gt; box;</span><br></pre></td></tr></table></figure><ul><li><p>ProbabilisticFusion::CollectSensorMeasurementFromObject(...)</p><p>首先对于基础属性，直接将track-&gt;fused_object-&gt;baseobject赋值到该obj中; 对于补充属性(fusion_supplement),从track-&gt;lidar_objects,track-&gt;radar_objects,track-&gt;camera_objects中分别得到上述<code>&lt;SensorObjectMeasurement&gt;</code>中的参数值，保存到<code>obj-&gt;fusion_supplement.measurements</code>中，其中<code>measurements</code>为一个向量数组，大小为下所示，分别保存了对应该track的所有测量值。 <code>lidar_objects_.size() + camera_objects_.size() + radar_objects_.size()</code> 除了上述数据类型中的值外,设置该obj的track_id,latest_tracked_time(上一次被跟踪的时间),tracking_time(跟踪时长)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;track_id = track-&gt;GetTrackId();</span><br><span class="line">obj-&gt;latest_tracked_time = timestamp;</span><br><span class="line">obj-&gt;tracking_time = track-&gt;GetTrackingPeriod();</span><br></pre></td></tr></table></figure><p>对每一个track执行上述操作后，得到的obj添加到<code>fused_objects</code>列表中。</p></li></ul></li><li><p>对于背景物体的跟踪的相关处理方法同上，此处不赘述。</p></li></ul></li></ol><p>至此，<code>fusion_-&gt;Fuse(options, frame, objects)</code>完成,返回到<code>fusion_component</code>组件中。</p><hr><p>序列化消息用于发布：<code>viz_message</code>,<code>out_message</code> 当测量传感器为主传感器时，通过节点发布。</p><h3 id="参考链接">参考链接</h3><p>https://developer.baidu.com/topic/show/290445</p><p>https://blog.csdn.net/u012423865/article/details/80386444</p><p>https://zhuanlan.zhihu.com/p/116901401</p><p>https://blog.csdn.net/zhanghm1995/article/details/104910923</p><p>视锥体，判断Lidar 3D点是否位于相机视野内： https://blog.csdn.net/qq_29797957/article/details/96914792</p><h3 id="补充">补充</h3><h4 id="卡方分布">1.卡方分布：</h4><p>由n个相互独立的随机变量，均服从标准正态分布(独立同分布于标准正太分布)，则这n个服从标准正态分布的随机变量的平方和构成新的随机变量，其分布规律称为卡方分布，卡方分布位于第一象限，均值为自由度v，方差为2v。</p><h4 id="apollo中gatehungrianmatcher的匹配流程">2. apollo中<code>GateHungrianMatcher</code>的匹配流程：</h4><ol type="1"><li><p>创建优化器实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common::GatedHungarianMatcher&lt;<span class="keyword">float</span>&gt; optimizer_;</span><br></pre></td></tr></table></figure><p>通过实现已经获取的度量矩阵设置<code>global_costs</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common::SecureMat&lt;<span class="keyword">float</span>&gt;* global_costs = optimizer_.mutable_global_costs();</span><br></pre></td></tr></table></figure></li><li><p>运行主接口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optimizer_.Match(<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(s_match_distance_thresh_), <span class="comment">// thresh 4.0</span></span><br><span class="line">                   <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(s_match_distance_bound_), opt_flag, <span class="comment">//bound 100.0</span></span><br><span class="line">                   &amp;local_assignments, &amp;local_unassigned_tracks, <span class="comment">//row -&gt; tracks</span></span><br><span class="line">                   &amp;local_unassigned_measurements); <span class="comment">///column -&gt; measurements</span></span><br></pre></td></tr></table></figure><p><strong>2.1</strong> <code>MatchInit()</code> 获取行数和列数(即跟踪目标数量rows和测量目标cols的数量)，并根据opt_flag，确定比较函数,此处包含的选项有<code>OptimizeFlag::OPTMAX</code>和<code>OptimizeFlag::OPTMIN</code>分别对应与<code>thresh</code>的比较方式,例如当<code>opt_flag=OPTMIN</code>时，当<code>global_cost(i,j)&lt;s_match_distance_thresh_</code>时返回ture。 <strong>2.2</strong> <code>ComputeConnectedComponents(&amp;row_components, &amp;col_components)</code> 为了加速匹配的速度，将原始的cost_graph分割为几个小的子二分图,根据阈值<code>s_match_distance_thresh_</code>判断连接是否有效，将有效的相互连接组成一个 <code>Component</code> 以此将原始图进行分割为独立的子图，下图所示为关联矩阵以2.1为阈值，并进行图分割为2个component的例子，0<sub>6为对应的节点id，其中0</sub>2对应行,3~6对应列(id=row_num+col_id),最终函数返回： <code>row_components[0]={0,1},row_components[1]={2}；col_components[0]={3,4},col_components[1]={5,6}</code></p><p><img src="/2020/05/13/apollo-fusion/image-20200510203006092.png" alt="image-20200510203006092" style="zoom:30%;"></p><p><strong>2.3</strong> <code>OptimizeConnectedComponent</code> 对每个component进行优化，进行分配。 <strong>2.4</strong> <code>GenerateUnassiganedData</code> 生成未分配的节点的集合</p></li></ol><h4 id="pbftracker的更新融合方法">3. PbfTracker的更新融合方法</h4><h5 id="dstexistancefusion">3.1 DstExistanceFusion</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExistanceDstMaps</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; EXIST = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>), NEXIST = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>), EXISTUNKOWN = (EXIST | NEXIST) &#125;; <span class="comment">//1,2,3</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; fod_subsets_ = &#123;EXIST, NEXIST, EXISTUNKOWN&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; subset_names_ = &#123;<span class="string">"EXIST"</span>, <span class="string">"NEXIST"</span>, <span class="string">"EXISTUNKOWN"</span>&#125;;</span><br><span class="line">  <span class="comment">//EXISTUNKOWN从二进制角度来说包含了EXIST,NEXIST</span></span><br><span class="line">  <span class="comment">//subsets的索引ind是指从0开始各个subset的编号，此处 0 1 2 </span></span><br><span class="line">  <span class="comment">//它们的实际值为 01  10  11</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基于<code>&lt;Dst&gt;</code>数据结构，重构了加法和乘法运算符，对应成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> app_name_; <span class="comment">//唯一的标识符</span></span><br><span class="line"><span class="keyword">mutable</span> DstCommonDataPtr dst_data_ptr_ = <span class="literal">nullptr</span>; <span class="comment">//由DstManager管理的DstCommonData</span></span><br><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; bba_vec_; <span class="comment">//大小为subset的大小，内容为各个subset的mass(可理解为概率)取值0~1</span></span><br><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; support_vec_;</span><br><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; plausibility_vec_; <span class="comment">//合理性</span></span><br><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; uncertainty_vec_; <span class="comment">//不确定性</span></span><br><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; probability_vec_; <span class="comment">//大小为bba_vec的大小</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DstCommonData</span> &#123;</span></span><br><span class="line">  <span class="comment">// ensure initialize DSTEvidence once</span></span><br><span class="line">  <span class="keyword">bool</span> init_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// fods</span></span><br><span class="line">  <span class="keyword">size_t</span> fod_loc_ = <span class="number">0</span>; <span class="comment">//指向subsets的最后一个元素对应的编号值</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; fod_subsets_;</span><br><span class="line">  <span class="comment">// for transforming to probability effectively 存储各subset的二进制中1的位数</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; fod_subset_cardinalities_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fod_subset_names_;</span><br><span class="line">  <span class="comment">// for combining two bbas effectively. 用于计算probability_vec_,</span></span><br><span class="line">  <span class="comment">//  第一维表示两个fod_subset交集(大小为fod_sets大小)对应的subset的索引编号</span></span><br><span class="line">  <span class="comment">//  第二维为对应该交集的所有两个fod_subset的索引编号pair</span></span><br><span class="line">  <span class="comment">//　用于结合两个bbas</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt;&gt;&gt; combination_relations_; </span><br><span class="line">  <span class="comment">// for computing support vector effectively,第一维大小为fod_subsets大小，第二维存储各fod_subset二进制</span></span><br><span class="line">  <span class="comment">//包含（存在包含关系）的subset所对应的索引编号</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt;&gt; subset_relations_;</span><br><span class="line">  <span class="comment">// for computing plausibility vector effectively，第一维大小为fod_subsets大小，第二位存储各fod_subset二</span></span><br><span class="line">  <span class="comment">// 进制具有相同二进制位(存在交集)的subset对应的索引编号</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt;&gt; inter_relations_; <span class="comment">//intersection</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint64_t</span>, <span class="keyword">size_t</span>&gt; subsets_ind_map_;  <span class="comment">//pair(subset,ind)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>概率计算举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExistanceDstMaps</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; EXIST = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>), NEXIST = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>), EXISTUNKOWN = (EXIST | NEXIST) &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; fod_subsets_ = &#123;EXIST, NEXIST, EXISTUNKOWN&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; subset_names_ = &#123;<span class="string">"EXIST"</span>, <span class="string">"NEXIST"</span>, <span class="string">"EXISTUNKOWN"</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; probability_vec_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; bba_vec_=&#123;<span class="number">0.7</span>,<span class="number">0</span>,<span class="number">0.3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span> ,<span class="keyword">size_t</span> &gt;&gt;&gt; combination_relations_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; fod_subset_cardinalities_=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputeProbability</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    combination_relations_.resize(bba_vec_.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    combination_relations_[<span class="number">0</span>].push_back(<span class="built_in">std</span>::make_pair(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    combination_relations_[<span class="number">0</span>].push_back(<span class="built_in">std</span>::make_pair(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">    combination_relations_[<span class="number">0</span>].push_back(<span class="built_in">std</span>::make_pair(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">    combination_relations_[<span class="number">1</span>].push_back(<span class="built_in">std</span>::make_pair(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    combination_relations_[<span class="number">1</span>].push_back(<span class="built_in">std</span>::make_pair(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    combination_relations_[<span class="number">1</span>].push_back(<span class="built_in">std</span>::make_pair(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">    combination_relations_[<span class="number">2</span>].push_back(<span class="built_in">std</span>::make_pair(<span class="number">2</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    probability_vec_.<span class="built_in">clear</span>();</span><br><span class="line">    probability_vec_.resize(bba_vec_.<span class="built_in">size</span>(), <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;combination_relations = combination_relations_; <span class="comment">//存储两个subset的交集索引编号和该两个subset的编号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; &amp;fod_subset_cardinalities =</span><br><span class="line">            fod_subset_cardinalities_; <span class="comment">//存储各个subset对应的二进制值中1的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; combination_relations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;combination_pairs = combination_relations[i];<span class="comment">//交集为各个subset的pair</span></span><br><span class="line">        <span class="keyword">double</span> intersection_card = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(fod_subset_cardinalities[i]); <span class="comment">//该subset对应的位数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> combination_pair : combination_pairs) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> a_ind = combination_pair.first;</span><br><span class="line">            <span class="keyword">size_t</span> b_ind = combination_pair.second;</span><br><span class="line">            probability_vec_[a_ind] +=</span><br><span class="line">                    intersection_card /</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(fod_subset_cardinalities[b_ind]) *</span><br><span class="line">                    bba_vec_[b_ind];<span class="comment">//根据交集的位数占后者的位数的比例确定所占概率比例的大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@ result：</span></span><br><span class="line">probability_vev_=&#123;<span class="number">0.85</span>,<span class="number">0.15</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">//@ note: bba_vec_=&#123;0.7,0,0.3&#125;</span></span><br><span class="line"><span class="comment">//@ 理解为此处的EXIST，NEXIST均与EXISTUNKOWN有交集，因此根据bba_vec按照交集位数的比例比如NEXIST与EXISTUNKOWN的二进制位数为1的比例为 1/2=0.5，因此其概率为0.3*0.5=0.15,而EXIST为0.7(自身概率)+0.3*0.5=0.85</span></span><br></pre></td></tr></table></figure><p>更新概率： 通过重构运算符加法和乘法，进行概率融合，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Dst <span class="keyword">operator</span>*(<span class="keyword">const</span> Dst &amp;dst, <span class="keyword">double</span> w) &#123;</span><br><span class="line">  dst.SelfCheck();</span><br><span class="line">  <span class="function">Dst <span class="title">res</span><span class="params">(dst.app_name_)</span></span>;</span><br><span class="line">  <span class="comment">// check w</span></span><br><span class="line">  <span class="keyword">if</span> (w &lt; <span class="number">0.0</span> || w &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    AERROR &lt;&lt; boost::format(</span><br><span class="line">                  <span class="string">"the weight of bba %lf is not valid, return default bba"</span>) %</span><br><span class="line">                  w;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">size_t</span> fod_loc = dst.dst_data_ptr_-&gt;fod_loc_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;resbba_vec_ = res.bba_vec_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;bba_vec = dst.bba_vec_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; resbba_vec_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == fod_loc) &#123;</span><br><span class="line">      resbba_vec_[i] = <span class="number">1.0</span> - w + w * bba_vec[i]; <span class="comment">//???</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resbba_vec_[i] = w * bba_vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dsttypefusion">3.2 DstTypeFusion</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DstMaps</span> &#123;</span></span><br><span class="line">  <span class="comment">// dst hypothesis types</span></span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    PEDESTRIAN = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>), <span class="comment">//1      0000 0001</span></span><br><span class="line">    BICYCLE = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>), <span class="comment">//2         0000 0010</span></span><br><span class="line">    VEHICLE = (<span class="number">1</span> &lt;&lt; <span class="number">2</span>), <span class="comment">//4         0000 0100</span></span><br><span class="line">    OTHERS_MOVABLE = (<span class="number">1</span> &lt;&lt; <span class="number">3</span>), <span class="comment">//8  0000 1000</span></span><br><span class="line">    OTHERS_UNMOVABLE = (<span class="number">1</span> &lt;&lt; <span class="number">4</span>)<span class="comment">//16 0001 0000   </span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    OTHERS = (OTHERS_MOVABLE | OTHERS_UNMOVABLE), <span class="comment">//24 0001 1000</span></span><br><span class="line">    UNKNOWN = (PEDESTRIAN | BICYCLE | VEHICLE | OTHERS) <span class="comment">//31 0001 1111</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; fod_subsets_ = &#123;</span><br><span class="line">      PEDESTRIAN,       BICYCLE, VEHICLE, OTHERS_MOVABLE,</span><br><span class="line">      OTHERS_UNMOVABLE, OTHERS,  UNKNOWN&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; subset_names_ = &#123;</span><br><span class="line">      <span class="string">"PEDESTRIAN"</span>,       <span class="string">"BICYCLE"</span>, <span class="string">"VEHICLE"</span>, <span class="string">"OTHERS_MOVABLE"</span>,</span><br><span class="line">      <span class="string">"OTHERS_UNMOVABLE"</span>, <span class="string">"OTHERS"</span>,  <span class="string">"UNKNOWN"</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span>, <span class="keyword">uint64_t</span>&gt; typ_to_hyp_map_ = &#123;</span><br><span class="line">      &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::PEDESTRIAN), PEDESTRIAN&#125;,</span><br><span class="line">      &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::BICYCLE), BICYCLE&#125;,</span><br><span class="line">      &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::VEHICLE), VEHICLE&#125;,</span><br><span class="line">      &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::UNKNOWN_MOVABLE), OTHERS_MOVABLE&#125;,</span><br><span class="line">      &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::UNKNOWN_UNMOVABLE),</span><br><span class="line">       OTHERS_UNMOVABLE&#125;,</span><br><span class="line">      &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::UNKNOWN), OTHERS&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint64_t</span>, <span class="keyword">size_t</span>&gt; hyp_to_typ_map_ = &#123;</span><br><span class="line">      &#123;PEDESTRIAN, <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::PEDESTRIAN)&#125;,</span><br><span class="line">      &#123;BICYCLE, <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::BICYCLE)&#125;,</span><br><span class="line">      &#123;VEHICLE, <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::VEHICLE)&#125;,</span><br><span class="line">      &#123;OTHERS_MOVABLE, <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::UNKNOWN_MOVABLE)&#125;,</span><br><span class="line">      &#123;OTHERS_UNMOVABLE,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::UNKNOWN_UNMOVABLE)&#125;,</span><br><span class="line">      &#123;OTHERS, <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::UNKNOWN)&#125;,</span><br><span class="line">      &#123;UNKNOWN, <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(base::ObjectType::UNKNOWN)&#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="kalmanmoitonfusion">3.3 KalmanMoitonFusion</h5><h5 id="pbfshapefusion">3.4 PbfShapeFusion</h5><h4 id="自适应卡尔曼滤波">4. 自适应卡尔曼滤波</h4>]]></content>
      
      
      <categories>
          
          <category> fusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多传感器融合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo lidar驱动组件</title>
      <link href="/2020/04/24/apollo-lidar_driver/"/>
      <url>/2020/04/24/apollo-lidar_driver/</url>
      
        <content type="html"><![CDATA[<p>Lidar的驱动程序组件</p><a id="more"></a><p>先搬运一下官方的velodyne驱动组件[说明文档][https://github.com/ApolloAuto/apollo/blob/master/modules/drivers/velodyne/README_cn.md],激光雷达的驱动主要包含了四个组件：</p><ul><li><p>数据读取打包 --&gt;/driver (输出数据包) channel: /apollo/sensor/lidar128/Scan type：apollo::drivers::velodyne::VelodyneScan</p><p>proto: <a href="https://github.com/ApolloAuto/apollo/blob/master/modules/drivers/velodyne/proto/velodyne.proto" target="_blank" rel="noopener">modules/drivers/velodyne/proto/velodyne.proto</a></p></li><li><p>生成点云 --&gt; /convert</p><p>channel: /apollo/sensor/lidar128/PointCloud2 type: apollo::drivers::PointCloud proto:[modules/drivers/proto/pointcloud.proto][https://github.com/ApolloAuto/apollo/blob/master/modules/drivers/proto/pointcloud.proto]</p></li><li><p>点云融合 --&gt; /fusion 点云融合主要将多个激光雷达数据融合成一张点云</p></li><li><p>运动补偿 --&gt; /compensator 运动补偿依赖<code>tf</code>来进行坐标转换查询，因此需要和<code>gnss_driver</code>一起运行才能正常工作 channel: /apollo/sensor/lidar128/copensator/PointCloud2 type : apollo::drivers::PointCloud proto: [modules/drivers/proto/pointcloud.proto][https://github.com/ApolloAuto/apollo/blob/master/modules/drivers/proto/pointcloud.proto]</p></li></ul><p>启动<code>velodyne</code>驱动： <strong>需要先修改并确认launch文件中的参数与实际车辆相对应</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># in docker</span></span><br><span class="line">cd /apollo &amp;&amp; cyber_launch start modules/drivers/velodyne/launch/velodyne.launch</span><br></pre></td></tr></table></figure><p>实际根据感知5.0的[说明文档][https://github.com/ApolloAuto/apollo/blob/master/modules/perception/README.md]，Lidar的输出数据包括：</p><ul><li>128 线Lidar数据，(cyber channel : /apollo/sensor/velodyne128)</li><li>16 线Lidar数据 ，(cyber channel: /apollo/sensor/lidar_front ,lidar_rear_left,lidar_rear_right)</li></ul><p>下面简单介绍驱动部分四个组件的处理：</p><h2 id="drivervelodyne_driver_component">driver(velodyne_driver_component)</h2><p>BUILD文件 组件编译为动态链接库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cc_binary(</span><br><span class="line">    name = <span class="string">"libvelodyne_driver_component.so"</span>,</span><br><span class="line">    linkopts = [<span class="string">"-shared"</span>],</span><br><span class="line">    linkstatic = <span class="keyword">False</span>,</span><br><span class="line">    deps = [<span class="string">":velodyne_driver_component_lib"</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对应组件的dag文件（<code>modules/drivers/velodyne/dag/velodyne.dag</code>）中的Driver部分：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module_config &#123;</span><br><span class="line">    module_library : <span class="string">"/apollo/bazel-bin/modules/drivers/velodyne/driver/libvelodyne_driver_component.so"</span></span><br><span class="line"></span><br><span class="line">    # <span class="number">128</span></span><br><span class="line">    components &#123;</span><br><span class="line">      class_name : <span class="string">"VelodyneDriverComponent"</span></span><br><span class="line">      config &#123;</span><br><span class="line">        name : <span class="string">"velodyne_128_driver"</span></span><br><span class="line">        config_file_path : <span class="string">"/apollo/modules/drivers/velodyne/conf/velodyne128_conf.pb.txt"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # <span class="number">16</span>_front_up</span><br><span class="line">    components &#123;</span><br><span class="line">      class_name : <span class="string">"VelodyneDriverComponent"</span></span><br><span class="line">      config &#123;</span><br><span class="line">        name : <span class="string">"velodyne_16_front_up_driver"</span></span><br><span class="line">        config_file_path : <span class="string">"/apollo/modules/drivers/velodyne/conf/velodyne16_front_up_conf.pb.txt"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # <span class="number">16</span>_front_center</span><br><span class="line">    components &#123;</span><br><span class="line">      class_name : <span class="string">"VelodyneDriverComponent"</span></span><br><span class="line">      config &#123;</span><br><span class="line">        name : <span class="string">"velodyne_16_front_center_driver"</span></span><br><span class="line">        config_file_path : <span class="string">"/apollo/modules/drivers/velodyne/conf/velodyne16_front_center_conf.pb.txt"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # <span class="number">16</span>_rear_left</span><br><span class="line">    components &#123;</span><br><span class="line">      class_name : <span class="string">"VelodyneDriverComponent"</span></span><br><span class="line">      config &#123;</span><br><span class="line">        name : <span class="string">"velodyne_16_rear_left_driver"</span></span><br><span class="line">        config_file_path : <span class="string">"/apollo/modules/drivers/velodyne/conf/velodyne16_rear_left_conf.pb.txt"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # <span class="number">16</span>_rear_right</span><br><span class="line">    components &#123;</span><br><span class="line">      class_name : <span class="string">"VelodyneDriverComponent"</span></span><br><span class="line">      config &#123;</span><br><span class="line">        name : <span class="string">"velodyne_16_rear_right_driver"</span></span><br><span class="line">        config_file_path : <span class="string">"/apollo/modules/drivers/velodyne/conf/velodyne16_rear_right_conf.pb.txt"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面以128线激光雷达为例，对应的配置文件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">frame_id: <span class="string">"velodyne128"</span></span><br><span class="line">scan_channel: <span class="string">"/apollo/sensor/lidar128/Scan"</span></span><br><span class="line">rpm: <span class="number">600.0</span></span><br><span class="line">model: VLS128</span><br><span class="line">mode: STRONGEST</span><br><span class="line">prefix_angle: <span class="number">18000</span></span><br><span class="line">firing_data_port: <span class="number">2368</span>  <span class="comment">//velodyne socket 端口</span></span><br><span class="line">positioning_data_port: <span class="number">8308</span> <span class="comment">//定位数据 socket端口</span></span><br><span class="line">use_sensor_sync: <span class="literal">false</span></span><br><span class="line">max_range: <span class="number">100.0</span></span><br><span class="line">min_range: <span class="number">0.9</span></span><br><span class="line">use_gps_time: <span class="literal">true</span></span><br><span class="line">calibration_online: <span class="literal">false</span></span><br><span class="line">calibration_file: <span class="string">"/apollo/modules/drivers/velodyne/params/velodyne128_VLS_calibration.yaml"</span></span><br><span class="line">organized: <span class="literal">false</span></span><br><span class="line">convert_channel_name: <span class="string">"/apollo/sensor/lidar128/PointCloud2"</span></span><br><span class="line">use_poll_sync: <span class="literal">true</span></span><br><span class="line">is_main_frame: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="程序">程序：</h3><ul><li><p>VelodyneDriverComponent::Init() 加载配置文件：<code>velodyne128_conf.pb.txt -&gt; proto:/modules/drivers/velodyne/proto/config.proto</code> 创建节点：type:<code>&lt;VelodyneScan&gt;</code> name:<code>&quot;/apollo/sensor/lidar128/Scan&quot;</code> ,proto:<code>./velodyne/proto/velodyne.proto</code> 根据配置文件<code>model</code>参数通过<code>VelodyneDriverFactory::CreateDriver</code>创建对应的驱动类<code>VelodyneDriver</code> 激光雷达的驱动类<code>VelodyneDriver</code>包含了两个主要的接口：</p><ul><li><p><code>Init()</code></p><ul><li><p><code>SocketInput::init(const int &amp;port)</code> 连接Velodyne UDP接口</p></li><li><p>创建<code>PollPositioningPacket</code>包接收线程,(以Gps的时间为基准)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// raw data output topic</span></span><br><span class="line">positioning_thread_ =</span><br><span class="line">    <span class="built_in">std</span>::thread(&amp;VelodyneDriver::PollPositioningPacket, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Poll(std::shared_ptr&lt;VelodyneScan&gt; scan)</code></p></li></ul><p>开启设备线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">device_thread_ = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::thread&gt;(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">std</span>::thread(<span class="built_in">std</span>::bind(&amp;VelodyneDriverComponent::device_poll, <span class="keyword">this</span>)));</span><br><span class="line">device_thread_-&gt;<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure></li><li>VelodyneDriverComponent::device_poll() 在线程中，循环执行该函数拉取Lidar数据<ul><li><code>VelodyneDriver::Poll(const std::shared_ptr&lt;VelodyneScan&gt;&amp; scan)</code></li><li><code>writer-&gt;Write(scan)</code> 点云数据发布通道<code>/apollo/sensor/lidar128/Scan</code></li></ul></li></ul><hr><p>##　convert(velodyne_convert_component)</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module_config &#123;</span><br><span class="line">    module_library : <span class="string">"/apollo/bazel-bin/modules/drivers/velodyne/parser/libvelodyne_convert_component.so"</span></span><br><span class="line"></span><br><span class="line">    components &#123;</span><br><span class="line">      class_name : <span class="string">"VelodyneConvertComponent"</span></span><br><span class="line">      config &#123;</span><br><span class="line">        name : <span class="string">"velodyne_convert"</span></span><br><span class="line">        config_file_path : <span class="string">"/apollo/modules/drivers/velodyne/conf/velodyne128_conf.pb.txt"</span></span><br><span class="line">        readers &#123;channel: <span class="string">"/apollo/sensor/lidar128/Scan"</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受<code>driver</code>组件发布的原始Velodyne数据，在该组件中转换为点云结构数据。</p><h3 id="初始化">初始化：</h3><p>创建Convert类对象(根据不同的lidar模型创建<code>VelodyneParser</code> 和Writer对象(对象类型:<code>&lt;PointCloud&gt;</code>,发布通道：<code>//apollo/sensor/lidar128/PointCloud2</code>) 创建<code>PointCloud</code>对象池(大小为8) <code>CCObjectPool&lt;PointCloud&gt; point_cloud_pool_</code> 并将对象池中的 PointCloud对象中的点数设置为140000</p><h3 id="处理函数">处理函数：</h3><p>接收<code>&quot;/apollo/sensor/lidar128/Scan&quot;</code>通道的原始Velodyne数据</p><p><strong>Convert::ConvertPacketsToPointCloud(scan_msg, point_cloud_out)</strong></p><ul><li><p><code>Velodyne128Parser::GeneratePointcloud(scan_msg, point_cloud)</code> 该函数接收Scan_msg返回点云数据格式的point_cloud。</p><ul><li><p><code>Velodyne128Parser::Unpack(scan_msg-&gt;firing_pkts(i), out_msg)</code> 循环读取<code>scan_msg</code>所有的原始数据信息，通过该函数进行解析，每个packet有12个blocks，根据数据协议可以得到激光点的水平角度值（azimuth）,然后每个block有32个channel，结合校正文件，进一步得到每一个点的距离(distance)</p><ul><li><p><code>is_scan_valid(azimuth,distance)</code> 根据距离判断点是否有效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (range &lt; config_.min_range() || range &gt; config_.max_range()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="comment">//该函数目测貌似没啥用</span></span><br></pre></td></tr></table></figure></li></ul><p>然后获取点的强度<code>intensity</code>, 这样由水平角度，垂直角度(在标定文件中)，距离三个信息可以换算得到三维直角坐标系中的点云坐标</p><ul><li><p><code>ComputeCoords(real_distance, corrections, azimuth_corrected, point_new);</code> 三维点云坐标以ROS右手坐标系为基准建立。</p></li><li><p><code>Velodyne128Parser::IntensityCompensate()</code></p><p>对反射强度进行补偿，根据标定文件中的<code>focal_distace</code>,<code>focal_slope</code> 。</p></li></ul></li></ul></li><li><p><code>writer_-&gt;Write(point_cloud_out)</code> 输出<code>&lt;PointCloud&gt;</code>格式的数据，发布通道为： <code>/apollo/sensor/lidar128/PointCloud2</code></p></li></ul><hr><h2 id="prisecfusioncomponent">PrisecFusionComponent()</h2><p><strong>以16线front center为基准融合rear left ,rear right的点云数据</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#dag组件配置</span><br><span class="line">module_config &#123;</span><br><span class="line">    module_library : <span class="string">"/apollo/bazel-bin/modules/drivers/velodyne/fusion/libvelodyne_fusion_component.so"</span></span><br><span class="line"></span><br><span class="line">    components &#123;</span><br><span class="line">      class_name : <span class="string">"PriSecFusionComponent"</span></span><br><span class="line">      config &#123;</span><br><span class="line">        name : <span class="string">"velodyne_fusion"</span></span><br><span class="line">        config_file_path : <span class="string">"/apollo/modules/drivers/velodyne/conf/velodyne_fusion_conf.pb.txt"</span></span><br><span class="line">        readers &#123;channel: <span class="string">"/apollo/sensor/lidar16/front/center/PointCloud2"</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Component参数：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># velodyne_fusion_conf.pb.txt</span><br><span class="line">max_interval_ms: <span class="number">50</span></span><br><span class="line">drop_expired_data : <span class="literal">true</span></span><br><span class="line">fusion_channel: <span class="string">"/apollo/sensor/lidar16/fusion/PointCloud2"</span></span><br><span class="line">input_channel: [</span><br><span class="line">    <span class="string">"/apollo/sensor/lidar16/rear/left/PointCloud2"</span>,</span><br><span class="line">    <span class="string">"/apollo/sensor/lidar16/rear/right/PointCloud2"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># wait time after main channel receive msg, unit second</span><br><span class="line">wait_time_s: <span class="number">0.02</span></span><br></pre></td></tr></table></figure><p><strong>初始化Init()</strong></p><ul><li><p><strong>Init</strong></p><ul><li><p>创建transform::Buffer实例，用于查询坐标转换信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer_ptr_ = apollo::transform::Buffer::Instance();</span><br></pre></td></tr></table></figure></li><li><p>创建节点writer，用于发布点云融合数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fusion_writer_ = node_-&gt;CreateWriter&lt;PointCloud&gt;(conf_.fusion_channel());</span><br></pre></td></tr></table></figure></li><li><p>创建节点reader,用于监听另外两个16线雷达的数据信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; channel : conf_.input_channel()) &#123;</span><br><span class="line">  <span class="keyword">auto</span> reader = node_-&gt;CreateReader&lt;PointCloud&gt;(channel);</span><br><span class="line">  readers_.emplace_back(reader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主通道数据通过组件Proc接收<code>front_center</code>位置的16线雷达数据，通过Proc处理。</p></li></ul></li><li><p><strong>Proc</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PriSecFusionComponent::Proc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PointCloud&gt;&amp; point_cloud)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> target = point_cloud;</span><br><span class="line">  <span class="keyword">auto</span> fusion_readers = readers_;</span><br><span class="line">  <span class="keyword">auto</span> start_time = Time::Now().ToSecond();</span><br><span class="line">  <span class="keyword">while</span> ((Time::Now().ToSecond() - start_time) &lt; conf_.wait_time_s() &amp;&amp;</span><br><span class="line">         fusion_readers.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = fusion_readers.<span class="built_in">begin</span>(); itr != fusion_readers.<span class="built_in">end</span>();) &#123;</span><br><span class="line">      (*itr)-&gt;Observe(); <span class="comment">//注意此处的reader并不通过回调函数读取数据，而是通过Observe()</span></span><br><span class="line">      <span class="keyword">if</span> (!(*itr)-&gt;Empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> source = (*itr)-&gt;GetLatestObserved();</span><br><span class="line">        <span class="keyword">if</span> (conf_.drop_expired_data() &amp;&amp; IsExpired(target, source)) &#123;</span><br><span class="line">          ++itr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Fusion(target, source);</span><br><span class="line">          itr = fusion_readers.erase(itr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++itr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    usleep(USLEEP_INTERVAL);<span class="comment">//5000us</span></span><br><span class="line">  &#125;</span><br><span class="line">  fusion_writer_-&gt;Write(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主通道接收到点云数据后，在0.02s内等待接收readers的消息。注意此处readers并不由回调函数调用，而是直接通过 <code>reader-&gt;Observe()</code>和<code>reader-&gt;GetLatestObserved()</code>获取数据。</p><ul><li><p><code>IsExpired(target,source)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 判断通过Observe得到的两个Lidar数据是否过期</span></span><br><span class="line"><span class="comment">// @param: target 主通道接收到的点云数据(front center)</span></span><br><span class="line"><span class="comment">// @param: source 另外两个lidar通过observe获取得到的最新数据(rear left or rear right)</span></span><br><span class="line"><span class="comment">// 根据lidar数据保重measurement_time的相隔时间不大于50ms</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PriSecFusionComponent::IsExpired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PointCloud&gt;&amp; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PointCloud&gt;&amp; source)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>Fusion(target, source)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 没有source 相较于target没有过期的话，则对当前帧点云数据进行融合</span></span><br><span class="line"><span class="comment">// @param: target 主通道接收到的点云数据(front center)</span></span><br><span class="line"><span class="comment">// @param: source 另外两个lidar通过observe获取得到的最新数据(rear left or rear right)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PriSecFusionComponent::Fusion</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PointCloud&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PointCloud&gt; source)</span></span></span><br></pre></td></tr></table></figure><ul><li><p><code>QueryPoseAffine(target-&gt;header().frame_id(), source-&gt;header().frame_id(),&amp;pose</code>)`</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 通过transform::buffer查询source-&gt;target的坐标转换矩阵</span></span><br><span class="line"><span class="comment">// @param[in]: target_frame_id, source_frame_id</span></span><br><span class="line"><span class="comment">// @param[out]: pose 转换矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PriSecFusionComponent::QueryPoseAffine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; target_frame_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; source_frame_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            Eigen::Affine3d* pose)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>AppendPointCloud(target, source, pose)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @bried: 利用坐标转换将source lidar注册到 target lidar的位置中</span></span><br><span class="line"><span class="comment">// @param[in/out]: point_cloud 主雷达数据(基准)</span></span><br><span class="line"><span class="comment">// @param[in]: point_cloud_add 补充的雷达数据</span></span><br><span class="line"><span class="comment">// @param[in]: pose: 坐标变换矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PriSecFusionComponent::AppendPointCloud</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PointCloud&gt; point_cloud,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PointCloud&gt; point_cloud_add, <span class="keyword">const</span> Eigen::Affine3d&amp; pose)</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>fusion_writer_-&gt;Write(target);</code>将融合后的front_center lidar数据通过通道 <code>/apollo/sensor/lidar16/fusion/PointCloud2</code>发布。</p></li></ul></li></ul><hr><h2 id="compensatorcomponent">CompensatorComponent()</h2><p><strong>对之前融合的16线fusion/Pointcloud和front up lidar, lidar128这三个通道的雷达数据进行补偿</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 以velydone <span class="number">128</span>线激光雷达为例</span><br><span class="line">module_config &#123;</span><br><span class="line">    module_library : <span class="string">"/apollo/bazel-bin/modules/drivers/velodyne/compensator/libvelodyne_compensator_component.so"</span></span><br><span class="line"></span><br><span class="line">    components &#123;</span><br><span class="line">      class_name : <span class="string">"CompensatorComponent"</span></span><br><span class="line">      <span class="built_in">config</span> &#123;</span><br><span class="line">        name : <span class="string">"velodyne128_compensator"</span></span><br><span class="line">        config_file_path : <span class="string">"/apollo/modules/drivers/velodyne/conf/velodyne128_fusion_compensator.pb.txt"</span></span><br><span class="line">        readers &#123;channel: <span class="string">"/apollo/sensor/lidar128/PointCloud2"</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Component参数：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># modules/drivers/velodyne/conf/velodyne128_fusion_compensator.pb.txt</span><br><span class="line">world_frame_id: <span class="string">"world"</span></span><br><span class="line">transform_query_timeout: <span class="number">0.02</span></span><br><span class="line">output_channel: <span class="string">"/apollo/sensor/lidar128/compensator/PointCloud2"</span></span><br></pre></td></tr></table></figure><p><strong>初始化Init()</strong></p><ul><li><p><strong>Init()</strong></p><ul><li><p>创建writer输出通道,发布补偿后的lidar点云数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer_ = node_-&gt;CreateWriter&lt;PointCloud&gt;(<span class="built_in">config</span>.output_channel());</span><br></pre></td></tr></table></figure></li><li><p>根据配置文件参数创建该组件的功能实现类<code>&lt;Compensator&gt;</code> ,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compensator_.reset(<span class="keyword">new</span> Compensator(<span class="built_in">config</span>));</span><br></pre></td></tr></table></figure></li><li><p>并创建点云数据类型的对象池(大小为8)(<strong>貌似对点云数据直接处理的都会先创建对象池</strong>),并为创建的点云类型预先分配14000个点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compensator_pool_.reset(<span class="keyword">new</span> CCObjectPool&lt;PointCloud&gt;(pool_size_));</span><br><span class="line">compensator_pool_-&gt;ConstructAll();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Proc()</strong> 从对象池中获取点云数据结构类型point_cloud_compensated</p><ul><li><p><code>Compensator::MotionCompensation(point_cloud, point_cloud_compensated)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@brief: 进行点云运动补偿的入口函数</span></span><br><span class="line"><span class="comment">//@param[in]: msg 接收到的原始点云数据</span></span><br><span class="line"><span class="comment">//@param[out]: msg_compensated 补偿后的点云数据</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compensator::MotionCompensation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> PointCloud&gt;&amp; msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PointCloud&gt; msg_compensated)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>GetTimestampInterval(msg, &amp;timestamp_min, &amp;timestamp_max)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@brief： 由接收到的点云数据计算时间间隔</span></span><br><span class="line"><span class="comment">//@param[out]: timestamp_min 该数据帧中点云中单个点的时间戳最小值</span></span><br><span class="line"><span class="comment">//@param[out]: timestamp_max ... 最大值</span></span><br><span class="line"><span class="comment">//@param[in]: 当前帧接收到的点云数据</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Compensator::GetTimestampInterval</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> PointCloud&gt;&amp; msg, <span class="keyword">uint64_t</span>* timestamp_min,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint64_t</span>* timestamp_max)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置运动补偿点云point_cloud_compensated的时间戳信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msg_compensated-&gt;mutable_header()-&gt;set_timestamp_sec(</span><br><span class="line">    cyber::Time::Now().ToSecond()); <span class="comment">//该时间戳为消息发布时刻</span></span><br><span class="line">msg_compensated-&gt;mutable_header()-&gt;set_frame_id(msg-&gt;header().frame_id());</span><br><span class="line">msg_compensated-&gt;mutable_header()-&gt;set_lidar_timestamp(</span><br><span class="line">    msg-&gt;header().lidar_timestamp()); <span class="comment">//该消息类型对应需要的lidar数据时刻</span></span><br><span class="line">msg_compensated-&gt;set_measurement_time(msg-&gt;measurement_time()); <span class="comment">//lidar数据获取时的时间</span></span><br><span class="line">msg_compensated-&gt;set_height(msg-&gt;<span class="built_in">height</span>());</span><br><span class="line">msg_compensated-&gt;set_is_dense(msg-&gt;is_dense());</span><br></pre></td></tr></table></figure></li><li><p>补偿点云，移除nan的点：</p><ul><li><p><code>QueryPoseAffineFromTF2(timestamp_min, &amp;pose_min_time, frame_id)</code><br>注： pose_max_time同样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@brief: 通过tf buffer获取timestamp时刻原始点云数据到世界坐标系的转换矩阵</span></span><br><span class="line"><span class="comment">//@param[in]: timestamp:时间戳（对应之前得到的该帧点云中最早检测点和最晚检测点的时刻）</span></span><br><span class="line"><span class="comment">//@param[in]: child_frame_id: 接收到的点云数据对应的传感器id</span></span><br><span class="line"><span class="comment">//@param[in/out]: pose </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compensator::QueryPoseAffineFromTF2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint64_t</span>&amp; timestamp, <span class="keyword">void</span>* pose,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; child_frame_id)</span></span></span><br></pre></td></tr></table></figure><p>通过上述函数就获得了该帧头尾两个时刻到世界坐标系的转换矩阵。</p></li><li><p><code>MotionCompensation(msg, msg_compensated, timestamp_min, timestamp_max,            pose_min_time, pose_max_time)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@brief: 主要处理函数，</span></span><br><span class="line"><span class="comment">//@param[in]: msg（原始接收到的lidar数据）,</span></span><br><span class="line"><span class="comment">//@param[in]: timestamp_min，timestamp_max 该帧数据头尾两个点的时刻</span></span><br><span class="line"><span class="comment">//@param[in]: pose_min_time,pose_max_time 对应头尾两个时刻到世界坐标系的转换矩阵</span></span><br><span class="line"><span class="comment">//@param[in/out]: msg_compensated 输出补偿后的点云数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compensator::MotionCompensation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> PointCloud&gt;&amp; msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PointCloud&gt; msg_compensated, <span class="keyword">const</span> <span class="keyword">uint64_t</span> timestamp_min,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> timestamp_max, <span class="keyword">const</span> Eigen::Affine3d&amp; pose_min_time,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Eigen::Affine3d&amp; pose_max_time)</span></span></span><br></pre></td></tr></table></figure><p>通过该帧头和尾时刻的世界坐标系的坐标可得到lidar在该帧的时间段内在世界坐标系下相对转动和平移，可以通过线性插值得到中间点近似的旋转和平移。由于lidar的测距精度为~2cm,当距离超过70m，此时角度应小于0.02/70=0.0003rad，认为此时的相对角度是有意义的。</p></li></ul><blockquote><p>由于lidar各个激光束的依次发射需要时间，因此在这段时间里，可能车辆发生了位移，导致该真点云并不是严格在同一位置检测得到的，因此需要补偿该帧各个点的位置。</p></blockquote></li></ul></li><li><p><code>writer_-&gt;Write(point_cloud_compensated);</code>通过通道<code>/apollo/sensor/lidar128/compensator/PointCloud2</code>发布补偿后的点云数据。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> lidar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo lidar算法--recognition component</title>
      <link href="/2020/04/24/apollo-lidar_recognition/"/>
      <url>/2020/04/24/apollo-lidar_recognition/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="配置文件">配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lidar目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multi-View 3D Object Detection Network for Autonomous Driving</title>
      <link href="/2020/04/24/pr_MV3D/"/>
      <url>/2020/04/24/pr_MV3D/</url>
      
        <content type="html"><![CDATA[<p>论文阅读：自动驾驶场景下的3D障碍物检测网络</p><a id="more"></a><h3 id="d-目标检测回顾">3D 目标检测回顾</h3><ul><li><p>点云3D目标检测 <strong>voxel grid representation</strong> 3D convolution: &lt;3D Fully Convolutional Network for Vehicle Detection in Point Cloud&gt; 3D卷积的计算代价很大</p><p><strong>multi-view representation</strong> &lt;Volumetric and multi-view cnns for object classification on 3d data.&gt;</p></li><li><p>图像3D目标检测 &lt;Monocular 3d object detection for autonomous driving.&gt; 从单目图像中生成3D proposal 还有结合运动和地平面结构信息，将2D Box迁移到3D Box &lt;A continuous occlusion model for road scene understanding.&gt; &lt;Joint sfm and detection cues for monocular 3d localization in road scenes.&gt; 基于图像的方法通常依赖于准确的深度估计和标志物检测。</p></li><li><p>多模态融合的3D目标检测 &lt;Onboard object detection: Multicue, multimodal, and multiview random forest of local experts&gt;综合了图像，深度，光流进行2D行人检测。</p></li></ul><p>目前使用多种数据融合进行检测的文章还不是很多，MV3D受分型网络FractalNet和Deeply-Fused Net网络启发，其中 FractalNet迭代重复基础模型构造网络，Deeply-Fused Net类似通过结合深、浅基网络实现基网络之间的深度融合。</p><ul><li>3D object proposal 类似于2D object proposal ,3D目标提议方法生成 包含大多数目标的3D候选框子集，由于3D卷积计算代价比较大，文中使用的方法是在鸟瞰图(bird view)上使用2D卷积生成正确的3D Proposal.</li></ul><h3 id="mv3d-net">MV3D net</h3><p>MV3D采用了3D点云图的多视角特征和2D图像作为输入。首先根据点云bird view生成了3D object proposal，然后由此根据提议在局部区域上对多视角特征进行深度融合。融合的特征用于分类和oriented 3D box回归。</p><ul><li><p>点云的表示形式 <img src="/2020/04/24/pr_MV3D/image-20200412211428658.png" alt="image-20200412211428658"></p><p>其中bird view 通过点云的高度，密度，强度表示。以0.1m为分辨率建立离散化网格，每个网格的高度由该网格中最高的点表示，为了编码更多的高度特征，点云被平均分成了M片。强度特征为对应高度图中点的反射强度，密度特征为每个cell中点的个数，为了归一化该特征，通过<span class="math inline">\(min(1.0,\frac{log(N+1)}{log(64)})\)</span> 其中N为该Cell中点的个数。整个bird view产生的特征通道的个数为(M+2)个。 front view 相当于Bird view提供了互补的特征，因为Lidar点云非常稀疏，将其投影到图像平面将会得到稀疏的2D点，因此，文中将点映射到了柱面（而不是图像平面）以得到一个相对密集的2d点云图。给定一个3d点<span class="math inline">\(p=(x,y,z)\)</span> 在前视图中的坐标为<span class="math inline">\(p_{fv}=(r,c)\)</span> 通过下列方式计算： (参考论文Vehicle Detection from 3D Lidar Using Fully Convolutional Network) <span class="math display">\[c=\lfloor atan2(y,x)/\Delta\theta\rfloor \\r = \lfloor atan2(z,\sqrt{x^2+y^2}/\Delta\phi \rfloor)\]</span> 其中<span class="math inline">\(\Delta\theta\)</span>和<span class="math inline">\(\Delta\phi\)</span>分别是水平和垂直方向laser分辨率，将前视图编码为三通道特征图。</p></li><li><p>3D proposal Network 通过鸟瞰图来进行3D proposal有以下几个优点： 保留了原始的物体尺寸，其次鸟瞰图中的物体占据了不同的空间，因此避免了相互之间的遮挡问题，最后，在道路场景中由于物体基本都位于地平面上，因此在垂直方向上位移很小，因此鸟瞰图对于获取准确的3D object proposal至关重要并且是可行的。 给定鸟瞰图，网络生成3D box proposal从一组3D先验框（anchor）中,每一个box通过<span class="math inline">\((x,y,z,l,w,h)\)</span>进行参数化（雷达坐标系下的中心和尺寸(m)）,对于每一个3D先验框，相对应的鸟瞰图的anchor<span class="math inline">\((x_{bv},y_{bv},l_{bv},w_{bv})\)</span> 通过离散化 <span class="math inline">\((x,y,l,w)\)</span>来获取，通过在训练集的object size上进行聚类，设计了N个3D 先验框。在车辆检测中，先验框<span class="math inline">\(（l,w）\)</span>大小设置为<span class="math inline">\(\{(3.9,1.6),(1.0,0.6)\}\)</span> 高度设置为1.56m,通过旋转鸟瞰图90°可以得到N=4个先验框。 注意，在proposal生成阶段，不进行物体朝向的判断。</p><p>由于离散化过程中分辨率设置为0.1m，则物体的边界框在鸟瞰图中可能仅有5~40个点，对于极小目标的检测是比较困难的，采用该[文章][https://github.com/zhaoweicai/mscnn]中的方法，在最后proposal layer的最后卷积层中进行2x 上采样。</p><p>proposal 回归<span class="math inline">\(t=(\Delta x,\Delta y,\Delta z,\Delta l,\Delta w,\Delta h)\)</span> ,这一部分与RPN类似，<span class="math inline">\(（\Delta x,\Delta y,\Delta z）\)</span>是由anchor尺寸归一化的值，而<span class="math inline">\((\Delta l,\Delta w,\Delta h)\)</span>则是通过<span class="math inline">\(log\frac{gt(s)}{anchor(s)},s\in(l,w,h)\)</span>计算，损失函数计算：分类采用类别交叉熵，位置采用<span class="math inline">\(smooth \ l_1\)</span> 训练过程中，通过计算anchor与ground truth的IOU来确定anchor的类别标签(大于0.7认为positive，小于0.5认为是negative,中间的被忽略，这部分基本与RPN一致)。由于点云是稀疏的，因此存在大量的空anchor，在训练和测试过程中去除，以减少计算量。</p><p>最后采用NMS(0.7)去除冗余，前2000个boxes在训练过程中被保持，在测试时，仅保留300个boxes</p></li><li><p>Region-based Fusion Network</p><p>通过设计region-based的融合网络来综合不同视角的特征图，并且同时进行物体分类和3D box方向的回归。</p><ul><li><p>Multi-View ROI pooling 由于来自不同视角的特征图具有不同的分辨率，采用ROI Pooling 去获得相同长度的特征向量。将生成的proposal映射到3D空间中的各个视图中，在此处，映射到三个视图（鸟瞰图BV，前视图FV，相机图像RGB），通过给定一个3D proposal ，我们可以得到ROIs: <span class="math display">\[ROI_v=T_{3D-&gt;v},v\in\{BV,FV,RGB\}\]</span> T表示从雷达坐标系转换为三个视图的坐标系，最终得到固定长度的特征向量。</p></li><li><p>Deep Fusion 提出了一种分层融合多视图特征图的Deep Fusion方法：</p><p><img src="/2020/04/24/pr_MV3D/image-20200412232728365.png" alt="image-20200412232728365" style="zoom:67%;"></p><p>输入为三个视图的特征图，上图展示了不同的融合策略。</p></li><li><p>Oriented 3D box regerssion</p><p>给定了多个视角特征的融合网络，然后由此根据3D proposal 回归 3Dbox的朝向，回归包括了3D框的8个三维角点坐标，总共24个向量，尽管这对于标记方向是冗余的，但是作者发现这种编码方式比通过中心点和尺寸的编码方式效果好。物体的朝向可以通过角点计算出来。</p><p>通过multi-task 损失函数同时训练类别和物体的朝向，这部分与proposal的损失函数一致。</p></li><li><p>Network Regularization（网络正则化）</p><p>这部分参考了FractalNet,采用两种方法调整网络：<code>drop-path training</code>和<code>auxiliary losses</code>。每一次迭代随机选择 global drop-path，如果一个global drop-path被选择，则从三个视图中随机选择一个视图。如果local drop-path被选择，则以0.5几率随机抛弃输入到join的节点，但要保证每个join（连接点）至少有一个输入。</p><figure><img src="/2020/04/24/pr_MV3D/image-20200412234940402.png" alt="image-20200412234940402"><figcaption>image-20200412234940402</figcaption></figure><p>在推断过程中，上述附加网络将会去除。</p></li></ul></li></ul><p>代码实现：https://github.com/bostondiditeam/MV3D https://github.com/leeyevi/MV3D_TF</p><p>论文解读：https://zhuanlan.zhihu.com/p/86312623</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标跟踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo lidar算法--segmentaion component（一）</title>
      <link href="/2020/04/24/apollo-liadr_segmentation/"/>
      <url>/2020/04/24/apollo-liadr_segmentation/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="配置文件">配置文件</h2><p>SegmentationComponent以128线Velodyne128为例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#组件dag配置文件：</span><br><span class="line">components &#123;</span><br><span class="line">   class_name : <span class="string">"SegmentationComponent"</span></span><br><span class="line">   config &#123;</span><br><span class="line">     name: <span class="string">"Velodyne128Segmentation"</span></span><br><span class="line">     config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/lidar/velodyne128_segmentation_conf.pb.txt"</span></span><br><span class="line">     flag_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/perception_common.flag"</span></span><br><span class="line">     readers &#123;</span><br><span class="line">         channel: <span class="string">"/apollo/sensor/lidar128/compensator/PointCloud2"</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>参数配置文件：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sensor_name: <span class="string">"velodyne128"</span></span><br><span class="line">enable_hdmap: <span class="literal">true</span></span><br><span class="line">lidar_query_tf_offset: <span class="number">0</span></span><br><span class="line">lidar2novatel_tf2_child_frame_id: <span class="string">"velodyne128"</span></span><br><span class="line">output_channel_name: <span class="string">"/perception/inner/SegmentationObjects"</span></span><br></pre></td></tr></table></figure><h2 id="初始化程序">初始化程序</h2><p><strong>SegmentationComponent::Init()</strong></p><ul><li><p>1.根据参数配置文件初始化成员变量，创建输出节点 ，通道为<code>/perception/inner/SegmentationObjects</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer_ &#x3D; node_-&gt;CreateWriter&lt;LidarFrameMessage&gt;(output_channel_name_);</span><br></pre></td></tr></table></figure></li><li><p>2.<code>InitAlgorithmPlugin()</code></p><p>初始化算法组件（<code>module/perception/lidar/..</code>下的各个功能模块）</p><ul><li><p>2.1创建<code>&lt;LidarObstacleSegmentation&gt;</code>功能实例<code>segmentator_</code> 然后初始化<code>segmentor_-&gt;Init(init_options)</code></p><ul><li><p>2.1.1通过<code>config_manager</code>获取功能模块的配置信息<code>model_config</code>,模块参数配置文件位于： <code>production/conf/perception/lidar/modules/lidar_obstacle_pipeline.config</code> 根据该文件中的根路径结合传感器名称可得配置信息如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 定义于lidar/app/proto/lidar_obstacle_segmentation_config.proto</span><br><span class="line">segmentor: <span class="string">"CNNSegmentation"</span></span><br><span class="line">use_map_manager: <span class="literal">true</span></span><br><span class="line">use_object_filter_bank: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>2.1.2 创建<code>&lt;SceneManager&gt;</code>类实例，并根据<code>SceneManagerInitOptions</code>进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: initialize scene manager with lock</span></span><br><span class="line"><span class="comment">// @param [in]: initialization options</span></span><br><span class="line"><span class="comment">// @return: status</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SceneManager::Init</span><span class="params">(<span class="keyword">const</span> SceneManagerInitOptions&amp; options = SceneManagerInitOptions())</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>通过<code>config_manager</code>获取该功能模块的配置信息，直接给出配置文件信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ./data/perception/lidar/models/scene_manager/scene_manager.conf</span><br><span class="line">service_name: <span class="string">"GroundService"</span></span><br><span class="line">service_name: <span class="string">"ROIService"</span></span><br></pre></td></tr></table></figure><p>然后由这两个service动态继承<code>&lt;SceneService&gt;</code>类创建实例，并进行初始化：<code>service-&gt;Init()</code></p><ul><li><p><code>GroundService::Init()</code> 创建<code>&lt;GroundServiceContent&gt;</code>类实例<code>ground_content_ref_</code>，并通过<code>config manager</code>获取配置参数进行初始化，包括以下配置：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="string">"./data/perception/lidar/models/ground_service"</span></span><br><span class="line">roi_rad_x: <span class="number">120.0</span></span><br><span class="line">roi_rad_y: <span class="number">120.0</span></span><br><span class="line">grid_size: <span class="number">16</span></span><br></pre></td></tr></table></figure><p>通过以上配置信息，初始化<code>ground_content_ref_</code>实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: rows,cols = grid_size</span></span><br><span class="line">ground_content_ref_-&gt;Init(roi_region_rad_x, roi_region_rad_y, rows, cols);</span><br></pre></td></tr></table></figure><p>最终得到<code>resolution,grid_size,...</code> 地平面上网格的行、列数，网格的尺寸及分辨率，由此初始化<code>&lt;GroundGrid&gt;</code>类实例 <code>grid_.Init(rows_, cols_)</code></p></li><li><p><code>ROIService::Init()</code> 创建<code>&lt;ROIServiceContent&gt;</code>类实例<code>roi_content_ref_</code>，并通过<code>config manager</code>获取配置参数进行初始化，包括以下配置,并设置<code>roi_content_ref_</code>的参数为下列值</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ./data/perception/lidar/models/roi_service</span><br><span class="line">range: <span class="number">120.0</span></span><br><span class="line">cell_size: <span class="number">0.25</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>向Scene Manager中添加初始化后的service：<code>services_.emplace(name, service);</code></p></li></ul></li><li><p>2.1.3 初始化点云预处理的功能类<code>&lt;PointCloudPreprocessor&gt;</code>实例<code>cloud_preprocessor_</code></p><ul><li><p><code>PointCloudPreprocessor::Init()</code></p><p>通过<code>config manager</code>获取该功能的配置参数，直接给出配置文件信息：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ./data/perception/lidar/models/pointcloud_preprocessor</span><br><span class="line">filter_naninf_points: <span class="literal">false</span></span><br><span class="line">filter_nearby_box_points: <span class="literal">true</span></span><br><span class="line">box_forward_x: <span class="number">2.0</span></span><br><span class="line">box_backward_x: -<span class="number">2.0</span></span><br><span class="line">box_forward_y: <span class="number">3.0</span></span><br><span class="line">box_backward_y: -<span class="number">5.0</span></span><br><span class="line">filter_high_z_points: <span class="literal">false</span></span><br><span class="line">z_threshold: <span class="number">5.0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>2.1.4 初始化地图管理类<code>&lt;MapManager&gt;</code>实例<code>map_manager_</code>,</p><ul><li><p><code>MapManager::Init()</code></p><p>通过<code>config manager</code>获取该功能的配置参数，直接给出配置文件信息：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ./data/perception/lidar/models/map_manager/map_manager.conf</span><br><span class="line">update_pose: <span class="literal">false</span></span><br><span class="line">roi_search_distance: <span class="number">120.0</span></span><br></pre></td></tr></table></figure><p>然后获取<code>HDMapInput::Instance()</code>实例<code>hdmap_input_</code>，并进行初始化，主要就是加载高清地图的文件路径，此处省略。</p></li></ul></li><li><p>2.1.5 根据2.1.1中的segmentor创建分割器接口类<code>&lt;BaseSegmentation&gt;</code>派生类<code>CNNSegmentation</code>,然后初始化 <code>segmentor_-&gt;Init(segmentation_init_options)</code></p><ul><li><p><code>CNNSegmentation::Init()</code> 初始化该网络模型，首先获取网络的结构，参数，权重的文件路径。</p><ul><li><p><code>CNNSegmentation::GetConfigs()</code> 依然是通过<code>config manager</code>和对应的proto获取参数，此处直接给出文件中的参数：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ./data/perception/lidar/models/cnnseg/cnnseg.conf</span><br><span class="line">use_paddle: <span class="literal">false</span></span><br><span class="line">param_file: <span class="string">"./data/perception/lidar/models/cnnseg/velodyne128/cnnseg_param.conf"</span></span><br><span class="line">proto_file: <span class="string">"./data/perception/lidar/models/cnnseg/velodyne128/deploy.prototxt"</span></span><br><span class="line">weight_file: <span class="string">"./data/perception/lidar/models/cnnseg/velodyne128/deploy.caffemodel"</span></span><br><span class="line">paddle_param_file: <span class="string">"./data/perception/lidar/models/cnnseg/velodyne128/cnnseg_param_paddle.conf"</span></span><br><span class="line">paddle_proto_file: <span class="string">"./data/perception/lidar/models/cnnseg/velodyne128/model"</span></span><br><span class="line">paddle_weight_file: <span class="string">"./data/perception/lidar/models/cnnseg/velodyne128/params"</span></span><br><span class="line">engine_file: <span class="string">"./data/perception/lidar/models/cnnseg/velodyne128/engine.conf"</span></span><br></pre></td></tr></table></figure><p>分别对应网络参数，模型的结构和权重三个文件路径。</p></li><li><p>创建前向推断器，构建网络模型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inference_.reset(inference::CreateInferenceByName(cnnseg_param_.model_type(),</span><br><span class="line">                                                    proto_file, weight_file,</span><br><span class="line">                                                    output_names, input_names));</span><br></pre></td></tr></table></figure></li><li><p>初始化前向推断器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_shape &#x3D; &#123;1, 8, height_, width_&#125;; 1*8*864*864</span><br><span class="line">inference_-&gt;Init(input_shapes)</span><br></pre></td></tr></table></figure></li><li><p>创建输入输出的blob_,用于数据的写入和读取</p></li><li><p>初始化特征生成器<code>&lt;FeatureGenerator&gt;</code>实例，并初始化 <code>feature_generator_-&gt;Init(feature_param, feature_blob_.get()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> FeatureParam&amp; feature_param, base::Blob&lt;<span class="keyword">float</span>&gt;* out_blob)</span></span>;</span><br></pre></td></tr></table></figure><p>创建变量<code>std::vector&lt;int&gt; point2grid_</code>保存每个点在特征图中的一维索引，空间申请为120000 对应特征图的参数信息为：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">feature_param &#123;</span><br><span class="line">            width: <span class="number">864</span></span><br><span class="line">            height: <span class="number">864</span></span><br><span class="line">    point_cloud_range: <span class="number">90</span></span><br><span class="line">            min_height: -<span class="number">5.0</span></span><br><span class="line">            max_height: <span class="number">5.0</span></span><br><span class="line">    use_intensity_feature: <span class="literal">false</span></span><br><span class="line">            use_constant_feature: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>CNNSegmentation::InitClusterAndBackgroundSegmentation()</code> 初始化聚类和背景分割方法：</p><ul><li><p>初始化地平面检测器<code>ground detector</code> 通过<code>&lt;BaseGroundDetectorRegister&gt;</code>接口类创建<code>&lt;SpatioTemporalGroundDetector&gt;</code>实现类，然后初始化：<code>ground_detector_-&gt;Init(ground_detector_init_options)</code></p><ul><li><p><code>SpatioTemporalGroundDetector::Init(）</code> 通过<code>config manager</code>和对应的proto获取配置参数，此处直接给出配置文件的内容：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        #./data/perception/lidar/models/spatio_temporal_ground_detector/</span><br><span class="line">        grid_size: <span class="number">16</span></span><br><span class="line">        ground_thres: <span class="number">0.25</span></span><br><span class="line">        roi_rad_x: <span class="number">120.0</span></span><br><span class="line">        roi_rad_y: <span class="number">120.0</span></span><br><span class="line">        roi_rad_z: <span class="number">120.0</span></span><br><span class="line">        nr_smooth_iter: <span class="number">5</span></span><br><span class="line"><span class="comment">//以上参数为PlaneFitGroundDetectionParam</span></span><br><span class="line">        use_roi: <span class="literal">false</span></span><br><span class="line">use_ground_service: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>通过以上参数初始化<code>&lt;PlaneFileGroundDetectorParam&gt;</code>类实例(定义位于common/i_ground)</p><ul><li><code>PlaneFitGroundDetectorParam::Validate()</code> 判断输入参数是否有效</li><li>创建<code>vg_fine_ = new VoxelGridXY&lt;float&gt;()</code>体素栅格用于对点云数据进行降采样</li><li></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>初始化<code>roi filter</code> 通过<code>&lt;BaseROIFilter&gt;</code>接口类创建<code>&lt;HdmapROIFilter&gt;</code>实现类然后初始化，用于从点云中提取roi区域的点云：</p><pre><code>    - `HdmapROIFilter::Init()`通过`config manager`加载配置参数：</code></pre><p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#./data/perception/lidar/models/roi_filter/hdmap_roi_filter</span><br><span class="line">range: <span class="number">120.0</span></span><br><span class="line">cell_size: <span class="number">0.25</span></span><br><span class="line">extend_dist: <span class="number">0.0</span></span><br><span class="line">no_edge_table: <span class="literal">false</span></span><br><span class="line">set_roi_service: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><pre><code>      通过以上参数创建`&lt;Bitmap2D&gt;`类实例并初始化。  - 初始化`spp engine`获取分割网络的相关输出用于后处理聚类,相关参数配置见本文最后。  - 初始化 `thread worker` ,  若存在HDMap输入，则进行ROIFilter，最终得到`roi_cloud_`和`roi_world_cloud_`    roifilter之后则进行地平面检测    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ground_detector_-&gt;Detect(ground_detector_options, lidar_frame_ref_);</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>2.1.6 点云分割初始化之后，创建<code>&lt;ObjectBuilder&gt;</code>类，用于根据点云创建物体的相关属性。</p></li><li><p>2.1.7 初始化<code>&lt;ObjectFilterBank&gt;</code> 用于过滤得到的object,初始化通过<code>config manager</code>及对应的proto加载对应的参数：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ./data/perception/lidar/models/object_filter_bank/filter_bank.conf</span><br><span class="line">filter_name: <span class="string">"ROIBoundaryFilter"</span></span><br></pre></td></tr></table></figure><p>通过接口类<code>&lt;BaseObjectFilterRegister&gt;</code>根据<code>filter_name</code>创建类<code>&lt;ROIBoundaryFilter&gt;</code> 对该类进行通过<code>config mangaer</code>进行下列参数的加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># .&#x2F;data&#x2F;perception&#x2F;lidar&#x2F;models&#x2F;object_filter_bank&#x2F;roi_boundary_filter.conf</span><br><span class="line">distance_to_boundary_threshold: -1.0</span><br><span class="line">confidence_threshold: 0.5</span><br><span class="line">cross_roi_threshold: 0.6</span><br><span class="line">inside_threshold: 1.0</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><strong>至此，segmentation初始化部分的大体流程就完成了，主要集中于segmentator的初始化，简要总结如下：</strong></p><p>LidarObstacleSegmentation的初始化包括：</p><ul><li>SceneManager类初始化：<ul><li>GroundService初始化</li><li>ROIService初始化</li></ul></li><li>PointCloudPreprocessor类初始化 :点云的预处理，包括</li><li>MapManager类初始化 :管理HDMap</li><li>CNNSegmentation网络类初始化<ul><li>inference 推断器（Caffe,RTNet...）初始化 用于网络的前向推断和原始数据的获取</li><li>FeatureGenerator类初始化 ： 特征提取器初始化</li><li>SpatioTemporalGroundDetector 类初始化 ：地面检测器和聚类的相关方法</li><li>HdmapROIFilter 类初始化：根据ROIMap过滤点云</li><li>SppEngine类初始化：</li></ul></li><li>ObjectBuilder 类初始化： 用于构建object的相关属性</li><li>ROIBoundaryFilter 类初始化 ：用于过滤object</li></ul><hr><p>参数配置文件及参数配置信息汇总：</p><p><strong>spp_engine:</strong></p><table><thead><tr class="header"><th>参数名称</th><th>默认值（default）</th><th>作用</th><th></th></tr></thead><tbody><tr class="odd"><td>height_gap</td><td>0.5</td><td></td><td></td></tr><tr class="even"><td>confidence_range</td><td>85.0</td><td></td><td></td></tr><tr class="odd"><td>width</td><td>864</td><td>特征图宽</td><td></td></tr><tr class="even"><td>height</td><td>864</td><td>特征图高</td><td></td></tr><tr class="odd"><td>range</td><td>90.0</td><td>特征图对应的范围(米)</td><td></td></tr></tbody></table><p><strong>sppdata:</strong></p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>作用</th><th></th></tr></thead><tbody><tr class="odd"><td>objectness_threshold</td><td>0.5</td><td>用于过滤无效的cluster</td><td></td></tr><tr class="even"><td>confidence_threshold</td><td>0.1</td><td>用于过滤无效的cluster</td><td></td></tr><tr class="odd"><td>top_z_threshold</td><td>0.5</td><td></td><td></td></tr><tr class="even"><td>class_num</td><td>5</td><td>类别数量，用于计算cluster的类别 位于util.h</td><td></td></tr><tr class="odd"><td>obj_prob_data_ref</td><td></td><td>类别概率map(特征图各行首节点的prob地址)</td><td></td></tr></tbody></table><p><strong>feature_generator:</strong></p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>作用</th><th></th></tr></thead><tbody><tr class="odd"><td>point_cloud_range</td><td>90</td><td>点云的范围（米）</td><td></td></tr><tr class="even"><td>width</td><td>864</td><td>构建的特征图网格的宽</td><td></td></tr><tr class="odd"><td>height</td><td>864</td><td>构建的特征图网格的高</td><td></td></tr><tr class="even"><td>min_height</td><td>-5.0</td><td>最低高度(米)</td><td></td></tr><tr class="odd"><td>max_height</td><td>5.0</td><td>最大高度(米)用于选取特征图中的点云</td><td></td></tr></tbody></table><p><strong>SppCCDetector:</strong></p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>作用</th><th>类型</th></tr></thead><tbody><tr class="odd"><td>prob_map</td><td>obj_prob_data_ref</td><td>网络输出的是否是object的概率</td><td>float** [height]</td></tr><tr class="even"><td>offset_map</td><td>instance_pt_blob的数据指针</td><td>中心偏移 用于聚类</td><td></td></tr><tr class="odd"><td>scale</td><td>864/(2x90)</td><td>对应尺度，每米对应的格数</td><td></td></tr><tr class="even"><td>objectness_threshold</td><td>0.5</td><td>是目标object的阈值</td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>cnnseg:</strong></p><table><thead><tr class="header"><th>参数名称</th><th>默认值</th><th>作用</th><th>类型</th></tr></thead><tbody><tr class="odd"><td>min_pts_num</td><td>3</td><td>cluster所需要包含的最小点云数量</td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lidar目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog-mark</title>
      <link href="/2020/04/04/blog-mark/"/>
      <url>/2020/04/04/blog-mark/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title博客收藏">title:博客收藏</h2><p>mark一些比较好的博客</p><a id="more"></a><p>神经网络深度学习相关</p><p>yolo:</p><p>https://xmfbit.github.io/2018/04/01/paper-yolov3/</p><p>caffe:</p><p>https://cloud.tencent.com/developer/article/1394880</p><p>latex和c++等语言：</p><p>https://liam.page/archives/page/61/</p><p>gtest使用：</p><p>https://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html</p><p>google开源风格指南： https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>multiple_object_tracking_review</title>
      <link href="/2020/04/04/multiple_object_tracking_review/"/>
      <url>/2020/04/04/multiple_object_tracking_review/</url>
      
        <content type="html"><![CDATA[<p>多目标跟踪论文综述</p><p>https://blog.csdn.net/yuhq3/article/details/78742658</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>py-motmetric使用</title>
      <link href="/2020/04/04/py-motmetrics/"/>
      <url>/2020/04/04/py-motmetrics/</url>
      
        <content type="html"><![CDATA[<p>记录pymotmetric的使用方法</p><a id="more"></a><p><code>import motmetrics as mm</code></p><p>介绍几个主要的功能接口：</p><h3 id="motaccumulator创建及更新填充">MOTAccumulator创建及更新(填充)</h3><p>创建<code>MOTAccumulator</code>类对象，用于一个跟踪序列中frame by frame的计算（注：一个数据集可能有多个序列）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acc &#x3D; mm.MOTAccumulator(auto_id&#x3D;True)</span><br></pre></td></tr></table></figure><p>然后每一帧往<code>accumulator</code>中填充跟踪结果的相关信息,每一帧都有<code>ground truth/hypotheses id</code>的列表和它们两两之间的距离<code>dists</code>矩阵，例如: oids(真值):[1,2] //ground truth objects id list in this frame hids(估计):[1,2,3] //detector hypotheses id list in this frame dists:[[0.1, np.nan,0.3], //distance from oid 1 to hid1,2,3 [0.5, 0.2 ,0.3]] //distance from oid 2 to hid1,2,3 <code>np.nan</code>表示object 1 不能与 hypothesis 2 配对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Params</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">oids : N array</span></span><br><span class="line"><span class="string">    Array of object ids.</span></span><br><span class="line"><span class="string">hids : M array</span></span><br><span class="line"><span class="string">    Array of hypothesis ids.</span></span><br><span class="line"><span class="string">dists: NxM array</span></span><br><span class="line"><span class="string">    Distance matrix. np.nan values to signal do-not-pair constellations.</span></span><br><span class="line"><span class="string">    See `distances` module for support methods.</span></span><br><span class="line"><span class="string">@ optional :</span></span><br><span class="line"><span class="string">frame id (optional when MOTAccumulator.auto_id is specified)</span></span><br><span class="line"><span class="string">vf: file to log details</span></span><br><span class="line"><span class="string">-----</span></span><br><span class="line"><span class="string">Returns</span></span><br><span class="line"><span class="string">-----</span></span><br><span class="line"><span class="string">frame_events:pd.DataFrame(containing generated events)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">acc.update(oids,hids,dists,frameid,vf)</span><br></pre></td></tr></table></figure><p>上述update过程通过<code>the CLEAR MOT merics</code>中的相关指标，判断<code>Match,SWITCH,MISS,FP</code>,想要查看 <code>accumulator</code>中发生的事件，通过打印对应<code>accumulator</code>的events即可,event通过pandas.Dataframe的格式输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print(acc.events) <span class="comment"># a pandas DataFrame containing all events</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">                Type  OId  HId    D</span></span><br><span class="line"><span class="string">FrameId Event                      </span></span><br><span class="line"><span class="string">0       0        RAW  NaN  NaN  NaN</span></span><br><span class="line"><span class="string">        1        RAW  1.0  1.0  0.1</span></span><br><span class="line"><span class="string">        2        RAW  1.0  3.0  0.3</span></span><br><span class="line"><span class="string">        3        RAW  2.0  1.0  0.5</span></span><br><span class="line"><span class="string">        4        RAW  2.0  2.0  0.2</span></span><br><span class="line"><span class="string">        5        RAW  2.0  3.0  0.3</span></span><br><span class="line"><span class="string">        6      MATCH  1.0  1.0  0.1</span></span><br><span class="line"><span class="string">        7      MATCH  2.0  2.0  0.2</span></span><br><span class="line"><span class="string">        8         FP  NaN  3.0  NaN</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>其中<code>RAW</code>表示原始数据(oid,hid,dist),关于mot匹配的事件为oid1和hid1以距离0.1<code>MATCH</code>,oid2和hid2以距离0.2<code>MATCH</code>,同时由于hid3没有oid与之匹配,判断为<code>FP</code>，当然如果仅仅只是想打印mot匹配的相关事件，不想要原始匹配信息，可通过<code>mot_events</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(acc.mot_events) <span class="comment"># a pandas DataFrame containing MOT only events</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                Type  OId HId    D</span></span><br><span class="line"><span class="string">FrameId Event</span></span><br><span class="line"><span class="string">0       6      MATCH    1   1  0.1</span></span><br><span class="line"><span class="string">        7      MATCH    2   2  0.2</span></span><br><span class="line"><span class="string">        8         FP  NaN   3  NaN</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>通过每一帧一次update的填充更新，最终得到整个数据集各帧的所有<code>events</code>。 可能发生的事件有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Each event type is one of the following</span></span><br><span class="line"><span class="string">        - `'MATCH'` a match between a object and hypothesis was found</span></span><br><span class="line"><span class="string">        - `'SWITCH'` a match between a object and hypothesis was found but differs from previous assignment (hypothesisid != previous)</span></span><br><span class="line"><span class="string">        - `'MISS'` no match for an object was found</span></span><br><span class="line"><span class="string">        - `'FP'` no match for an hypothesis was found (spurious detections)</span></span><br><span class="line"><span class="string">        - `'RAW'` events corresponding to raw input</span></span><br><span class="line"><span class="string">        - `'TRANSFER'` a match between a object and hypothesis was found but differs from previous assignment (objectid != previous)</span></span><br><span class="line"><span class="string">        - `'ASCEND'` a match between a object and hypothesis was found but differs from previous assignment  (hypothesisid is new)</span></span><br><span class="line"><span class="string">        - `'MIGRATE'` a match between a object and hypothesis was found but differs from previous assignment  (objectid is new)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="metric的创建计算">2.Metric的创建计算</h3><p>根据已经填充的<code>MOTAccumulator</code>,创建<code>metrics</code>计算并显示指标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mh = mm.metrics.create()</span><br><span class="line">summary = mh.compute(acc, metrics=[<span class="string">'num_frames'</span>, <span class="string">'mota'</span>, <span class="string">'motp'</span>], name=<span class="string">'acc'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">compute(self, df, ana=None, metrics=None, return_dataframe=True, return_cached=False, name=None)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@brief</span></span><br><span class="line"><span class="string">Compute metrics on the dataframe / accumulator</span></span><br><span class="line"><span class="string">Params</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">df : MOTAccumulator or pandas.DataFrame</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Kwargs(optional)</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">ana(dict) :cache results for fast computation</span></span><br><span class="line"><span class="string">metrics(string,list of string or None):the identifiers of the metrics(想要计算的指标的标识符，none全计算)</span></span><br><span class="line"><span class="string">return_dataframe(bool):return the results as pandas.DataFrame</span></span><br><span class="line"><span class="string">return_cached(bool):return metrics</span></span><br><span class="line"><span class="string">name(string):when return a pandas.DataFrame this is the index of the row containing the computed metric valuse</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>通过<code>print(summary)</code>，我们可以得到我们给定的<code>metrics</code>列表中对应的指标计算结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     num_frames  mota  motp</span><br><span class="line">acc           3   0.5  0.34</span><br></pre></td></tr></table></figure><p>上面是计算单个<code>accumulator</code>，如果要同时计算多个数据集的指标，则通过<code>mh.compute_many()</code>进行计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">summary = mh.compute_many(</span><br><span class="line">    [acc, acc.events.loc[<span class="number">0</span>:<span class="number">1</span>]],</span><br><span class="line">    metrics=[<span class="string">'num_frames'</span>, <span class="string">'mota'</span>, <span class="string">'motp'</span>],</span><br><span class="line">    names=[<span class="string">'full'</span>, <span class="string">'part'</span>])</span><br><span class="line">print(summary)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def compute_many(self, dfs, anas=None, metrics=None, names=None, generate_overall=False):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@brief:</span></span><br><span class="line"><span class="string">Compute metrics on multiple dataframe / accumulators.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Params</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">dfs(list)： list of MOTAccumulator or list of pandas.DataFrame</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Kwargs</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">names(list of string): the names of individual rows in the resulting dataframe. </span></span><br><span class="line"><span class="string">...其余与compute类似，省略</span></span><br><span class="line"><span class="string">Returns</span></span><br><span class="line"><span class="string">-------</span></span><br><span class="line"><span class="string">df : pandas.DataFrame</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>通过<code>print(summary)</code>,可得到各<code>accumulator</code>的指标计算结果的显示,<code>full,part</code>对应<code>names</code>，行名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      num_frames  mota      motp</span><br><span class="line">full           <span class="number">3</span>   <span class="number">0.5</span>  <span class="number">0.340000</span></span><br><span class="line">part           <span class="number">2</span>   <span class="number">0.5</span>  <span class="number">0.166667</span></span><br></pre></td></tr></table></figure><h3 id="格式化输出最终结果">3.格式化输出最终结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">strsummary = mm.io.render_summary(</span><br><span class="line">    summary,</span><br><span class="line">    formatters=&#123;<span class="string">'mota'</span> : <span class="string">'&#123;:.2%&#125;'</span>.format&#125;,</span><br><span class="line">    namemap=&#123;<span class="string">'mota'</span>: <span class="string">'MOTA'</span>, <span class="string">'motp'</span> : <span class="string">'MOTP'</span>&#125;</span><br><span class="line">)</span><br><span class="line">print(strsummary)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def render_summary(summary, formatters=None, namemap=None, buf=None):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@brief:</span></span><br><span class="line"><span class="string">Render metrics summary to console friendly tabular output</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Params</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">summary :pd.DataFrame Dataframe containing summaries in rows(compute_many/compute的返回值)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Kwargs</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">buf : StringIO-like Buffer to writer to </span></span><br><span class="line"><span class="string">formatters(dict): define custorm formatters for individual metrics.you can get preset formatters from</span></span><br><span class="line"><span class="string">MetricsHost.formatters</span></span><br><span class="line"><span class="string">namemap(dict): Dictornary defining new metric names for display I.e`&#123;'num_false_positives': 'FP'&#125;`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns</span></span><br><span class="line"><span class="string">-------</span></span><br><span class="line"><span class="string">string : Formatted string</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>通过打印<code>print(strsummary)</code>可打印指标计算结果，并于未格式化之前进行比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># unformatted</span></span><br><span class="line">     num_frames  mota      motp</span><br><span class="line">full           <span class="number">3</span>   <span class="number">0.5</span>  <span class="number">0.340000</span></span><br><span class="line">part           <span class="number">2</span>   <span class="number">0.5</span>  <span class="number">0.166667</span></span><br><span class="line"><span class="comment"># formatted</span></span><br><span class="line"> num_frames   MOTA      MOTP</span><br><span class="line">full           <span class="number">3</span> <span class="number">50.00</span>%  <span class="number">0.340000</span></span><br><span class="line">part           <span class="number">2</span> <span class="number">50.00</span>%  <span class="number">0.166667</span></span><br></pre></td></tr></table></figure><p>pymotmetric中包含了预定义的输出格式，其中metrics即我们想要衡量的计算指标直接使用预设的<code>motchallenge_metrics</code> 输出格式使用预定义的<code>mh.formatters</code>,指标名称映射使用<code>mm.io.motchallenge_metric_names</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">summary &#x3D; mh.compute_many(</span><br><span class="line">    [acc, acc.events.loc[0:1]],</span><br><span class="line">    metrics&#x3D;mm.metrics.motchallenge_metrics,</span><br><span class="line">    names&#x3D;[&#39;full&#39;, &#39;part&#39;])</span><br><span class="line"></span><br><span class="line">strsummary &#x3D; mm.io.render_summary(</span><br><span class="line">    summary,</span><br><span class="line">    formatters&#x3D;mh.formatters,</span><br><span class="line">    namemap&#x3D;mm.io.motchallenge_metric_names</span><br><span class="line">)</span><br><span class="line">print(strsummary)</span><br></pre></td></tr></table></figure><p>可得到预定义的输出格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      IDF1   IDP   IDR  Rcll  Prcn GT MT PT ML FP FN IDs  FM  MOTA  MOTP IDt IDa IDm</span><br><span class="line">full <span class="number">83.3</span>% <span class="number">83.3</span>% <span class="number">83.3</span>% <span class="number">83.3</span>% <span class="number">83.3</span>%  <span class="number">2</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span> <span class="number">50.0</span>% <span class="number">0.340</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span></span><br><span class="line">part <span class="number">75.0</span>% <span class="number">75.0</span>% <span class="number">75.0</span>% <span class="number">75.0</span>% <span class="number">75.0</span>%  <span class="number">2</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span> <span class="number">50.0</span>% <span class="number">0.167</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果先要获取各个数据集(在MOT中可能是一个数据集的各个sequence)最终的总体指标,将<code>mh.compute()</code>或 <code>mh.compute_many()</code>中的参数<code>generate_overall=True</code>,则在计算完各个序列的指标后，最后会计算一个总的overall指标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">summary = mh.compute_many(</span><br><span class="line">    [acc, acc.events.loc[<span class="number">0</span>:<span class="number">1</span>]],</span><br><span class="line">    metrics=mm.metrics.motchallenge_metrics,</span><br><span class="line">    names=[<span class="string">'full'</span>, <span class="string">'part'</span>],</span><br><span class="line">    generate_overall=<span class="literal">True</span>                 <span class="comment">##计算整个数据集的指标</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">strsummary = mm.io.render_summary(</span><br><span class="line">    summary,</span><br><span class="line">    formatters=mh.formatters,</span><br><span class="line">    namemap=mm.io.motchallenge_metric_names</span><br><span class="line">)</span><br><span class="line">print(strsummary)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">         IDF1   IDP   IDR  Rcll  Prcn GT MT PT ML FP FN IDs  FM  MOTA  MOTP</span></span><br><span class="line"><span class="string">full    83.3% 83.3% 83.3% 83.3% 83.3%  2  1  1  0  1  1   1   1 50.0% 0.340</span></span><br><span class="line"><span class="string">part    75.0% 75.0% 75.0% 75.0% 75.0%  2  1  1  0  1  1   0   0 50.0% 0.167</span></span><br><span class="line"><span class="string">OVERALL 80.0% 80.0% 80.0% 80.0% 80.0%  4  2  2  0  2  2   1   1 50.0% 0.275</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="获取update中的distance距离矩阵">获取update中的distance距离矩阵</h3><p><code>pymotmetric</code>中提供的工具为<code>motmetrics.distance</code>模块</p><p><strong>Euclidean norm squared on points</strong> 欧氏距离的平方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Object related points</span></span><br><span class="line">o = np.array([</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">2.</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3.</span>, <span class="number">2</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hypothesis related points</span></span><br><span class="line">h = np.array([</span><br><span class="line">    [<span class="number">0.</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">1</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">C = mm.distances.norm2squared_matrix(o, h, max_d2=<span class="number">5.</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[  5.   1.]</span></span><br><span class="line"><span class="string"> [ nan   2.]</span></span><br><span class="line"><span class="string"> [ nan   5.]]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p><code>mm.distance.norm2squared_matrix(objs,hyps,max_d2=float('inf'))</code> ,<code>max_d2</code>为距离阈值，超过此距离则不进行匹配，设为<code>np.nan</code> ,<code>objs</code>和<code>hyps</code>为列数同一维度的坐标点(ie. 都是二维点)，但是点的数量可以不一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Computes the squared Euclidean distance matrix between object and hypothesis points.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Params</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">objs : NxM array</span></span><br><span class="line"><span class="string">    Object points of dim M in rows</span></span><br><span class="line"><span class="string">hyps : KxM array</span></span><br><span class="line"><span class="string">    Hypothesis points of dim M in rows</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Kwargs</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">max_d2 : float</span></span><br><span class="line"><span class="string">    Maximum tolerable squared Euclidean distance. Object / hypothesis points</span></span><br><span class="line"><span class="string">    with larger distance are set to np.nan signalling do-not-pair. Defaults</span></span><br><span class="line"><span class="string">    to +inf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns</span></span><br><span class="line"><span class="string">-------</span></span><br><span class="line"><span class="string">C : NxK array</span></span><br><span class="line"><span class="string">    Distance matrix containing pairwise distances or np.nan.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p><strong>Intersection over union norm for 2D rectangles</strong> :2D框的交并比作为距离衡量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; np.array([</span><br><span class="line">    [0, 0, 1, 2],    # Format X, Y, Width, Height</span><br><span class="line">    [0, 0, 0.8, 1.5],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">b &#x3D; np.array([</span><br><span class="line">    [0, 0, 1, 2],</span><br><span class="line">    [0, 0, 1, 1],</span><br><span class="line">    [0.1, 0.2, 2, 2],</span><br><span class="line">])</span><br><span class="line">mm.distances.iou_matrix(a, b, max_iou&#x3D;0.5)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[[ 0.          0.5                nan]</span><br><span class="line"> [ 0.4         0.42857143         nan]]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p><code>mm.distance.iou_matrix(objs,hyps,max_iou=1.)</code> 计算iou距离=1-iou，输入格式要求为(x,y,w,h),其中<code>max_iou</code>,当计算的iou距离大于<code>max_iou</code>，距离置为<code>np.nan</code>不进行匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Computes 'intersection over union (IoU)' distance matrix between object and hypothesis rectangles.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The IoU is computed as</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    IoU(a,b) = 1. - isect(a, b) / union(a, b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">where isect(a,b) is the area of intersection of two rectangles and union(a, b) the area of union. The</span></span><br><span class="line"><span class="string">IoU is bounded between zero and one. 0 when the rectangles overlap perfectly and 1 when the overlap is</span></span><br><span class="line"><span class="string">zero.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Params</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">objs : Nx4 array</span></span><br><span class="line"><span class="string">    Object rectangles (x,y,w,h) in rows</span></span><br><span class="line"><span class="string">hyps : Kx4 array</span></span><br><span class="line"><span class="string">    Hypothesis rectangles (x,y,w,h) in rows</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Kwargs</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string">max_iou : float</span></span><br><span class="line"><span class="string">    Maximum tolerable overlap distance. Object / hypothesis points</span></span><br><span class="line"><span class="string">    with larger distance are set to np.nan signalling do-not-pair. Defaults</span></span><br><span class="line"><span class="string">    to 0.5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns</span></span><br><span class="line"><span class="string">-------</span></span><br><span class="line"><span class="string">C : NxK array</span></span><br><span class="line"><span class="string">    Distance matrix containing pairwise distances or np.nan.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="直接利用mot数据集格式的检测结果进行衡量">直接利用mot数据集格式的检测结果进行衡量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'idf1'</span>: <span class="string">'IDF1'</span>,</span><br><span class="line"><span class="string">'idp'</span>: <span class="string">'IDP'</span>,</span><br><span class="line"><span class="string">'idr'</span>: <span class="string">'IDR'</span>,</span><br><span class="line"><span class="string">'recall'</span>: <span class="string">'Rcll'</span>,</span><br><span class="line"><span class="string">'precision'</span>: <span class="string">'Prcn'</span>,</span><br><span class="line"><span class="string">'num_unique_objects'</span>: <span class="string">'GT'</span>,</span><br><span class="line"><span class="string">'mostly_tracked'</span>: <span class="string">'MT'</span>,</span><br><span class="line"><span class="string">'partially_tracked'</span>: <span class="string">'PT'</span>,</span><br><span class="line"><span class="string">'mostly_lost'</span>: <span class="string">'ML'</span>,</span><br><span class="line"><span class="string">'num_false_positives'</span>: <span class="string">'FP'</span>,</span><br><span class="line"><span class="string">'num_misses'</span>: <span class="string">'FN'</span>,</span><br><span class="line"><span class="string">'num_switches'</span>: <span class="string">'IDs'</span>,</span><br><span class="line"><span class="string">'num_fragmentations'</span>: <span class="string">'FM'</span>,</span><br><span class="line"><span class="string">'mota'</span>: <span class="string">'MOTA'</span>,</span><br><span class="line"><span class="string">'motp'</span>: <span class="string">'MOTP'</span>,</span><br><span class="line"><span class="string">'num_transfer'</span>: <span class="string">'IDt'</span>,</span><br><span class="line"><span class="string">'num_ascend'</span>: <span class="string">'IDa'</span>,</span><br><span class="line"><span class="string">'num_migrate'</span>: <span class="string">'IDm'</span>,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- &#96;&#39;MATCH&#39;&#96; a match between a object and hypothesis was found</span><br><span class="line">- &#96;&#39;SWITCH&#39;&#96; a match between a object and hypothesis was found but differs from previous assignment (hypothesisid !&#x3D; previous)</span><br><span class="line">- &#96;&#39;MISS&#39;&#96; no match for an object was found</span><br><span class="line">- &#96;&#39;FP&#39;&#96; no match for an hypothesis was found (spurious detections)</span><br><span class="line">- &#96;&#39;RAW&#39;&#96; events corresponding to raw input</span><br><span class="line">- &#96;&#39;TRANSFER&#39;&#96; a match between a object and hypothesis was found but differs from previous assignment (objectid !&#x3D; previous)</span><br><span class="line">- &#96;&#39;ASCEND&#39;&#96; a match between a object and hypothesis was found but differs from previous assignment  (hypothesisid is new)</span><br><span class="line">- &#96;&#39;MIGRATE&#39;&#96; a match between a object and hypothesis was found but differs from previous assignment  (objectid is new)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 目标跟踪 </category>
          
          <category> 多目标跟踪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本编程基础</title>
      <link href="/2020/04/04/shell_program/"/>
      <url>/2020/04/04/shell_program/</url>
      
        <content type="html"><![CDATA[<p>shell 脚本可以让计算机自动完成一系列的工作，通过解释运行。</p><a id="more"></a><p>[TOC]</p><p>shell脚本的第一行一般是<code>#! /bin/bash</code> 告诉系统这个脚本需要用什么解释器来执行，即用哪一种shell,<code>#!</code>是约定的标记 运行shell脚本的两种方法：</p><p>作为可执行程序(通过<code>./</code>执行要求文件有执行权限)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">./test.sh <span class="comment"># 执行脚本</span></span><br></pre></td></tr></table></figure><p>作为解释器参数(文件可以无执行权限)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash test.sh</span><br></pre></td></tr></table></figure><p><code>source</code>命令作用是在当前bash环境下读取并执行文件中的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source test.sh</span><br></pre></td></tr></table></figure><h2 id="shell编程语法">1. Shell编程语法</h2><h3 id="shell-变量">1.1 Shell 变量</h3><p><strong>定义变量：</strong> 定义变量时，不需要加<code>$</code>符号，且变量名和等号之间不能有空格，通过字母数字下划线组成，开头不能为数字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">"jac"</span></span><br></pre></td></tr></table></figure><p><strong>使用变量：</strong> 使用一个定义过的变量，只需要在变量名之前加<code>$</code>,如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">"jac"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$my_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;my_name&#125;</span></span><br></pre></td></tr></table></figure><p>变量名外的花括号可选，花括号用于帮助解释器识别变量的边界。 <strong>只读变量：</strong> 使用<code>readonly</code>命令可以将变量定义为只读变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">"jac"</span></span><br><span class="line"><span class="built_in">readonly</span> my_name</span><br></pre></td></tr></table></figure><p><strong>删除变量：</strong> 使用<code>unset</code>命令可以删除变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> my_name</span><br></pre></td></tr></table></figure><p><strong>变量类型：</strong> 运行shell时，会同时存在三种变量： (1) 局部变量：在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量 (2) 环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行， 必要的时候shell脚本也可以定义环境变量。 (3) shell变量：shell变量时shell 程序设置的特殊变量，shell变量中有一部分是环境变量，有一部分是局部变量。</p><h3 id="shell-变量类型">1.2 shell 变量类型</h3><p><strong>shell字符串:</strong> 字符串是shell编程中最常用的数据类型，可以用单引号，也可以用双引号表示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">'this is a string'</span></span><br></pre></td></tr></table></figure><p>单引号字符串的限制： 单引号里的任何字符都会原样输出，且单引号字符串中的变量,转义符都是是无效的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">'jac'</span></span><br><span class="line">str=<span class="string">"Hello,<span class="variable">$&#123;my_name&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>双引号字符串的优点： 双引号里可以出现转义字符，也可以含有变量。</p><p>拼接字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">'jachin'</span></span><br><span class="line">my_name=<span class="string">'jac'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span> <span class="variable">$my_name</span></span><br></pre></td></tr></table></figure><p>获取字符串长度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">"jachin"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#my_name&#125;</span> <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure><p>提取子字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">"jachin"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;my_name:1:4&#125;</span> <span class="comment">#输出achi</span></span><br></pre></td></tr></table></figure><p>​ 字符串截取方式：<code>#,##</code>表示从左边开始删除，一个<code>#</code>表示从左边删除到第一个指定的字符，两个<code>#</code>表示从左边开始删除到最后一个指定的字符，而<code>%,%%</code>表示从右边开始删除，一个<code>%</code>表示从右边删除到第一个指定的字符，两个<code>%</code>表示从右边删除到最后一个指定的字符。</p><p>查找子字符串：查找字符h或i的位置（谁先出现，就返回谁）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">"jachin"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$my_name</span>"</span> io`</span><br></pre></td></tr></table></figure><p>注意是反引号 ` 不是单引号 ’</p><p><strong>Shell数组：</strong> bash支持一维数组（不支持多维数组），并且没有限定数组的大小,与C语言类似，数组元素的下标从0开始编号，并通过下标获取数组中的元素。</p><p>定义数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure><p>读取数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value=<span class="variable">$&#123;array_name[n]&#125;</span></span><br><span class="line">value=<span class="variable">$&#123;array_name[@]&#125;</span></span><br></pre></td></tr></table></figure><p>使用<code>@</code>可以获取数组中的所有元素 获取数组长度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="shell-传递参数">1.3 shell 传递参数</h3><p>在执行脚本时，可以脚本传递参数，脚本内获得参数的格式为：<code>$n</code>,n代表一个数字，1为执行脚本的第一个参数，2为执行脚本的第二个参数，同时还有一下特殊字符<code>#,*,$,!,@,-,?</code></p><table><thead><tr class="header"><th style="text-align: center;">参数</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>$#</code></td><td style="text-align: center;">传递到的脚本的参数个数</td></tr><tr class="even"><td style="text-align: center;"><code>$*</code></td><td style="text-align: center;">以一个单字符串显示所有向脚本传递的参数</td></tr><tr class="odd"><td style="text-align: center;"><code>$$</code></td><td style="text-align: center;">脚本运行的当前进程id号</td></tr><tr class="even"><td style="text-align: center;"><code>$!</code></td><td style="text-align: center;">后台运行的最后一个进程的id号</td></tr><tr class="odd"><td style="text-align: center;"><code>$@</code></td><td style="text-align: center;">以一个单字符串显示所有向脚本传递的参数</td></tr><tr class="even"><td style="text-align: center;"><code>$-</code></td><td style="text-align: center;">显示shell使用的当前选项</td></tr><tr class="odd"><td style="text-align: center;"><code>$?</code></td><td style="text-align: center;">显示最后命令的退出状态，0表示没有错误，其他任何值表明有错误</td></tr></tbody></table><p><code>$*</code>当以双引号&quot; &quot;括起来，则返回的是&quot;$1,$2,...&quot; <code>$@</code>当以双引号&quot; &quot;括起来，则返回的是&quot;$1&quot;,&quot;$2&quot;,...</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bash test.sh 1 2 3</span><br><span class="line">---</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"$*"</span>;<span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#输出 1 2 3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>;<span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#输出 </span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="shell-运算符">1.4 Shell 运算符</h3><p>shell支持多种运算符，包括：</p><ul><li>算数运算符</li><li>关系运算符</li><li>布尔运算符</li><li>字符串运算符</li><li>文件测试运算符</li></ul><p>原生的bash不支持数学运算，但是可以通过<code>awk</code> 和<code>expr</code>等命令来实现。<code>expr</code>较常用，其是表达式计算工具，使用它能够完成表达式的求值操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`</span><br></pre></td></tr></table></figure><p>注意表达式和运算符之间要有空格，且表达式要被``包含。</p><p><strong>算数运算符：</strong></p><table><thead><tr class="header"><th style="text-align: left;">运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">+</td><td>加法</td><td>`expr $a + $b`</td></tr><tr class="even"><td style="text-align: left;">-</td><td>减法</td><td>`expr $a - $b`</td></tr><tr class="odd"><td style="text-align: left;">*</td><td>乘法</td><td>`expr $a \* $b`</td></tr><tr class="even"><td style="text-align: left;">/</td><td>除法</td><td>`expr $a / $b`</td></tr><tr class="odd"><td style="text-align: left;">%</td><td>取余</td><td>`expr $a % <span class="math inline">\(b\` | | = | 赋值 | a=\)</span>b</td></tr><tr class="even"><td style="text-align: left;">==</td><td>相等。用于比较两个数字，相同则返回True</td><td>[ $a == $b ]</td></tr><tr class="odd"><td style="text-align: left;">!=</td><td>不相等。用于比较两个数字，不相同则返回True</td><td>[ $a != $b ]</td></tr></tbody></table><p>注意：运算符左右的空格,以及[ ]与变量之间的空格, `expr 10 + 20`可替换为$(expr 10 + 20)</p><p><strong>关系运算符：</strong></p><table><thead><tr class="header"><th style="text-align: left;">运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">-eq</td><td>检查两个数是否相等，相等则返回true</td><td>[ $a -eq $b ]</td></tr><tr class="even"><td style="text-align: left;">-ne</td><td>检查两个数是否不相等，不相等则返回true</td><td>[ $a -ne $b ]</td></tr><tr class="odd"><td style="text-align: left;">-gt</td><td>检查左边的数是否大于右边的，是则返回true</td><td>[ $a -gt $b ]</td></tr><tr class="even"><td style="text-align: left;">-lt</td><td>检查左边的数是否小于右边的，是则返回true</td><td>[ $a -lt $b ]</td></tr><tr class="odd"><td style="text-align: left;">-ge</td><td>检查左边的数是否大于等于右边的，是则返回true</td><td>[ $a -ge $b ]</td></tr><tr class="even"><td style="text-align: left;">-le</td><td>检查左边的数是否小于等于右边的，是则返回true</td><td>[ $a -le $b ]</td></tr></tbody></table><p>注：可用于条件语句：if.. then .. fi eq-&gt;equal ,ne-&gt;not equal ,gt-&gt;greater than,lt-&gt;less than,ge-&gt;greater than or equal ,le-&gt;less than or equal</p><p><strong>布尔运算符：</strong></p><table><thead><tr class="header"><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr class="odd"><td>!</td><td>非运算，表达式为true则返回false</td><td>[ !false ] 返回true</td></tr><tr class="even"><td>-o</td><td>或运算，有一个表达式为true，则返回true</td><td>[ $a -lt 20 -o $b -gt 100 ]</td></tr><tr class="odd"><td>-a</td><td>与运算，两个表达式都为true才返回true</td><td>[ $a -lt 20 -a $b -gt 100 ]</td></tr></tbody></table><p><strong>逻辑运算符：</strong></p><table><thead><tr class="header"><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr class="odd"><td>&amp;&amp;</td><td>逻辑的AND</td><td>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</td></tr><tr class="even"><td>||</td><td>逻辑的OR</td><td>[[ $a -lt 100</td></tr></tbody></table><p>注意：逻辑运算用的是[[ ... ]] ,[[ ... ]]是[ ... ]运算符的补充，支持逻辑运算符||,&amp;&amp;，不再使用 -a,-o</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -a <span class="variable">$b</span> -gt 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"返回 false"</span> <span class="comment">#bingo</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>字符串运算符：</strong></p><table><colgroup><col style="width: 10%"><col style="width: 67%"><col style="width: 21%"></colgroup><thead><tr class="header"><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr class="odd"><td>=</td><td>检测两个字符串是否相等，相等返回true</td><td>[ $a = $b ]</td></tr><tr class="even"><td>!=</td><td>检测两个字符串是否相等，不相等返回true</td><td>[ $a != $b]</td></tr><tr class="odd"><td>-z</td><td>检测字符串长度是否为0,为0返回true</td><td>[ -z $a ] | | -n | 检测字符串长度是否不为0,不为0返回true | [ -n &quot;$a&quot;]</td></tr><tr class="even"><td>$</td><td>检测字符串是否为空，不为空返回true</td><td>[ $a ]</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=<span class="string">'abcdefg'</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$a</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$a</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$a</span> : 字符串长度为 0"</span> <span class="comment">#bingo</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> : 字符串不为空"</span> <span class="comment">#bingo</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> : 字符串为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>注意：判断字符串长度是否为0，应该[ -n &quot;$a&quot; ]而不是[ -n $a ]</p><p><strong>文件测试运算符：</strong></p><table><thead><tr class="header"><th>操作符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr class="odd"><td>-b file</td><td>检测文件是否是块设备文件，是则返回true</td><td>[ -b $file ]</td></tr><tr class="even"><td>-c file</td><td>检测文件是否是字符设备文件，是则返回true</td><td>[ -c $file ]</td></tr><tr class="odd"><td>-d file</td><td>检测文件是否是目录，是则返回true</td><td>[ -d $file ]</td></tr><tr class="even"><td>-f file</td><td>检测文件是否是普通文件，是则返回true</td><td>[ -f $file ]</td></tr><tr class="odd"><td>-g file</td><td>检测文件是否设置了SGID位，如果是则返回true</td><td>[ -g $file ]</td></tr><tr class="even"><td>-k file</td><td>检测文件是否设置了粘着位(sticky bit)，如果是则返回true</td><td>[ -k $file ]</td></tr><tr class="odd"><td>-p file</td><td>检测文件是否是有名管道，如果是则返回true</td><td>[ -p $file ]</td></tr><tr class="even"><td>-u file</td><td>检测文件是否设置了SUID位，如果是则返回true</td><td>[ -u $file ]</td></tr><tr class="odd"><td>-r file</td><td>检测文件是否可读，如果是，则返回true</td><td>[ -r $file ]</td></tr><tr class="even"><td>-w file</td><td>检测文件是否可写，如果是，则返回true</td><td>[ -w $file ]</td></tr><tr class="odd"><td>-x file</td><td>检测文件是否可执行，如果是，则返回true</td><td>[ -x $file ]</td></tr><tr class="even"><td>-s file</td><td>检测文件是否位空（文件大小是否大于0），不为空返回true</td><td>[ -s $file ]</td></tr><tr class="odd"><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回true</td><td>[ -e $file ]</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file=<span class="string">"/var/www/runoob/test.sh"</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件存在"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="shell-指令">1.5 Shell 指令</h3><p><strong>echo指令：</strong> 用于字符串的输出，命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> string</span><br></pre></td></tr></table></figure><p>若要显示转义字符：需要用反斜线 <code>\</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"\"It is a test\""</span></span><br></pre></td></tr></table></figure><p>使用<code>-e</code>可开始转义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"OK! \n"</span> <span class="comment">#换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It is  a test</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"OK! \c"</span> <span class="comment">#不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OK! It is a test</span><br></pre></td></tr></table></figure><p>若要显示变量，则双引号内 $name ,若要原样输出，则用单引号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">read</span> name </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> It is a test"</span></span><br></pre></td></tr></table></figure><p>注意：<code>read</code>命令从标准输入读取一行，各个参数通过空格分隔，</p><p>若要将显示结果定向至文件，则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span> &gt; myfile</span><br></pre></td></tr></table></figure><p>注意：重定向：<code>&gt;&gt;</code> 重定向追加，在原文件末尾追加内容，<code>&gt;</code>重定向输出，替换原有文件内容</p><p>显示命令执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `date`</span><br></pre></td></tr></table></figure><p>注意这里用的是反引号(ESC键下方)，不是单引号</p><p><strong>printf命令：</strong> <code>printf</code>命令模仿c程序中的printf()函数,与echo相比，<code>printf</code>需要手动添加换行，其命令语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> format-string [arguments...]</span><br></pre></td></tr></table></figure><p><code>format-string</code>:为格式控制字符串 <code>arguments</code>:为输出参数列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%d %s %c %f 格式替代符详解:</span><br><span class="line">d: Decimal 十进制整数 -- 对应位置参数必须是十进制整数，否则报错！</span><br><span class="line">s: String 字符串 -- 对应位置参数必须是字符串或者字符型，否则报错！</span><br><span class="line">c: Char 字符 -- 对应位置参数必须是字符串或者字符型，否则报错！</span><br><span class="line">f: Float 浮点 -- 对应位置参数必须是数字型，否则报错！</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%d %s %c\n"</span> 1 <span class="string">"abc"</span> <span class="string">"def"</span></span><br><span class="line"><span class="comment"># 1 abc d    %c会自动截取字符串的第一个字符</span></span><br></pre></td></tr></table></figure><p><strong>shell test命令：</strong> <code>test</code>命令用于检查某个条件是否成立，它可以进行数值，字符和文件三个方面的测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件夹不存在则创建</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"/data/"</span> ];<span class="keyword">then</span></span><br><span class="line">  mkdir /data</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"文件夹已经存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="shell-流程控制">1.6 Shell 流程控制</h3><p>需要注意的是shell的流程控制不可为空</p><p><strong>if else</strong> 语法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line">..</span><br><span class="line">commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>写成一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ... ]; <span class="keyword">then</span> <span class="built_in">command</span> ; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>注意<code>;</code>后的空格。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">command1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">command2</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">commnadN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>for</strong> for循环的一般格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line">...</span><br><span class="line">commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>写成一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 ... itemN; <span class="keyword">do</span> command1; cammand2... <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure><p>也可表示为,与c语言for循环类似的形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((assignment;condition;next));<span class="keyword">do</span></span><br><span class="line">    command_1;</span><br><span class="line">    command_2;</span><br><span class="line">    commond_..;</span><br><span class="line"><span class="keyword">done</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=5;i++));<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"这是第 <span class="variable">$i</span> 次调用"</span>;</span><br><span class="line"><span class="keyword">done</span>;</span><br></pre></td></tr></table></figure><p><strong>while</strong> while循环用于不断执行一系列命令，也用于从文件中读取数据，其一般格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"int++"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>其中 <code>let</code>用于执行表达式，变量计算中不需要<code>$</code>来表示变量，也可以省略 &quot; &quot; ,例如 <code>let n++</code> 实现自加，同时<code>let</code>与 <code>expr</code>相比不需要用空格隔开各个运算的字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环读取</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'按下 &lt;CTRL-D&gt; 退出'</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">'输入你最喜欢的网站名: '</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> FILM</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"是的！<span class="variable">$FILM</span> 是一个好网站"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>until</strong> until循环执行一系列指令直至条件为true时停止，until循环与while循环在处理方式时刚好相反：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition <span class="comment">#返回值为false,则继续执行</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>case</strong> case语句匹配一个值与一个模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> val <span class="keyword">in</span></span><br><span class="line">模式1)</span><br><span class="line">command1</span><br><span class="line">...</span><br><span class="line">commandN</span><br><span class="line">;;</span><br><span class="line">模式2)</span><br><span class="line">command1</span><br><span class="line">...</span><br><span class="line">commandN</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span> <span class="comment">#倒序表示结束</span></span><br></pre></td></tr></table></figure><p>每一模式以右括号<code>)</code>结束，取值可以为变量或常数，当val与模式匹配后，执行模式到<code>;;</code>结束，其他模式将不再执行。</p><p><strong>break</strong> break允许跳出所有循环（终止执行该循环）</p><p><strong>continue</strong> continue命令与break命令相似，但是continue不会跳出所有循环，仅仅跳出当前循环。</p><h3 id="shell-函数">1.7 Shell 函数</h3><p>shell脚本中用户可以定义函数，然后在shell脚本中可以随便调用： 格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：可以function fun()定义，也可以直接fun()定义，不带任何参数；参数返回可以显示加 <code>return</code>,如果不加，将以最后一条命令运行结果，作为返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithReturn</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"这个函数会对输入的两个数字进行相加运算..."</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"输入第一个数字: "</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"输入第二个数字: "</span></span><br><span class="line">    <span class="built_in">read</span> anotherNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"两个数字分别为 <span class="variable">$aNum</span> 和 <span class="variable">$anotherNum</span> !"</span></span><br><span class="line">    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"输入的两个数字之和为 $? !"</span></span><br></pre></td></tr></table></figure><p>函数返回值在调用该函数后，通过<code>$?</code>来获得,且其只对上一条指令负责，一旦函数返回后其返回值没有立即保存到参数，那么其返回值将不再能通过<code>$?</code>获得。 注意：所有函数在使用前必须定义，即一般函数放在脚本开始的部分，调用函数时仅使用函数名即可。</p><p><strong>函数参数</strong></p><p>在shell中，调用函数时，可以向其传递参数，在函数体内部，通过<code>$n</code>的形式来获取参数的值，例如<code>$1</code>表示第一个参数。 当n&gt;=10时，需要使用<code>${n}</code>来获取参数，<code>${10}</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第一个参数为 <span class="variable">$1</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第二个参数为 <span class="variable">$2</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 <span class="variable">$10</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 <span class="variable">$&#123;10&#125;</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十一个参数为 <span class="variable">$&#123;11&#125;</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"参数总数有 <span class="variable">$#</span> 个!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"作为一个字符串输出所有参数 $* !"</span></span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><p>注意：函数或命令的执行结果可以作为条件语句，须注意的是，shell语言中函数正确执行的结果0代表true</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中的标定</title>
      <link href="/2020/04/04/apollo_calibration/"/>
      <url>/2020/04/04/apollo_calibration/</url>
      
        <content type="html"><![CDATA[<p>Apollo中的在线标定：用于获取实时外参(针对由于路面颠簸等情况造成相机位姿改变的校正)，由于在线标定算法用到车道线信息，因此此处将车道线检测的相关算法一并说明。</p><a id="more"></a><h2 id="lanedetector">LaneDetector</h2><p>算法接口文件:<code>modules/perception/camera/lib/interface/base_lane_detector.h</code> 该算法实现从图像中检测车道线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: detect lane from image.</span></span><br><span class="line"><span class="comment">// @param [in]: options</span></span><br><span class="line"><span class="comment">// @param [in/out]: frame</span></span><br><span class="line"><span class="comment">// detected lanes should be filled, required,</span></span><br><span class="line"><span class="comment">// 3D information of lane can be filled, optional.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Detect</span><span class="params">(<span class="keyword">const</span> LaneDetectorOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                    CameraFrame* frame)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="初始化">1.初始化</h3><p><strong>配置文件信息</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lane_param &#123;</span><br><span class="line">  lane_detector_param &#123;</span><br><span class="line">    plugin_param &#123;</span><br><span class="line">      name : <span class="string">"DarkSCNNLaneDetector"</span></span><br><span class="line">      root_dir : <span class="string">"/apollo/modules/perception/production/data/perception/camera/models/lane_detector/"</span></span><br><span class="line">      config_file : <span class="string">"config_darkSCNN.pt"</span></span><br><span class="line">    &#125;</span><br><span class="line">    camera_name : <span class="string">"front_6mm"</span></span><br><span class="line">  &#125;</span><br><span class="line">  lane_postprocessor_param &#123;</span><br><span class="line">    name : <span class="string">"DarkSCNNLanePostprocessor"</span></span><br><span class="line">    root_dir : <span class="string">"/apollo/modules/perception/production/data/perception/camera/models/lane_postprocessor/darkSCNN/"</span></span><br><span class="line">    config_file : <span class="string">"config.pt"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化程序</strong>： <code>ObstacleCameraPerception::Init()</code>中执行<code>InitLane()</code>进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 车道线检测初始化</span></span><br><span class="line"><span class="comment">// @param [in]: work_root:当前工作路径，通过`GetCyberWorkRoot()`可以获取</span></span><br><span class="line"><span class="comment">// @param [in]: model:相机传感器模型，通过SensorManage类加载`perception_gflags.cc`中的对应文件获取</span></span><br><span class="line"><span class="comment">// @param [in]: perception_param_:上面参数配置文件的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLane</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;work_root,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> base::BaseCameraModelPtr model,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> app::PerceptionParam &amp;perception_param)</span></span>;</span><br></pre></td></tr></table></figure><p>车道线的初始化包括两大部分，一是检测器detector初始化，二是后处理其postprocessor初始化。</p><p><strong>检测器detector初始化</strong> 由于车道线检测这里用到了网络模型，因此detector初始化过程主要加载了模型的配置文件，以及具体的功能实现类 <code>DarkSCNNLaneDetector</code>,然后同障碍物检测的detector相似 进行<code>DarkSCNNLaneDetector</code>的初始化: 需要注意的是，<code>LaneDetector</code>的实现在<code>camera/lib/lane/detector/darkSCNN</code>, 而检测器参数配置则位于<code>production/data/perception/camera/models/lane_detector</code>下。</p><blockquote><p>model_name -&gt; darkSCNN proto_flie -&gt; deploy.prototxt weight_file -&gt; deploy.caffemodel</p></blockquote><p>网络的输入输出节点名称</p><blockquote><p>input_blob : &quot;data&quot; vpt_blob : &quot;fc_out&quot; //消失点检测 seg_blob : &quot;softmax&quot; //分割输出</p></blockquote><p>根据上述参数创建网络的推断模型<code>CreateInferenceByName</code>，此处<code>cnnadapter_lane_</code>的推断模型为<code>caffe</code>,然后对此推断模型进行初始化，之前的创建过程并未将参数加载到<code>caffe</code>模型中，因此<code>cnnadapter_lane_-&gt;Init</code>将网络模型结构和网络参数导入到Caffe中。</p><p><strong>后处理器postprocessor初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lane_map_width: <span class="number">640</span></span><br><span class="line">lane_map_height: <span class="number">480</span></span><br><span class="line">roi_height: <span class="number">768</span></span><br><span class="line">roi_start: <span class="number">312</span></span><br><span class="line">roi_width: <span class="number">1920</span></span><br></pre></td></tr></table></figure><p>后处理器实现类<code>DarkSCNNLanePostprocessor</code>,该功能类的初始化加载上面所示参数，同时也加载了<code>detector</code>的部分参数(图像裁剪相关)</p><h3 id="算法实现">2. 算法实现</h3><p>算法实现的相关过程位于<code>obstacle_camera_perception.cc</code>中的<code>Perception</code>函数中,并注意车道线检测算法只工作于 <code>front_6mm</code>相机上,算法流程如下,然后分模块进行说明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Detect -&gt; Process2D(postprocessor) -&gt; Update(Calibration) -&gt; Process3D(postprocessor)</span></span><br></pre></td></tr></table></figure><h4 id="detect">2.1 Detect</h4><ul><li><p>准备图像数据，并将图像数据拷贝到input_blob中 首先对原始图像(<code>1920*1080</code>)进行裁剪，得到ROI图像，(<code>1920*1080</code>)-&gt;(<code>1920*768</code>)</p><p>由于<code>DarkSCNN</code>网络结构输出为<code>640*480</code>,所以还需要<code>resize,</code>通过GPU实现图像大小的转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 通过GPU对每个像素并行处理进行resize后的图像</span></span><br><span class="line"><span class="comment">// @param [in]: image_src_:(dataprovider提供的原始图像)</span></span><br><span class="line"><span class="comment">// @param [in/out]: input_blob(将数据拷贝到input_blob中) </span></span><br><span class="line"><span class="comment">// @param [in]: image_mean(将图像减去此均值)</span></span><br><span class="line"><span class="comment">// @note : channel_axis=fasle(input_blob:nchw src:nhwc) channel_axis=true(dst=src=nhwc)</span></span><br><span class="line">inference::ResizeGPU(</span><br><span class="line">      image_src_, input_blob, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(crop_width_), <span class="number">0</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(image_mean_[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(image_mean_[<span class="number">1</span>]),</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(image_mean_[<span class="number">2</span>]), <span class="literal">false</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">1.0</span>));</span><br></pre></td></tr></table></figure><p>通过上述程序将图像数据拷贝到了网络模型的输入input_blob中，接下来进行前向推断，获取结果。</p></li><li><p>前向推断<code>cnnadapter_lane_-&gt;Infer()</code>,获取网络模型输出。</p></li><li><p>将网络输出seg_blob数据转换到图像矩阵Mat中,其中每一个通道c代表一类车道线,然后遍历图片中每一个像素位置的类别(通道c)大于阈值<code>0.95</code>则将打上对应的类别标签，最后将处理好的像素为对应类别标签的<code>Mat</code>转换为<code>blob</code>类型</p><p><code>frame-&gt;lane_detected_blob = lane_blob_;</code>将检测数据保存到<code>frame</code>帧结构中即完成了车道线检测的数据获取任务。</p></li></ul><p>在<code>darkSCNN</code>网络中，除了输出车道线的语义分割像素位置，还同时设计了消失点检测的子网络，通过最后的全连接层输出消失点： 网络输出的消失点坐标是相对于输入图像中心的偏移，将消失点恢复到网络的输入图像中，然后再根据roi裁剪恢复到原始图像中，同样将消失点坐标保存到<code>frame</code>数据结构中，<code>frame-&gt;pred_vpt = v_point</code></p><p>通过对网络输出数据的初步处理，将检测信息保存到<code>frame</code>中，原始检测数据的获取部分就完成了，接下来进行数据的后处理。</p><h4 id="postprocess-2d">2.2 Postprocess 2D</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: detect lane from image.</span></span><br><span class="line"><span class="comment">// @param [in]: options</span></span><br><span class="line"><span class="comment">// @param [in/out]: frame</span></span><br><span class="line"><span class="comment">// detected lanes should be filled, required,</span></span><br><span class="line"><span class="comment">// 3D information of lane can be filled, optional.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Process2D</span><span class="params">(<span class="keyword">const</span> LanePostprocessorOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">               CameraFrame* frame)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><p>该部分主要通过检测器得到的语义分割信息提取车道线，车道线的数据结构为<code>modules/perception/base/lane_struct.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LaneLine</span> &#123;</span></span><br><span class="line">  LaneLineType type;</span><br><span class="line">  <span class="comment">// @brief laneline position -&gt; 13</span></span><br><span class="line">  LaneLinePositionType pos_type;</span><br><span class="line">  <span class="comment">// @brief image coordinate system</span></span><br><span class="line">  LaneLineCubicCurve curve_car_coord;</span><br><span class="line">  <span class="comment">// @brief camera coordinate system</span></span><br><span class="line">  LaneLineCubicCurve curve_camera_coord;</span><br><span class="line">  <span class="comment">// @brief image coordinate system</span></span><br><span class="line">  LaneLineCubicCurve curve_image_coord;</span><br><span class="line">  <span class="comment">// @brief curve image point set</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point2DF&gt; curve_image_point_set;</span><br><span class="line">  <span class="comment">// @brief curve camera point set</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point3DF&gt; curve_camera_point_set;</span><br><span class="line">  <span class="comment">// @brief curve car coord point set, only on XY plane</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point2DF&gt; curve_car_coord_point_set;</span><br><span class="line">  <span class="comment">// @brief image end point set</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;EndPoints&gt; image_end_point_set;</span><br><span class="line">  <span class="comment">// @brief track id</span></span><br><span class="line">  <span class="keyword">int</span> track_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// @brief confidence for lane line</span></span><br><span class="line">  <span class="keyword">float</span> confidence = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">  LaneLineUseType use_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>车道线检测过程可以分为四个阶段：</p><ul><li><p>检测车道线边界，以车辆为中心，左侧的车道线提取右边界，右侧的车道线提取左边界。</p></li><li><p>根据提取的边界线点通过<code>ransac</code>采样去除离群点。 首先确定车道线拟合方程<span class="math inline">\(y=ax^3+bx^2+cx+d\)</span>,因此通过<code>ransac</code>确定车道线方程程序中至少需要8个点。 程序中貌似仅仅拟合了二阶(b,c,d)？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 拟合边界点,去除离群值</span></span><br><span class="line"><span class="comment">// @param [in]: pos_vec(地平面下的边界点)</span></span><br><span class="line"><span class="comment">// @param [in/out]: selected_points(去除离群值之后的边界点)</span></span><br><span class="line"><span class="comment">// @param [in]: coeff(多项式系数,a,b,c,d)</span></span><br><span class="line"><span class="comment">// @param [in]: N(所需的最少点数minNumPoints=8)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RansacFitting</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Eigen::Matrix&lt;Dtype, <span class="number">2</span>, <span class="number">1</span>&gt;&gt;&amp; pos_vec,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Eigen::Matrix&lt;Dtype, <span class="number">2</span>, <span class="number">1</span>&gt;&gt;* selected_points,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Eigen::Matrix&lt;Dtype, <span class="number">4</span>, <span class="number">1</span>&gt;* coeff, <span class="keyword">const</span> <span class="keyword">int</span> max_iters = <span class="number">100</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>, Dtype inlier_thres = <span class="number">0.1</span>)</span></span></span><br></pre></td></tr></table></figure></li><li><p>[1]对某些特殊情形下的车道线类型进行置换（比如车辆压在边界线上，或者已经到达左右边界），然后开始向<code>LaneLine</code>数据类型中填充数据。 [2]填充对应13种车道线类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;base::LaneLinePositionType, <span class="keyword">int</span>&gt; spatialLUTind = &#123;</span><br><span class="line">    &#123;base::LaneLinePositionType::UNKNOWN, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::FOURTH_LEFT, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::THIRD_LEFT, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::ADJACENT_LEFT, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::EGO_LEFT, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::EGO_CENTER, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::EGO_RIGHT, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::ADJACENT_RIGHT, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::THIRD_RIGHT, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::FOURTH_RIGHT, <span class="number">9</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::OTHER, <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::CURB_LEFT, <span class="number">11</span>&#125;,</span><br><span class="line">    &#123;base::LaneLinePositionType::CURB_RIGHT, <span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>[3]根据拟合的车道线曲线，x=3时对应的y值判断车道线是否无效(即车道线的排列顺序对应y值应有的顺序)。 [4]将车道线参数值添加到车道线数据结构<code>LaneLine</code>中，并将此数据添加到<code>Frame</code>中 <code>frame-&gt;lane_objects.push_back(cur_object);</code> [5]针对车辆位于左边或者右边的车道线上，修改对应一边的车道线的类型标签。</p></li></ul><h4 id="postprocess-3dprocess3d之前进行了calibration-service-中相机状态的更新">2.3 Postprocess 3D（Process3D之前进行了Calibration Service 中相机状态的更新）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// convert image point to the camera coordinate</span></span><br><span class="line"><span class="comment">// &amp; fit the line using polynomial</span></span><br><span class="line"><span class="comment">// @param :options(same as process 2D),frame</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Process3D</span><span class="params">(<span class="keyword">const</span> LanePostprocessorOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">               CameraFrame* frame)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>ConvertImagePoint2Camera(frame)</code>将车道线坐标转换到相机坐标系 利用<code>Calibration Service</code>校正过的<code>pitch</code>角度，以及相机到地平面的高度<code>camera_ground_height</code> 结合内参：<ul><li><code>ImagePoint2Camera(image_point,..) return camera_point3d</code>,相机高度可用于计算由于距离未知所引入的尺度因子(齐次坐标同时乘以一个系数，坐标不变)</li></ul></li><li><code>PolyFitCameraLaneLine(frame)</code> 使用多项式拟合相机坐标系下的车道线<ul><li><code>PolyFit(camera_pos_vec,...) return camera_coeff</code> 通过QR分解(eigen 3)进行线性最小二乘求解。</li></ul></li></ul><hr><h2 id="calibration_service">Calibration_service</h2><p>算法接口文件<code>modules/perception/camera/lib/interface/base_calibration_service.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief query camera to world pose with refinement if any</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">QueryCameraToWorldPose</span><span class="params">(Eigen::Matrix4d *pose)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @brief query depth on ground plane given pixel coordinate</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">QueryDepthOnGroundPlane</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> *depth)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @brief query 3d point on ground plane given pixel coordinate</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">QueryPoint3dOnGroundPlane</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Eigen::Vector3d *point3d)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @brief query ground plane in camera frame, parameterized as</span></span><br><span class="line">  <span class="comment">// [n^T, d] with n^T*x+d=0   ax+by+cz+d=0,法向量 n=(a,b,c)</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">QueryGroundPlaneInCameraFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Eigen::Vector4d *plane_param)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @brief query camera to ground height and pitch angle</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">QueryCameraToGroundHeightAndPitchAngle</span><span class="params">(<span class="keyword">float</span> *<span class="built_in">height</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">float</span> *pitch)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">QueryCameraToGroundHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.f</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">QueryPitchAngle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.f</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @brief using calibrator to update pitch angle</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(CameraFrame *frame)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @brief set camera height, pitch and project matrix</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetCameraHeightAndPitch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">float</span>&gt; &amp;name_camera_ground_height_map,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">float</span>&gt; &amp;name_camera_pitch_angle_diff_map,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">float</span> &amp;pitch_angle_master_sensor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>OnCalibrationService</code>通过车道线进行在线标定，标定参数主要包含了相机的高度和pitch角度。</p><p>同时，标定服务实际对应的<code>calibrator</code>方法的接口为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCalibrator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// @brief: refine 3D location of detected obstacles.</span></span><br><span class="line">  <span class="comment">// @param [in]: options</span></span><br><span class="line">  <span class="comment">// @param [in/out]: pitch_angle</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Calibrate</span><span class="params">(<span class="keyword">const</span> CalibratorOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> *pitch_angle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;  <span class="comment">// class BaseCalibrator</span></span><br></pre></td></tr></table></figure><p>该接口根据检测得到的车道线信息以及相机到世界坐标系的位姿变换矩阵，在线标定相机<code>pitch</code>轴角度，并最终用于障碍物3D位置的改善。</p><h3 id="初始化-1">1. 初始化</h3><p><strong>配置文件与配置信息</strong> <code>modules/perception/production/conf/perception/camera/obstacle.pt</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">calibration_service_param &#123;</span><br><span class="line">  plugin_param &#123;</span><br><span class="line">      name : <span class="string">"OnlineCalibrationService"</span></span><br><span class="line">      root_dir : <span class="string">""</span></span><br><span class="line">      config_file : <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  calibrator_method : <span class="string">"LaneLineCalibrator"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CalibrationServiceInitOptions</span> :</span> <span class="keyword">public</span> BaseInitOptions &#123;</span><br><span class="line">  <span class="keyword">int</span> image_width = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> image_height = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> timestamp = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> calibrator_working_sensor_name = <span class="string">""</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> calibrator_method = <span class="string">""</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Eigen::Matrix3f&gt; name_intrinsic_map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>初始化程序</strong>： 在<code>ObstacleCameraPerception::Init()</code>中进行初始化<code>InitCalibrationService</code> 初始化过程配置在线标定的传感器为<code>front_6mm</code>,配置标定方法为:<code>LaneLineCalibrator</code>,同时加载内参矩阵和图像宽高,根据<code>plugin_param</code>中的<code>name</code>确定<code>calibration_service_</code>指向的算法实现类为<code>OnlineCalibrationService</code>。 在<code>OnlineCalibrationService::Init()</code>初始化过程中，进行标定方法<code>LaneLineCalibrator</code>的初始化,然后在初始过程中又进行了更底层实现<code>lane_based_calibrator</code>的初始化，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 标定方法初始化，loal_options包括（图像的宽高以及相机内参f_x,f_y,c_x,c_y）</span></span><br><span class="line">calibrator_.Init(local_options)</span><br></pre></td></tr></table></figure><p>在<code>LaneLineCalibrator</code>初始过程中进行<code>HistogramEstimator</code>的初始化（<strong>注：默认参数在构造函数中加载</strong>）</p><h3 id="算法实现-1">2. 算法实现</h3><h4 id="online_calibration_serviceupdate">2.1 Online_Calibration_Service::Update</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief using calibrator to update pitch angle</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(CameraFrame *frame)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><p>该方法通过创建<code>calibrator</code>进行相机pitch角度的校正，<code>calibrator</code>的配置信息包括:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CalibratorOptions</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::LaneLine&gt;&gt; lane_objects; <span class="comment">//车道线检测检测信息</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Eigen::Affine3d&gt; camera2world_pose; <span class="comment">//相机到世界坐标系的转换矩阵</span></span><br><span class="line">  <span class="keyword">double</span> *timestamp = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后根据车道线检测信息和位姿变换矩阵，在线标定pitch轴角度：</p><h5 id="lanelinecalibratorcalibrate">2.1.1 LaneLineCalibrator::Calibrate</h5><p><code>bool updated = calibrator_-&gt;Calibrate(calibrator_options, &amp;pitch_angle)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: estimate camera-ground plane pitch.</span></span><br><span class="line"><span class="comment">// @param [in]: options (包括车道线检测信息，相机到世界坐标系的转换矩阵)</span></span><br><span class="line"><span class="comment">// @param [in/out]: pitch_angle</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Calibrate</span><span class="params">(<span class="keyword">const</span> CalibratorOptions &amp;options, <span class="keyword">float</span> *pitch_angle)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>LoadEgoLaneline()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: load ego lane line from camera frame (获取车辆所在的车道线，用于标定)</span></span><br><span class="line"><span class="comment">// @param [in]: lane_objects (from model fitting)</span></span><br><span class="line"><span class="comment">// @param [out]: ego_lane (ego left_line,ego right_line)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LoadEgoLaneline</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::LaneLine&gt; &amp;lane_objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                       EgoLane *ego_lane)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>上述程序处理中存在问题，lane_objects.curve_image_coord并没有相关赋值，不知道它为何直接用了</strong></p></li><li><p><code>GetYawVelocityInfo()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 获取车辆速度和yaw轴角度变化率</span></span><br><span class="line"><span class="comment">// @param [in]: time_diff(两帧时间差),cam_coord_cur(当前相机在世界坐标系下位置)</span></span><br><span class="line"><span class="comment">// @param [in]: cam_coord_pre(上一帧相机在世界坐标下位置),cam_coord_pre_pre()</span></span><br><span class="line"><span class="comment">// @param [out]: yaw_rate(yaw角度变化率),velocity(车速)</span></span><br><span class="line"><span class="comment">// @note: 车辆速度通过两帧时间差的相机位置变化确定，yaw通过世界坐标系下相机位置计算得到</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetYawVelocityInfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> &amp;time_diff, <span class="keyword">const</span> <span class="keyword">double</span> cam_coord_cur[<span class="number">3</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">double</span> cam_coord_pre[<span class="number">3</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">double</span> cam_coord_pre_pre[<span class="number">3</span>], <span class="keyword">float</span> *yaw_rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">float</span> *velocity)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>LaneBasedCalibrator::Process()</code> 计算pitch_estimation,vanishing_row</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: Main function. process every frame, return true if get valid</span></span><br><span class="line"><span class="comment">// estimation. suppose the points in lane are already sorted.</span></span><br><span class="line"><span class="comment">// @param [in]: ego_lane(车辆所在车道线的左右车道线)</span></span><br><span class="line"><span class="comment">// @param [in]: velocity(相机世界坐标系下的速度)</span></span><br><span class="line"><span class="comment">// @param [in]: yaw_rate(相机世界坐标系下yaw变化率)</span></span><br><span class="line"><span class="comment">// @param [in]: time_diff(两帧之间的时间差) </span></span><br><span class="line"><span class="comment">// @out : pitch_estimation_, vanishing_row_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Process</span><span class="params">(<span class="keyword">const</span> EgoLane &amp;lane, <span class="keyword">const</span> <span class="keyword">float</span> &amp;velocity,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> <span class="keyword">float</span> &amp;yaw_rate, <span class="keyword">const</span> <span class="keyword">float</span> &amp;time_diff)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>IsTravelingStraight()</code>判断当前yaw变化率是否小于3°，即判断是否直线行驶，若不为直线行驶，则不进行处理,return false。</p></li><li><code>GetVanishingPoint()</code>根据ego Lane车道线获取消失点<code>vp_cur</code><ul><li><code>SelectTwoPointsFromLineForVanishingPoint(egoleftline/rightline)</code> 使用ego line的部分(或全部)线段，返回线段的起止索引。</li><li><code>GetIntersectionFromTwoLineSegment()</code>使用上面的车道线线段获取消失点，即计算两条直线延长线的交点。 ref:https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect</li></ul></li><li><p><code>PushVanishingPoint()</code>将<code>vp_cur</code>添加到<code>vp_buffer_</code>中，<code>vp_buffer_</code>中最大容量1000，最先检测到的位于最后</p></li><li><p><code>PopVanishingPoint()</code>计算<code>vp_buffer</code>累计前行的距离，判断是否大于最低前行距离要求(20m),若满足则将末尾（最新）的消失点提出来使用-&gt;<code>vp_work</code></p></li><li><p><code>GetPitchFromVanishingPoint()</code>根据<code>vp_work</code>估计相机<code>Pitch</code>角度-&gt;<code>pitch_cur_</code> 空间中一条直线的消失点是一条与该直线平行且经过相机光心的射线与像平面的交点,由于车道线与地平面水平，因此可计算pitch(与地平面夹角)</p></li><li><p><code>AddPitchToHistogram()</code>将pitch_cur添加到hist中。</p><ul><li><code>HistogramEstimator::Push(pitch_cur_)</code>,首先需要注意用于标定的直方图参数的设置是在 <code>CalibratorParams::Init()</code>中，通过将(-10,10°)区间平分为400份，然后计算输入的<code>pitch_cur_</code>所在区间的位置，并将该位置的计数值加1<code>hist_[index]++</code>。(直方图的数据分组数量为bin)</li></ul></li><li><p><code>HistogramEstimator::Process()</code> 当累计前行距离大于100m时，进行标定值的更新，流程可以概括为： <code>smooth -&gt; get peak &amp; check mass -&gt; shape analysis -&gt; update estimate -&gt; final decay</code>。</p><ul><li><p><code>Smooth(hist,nr_bins,hist_smoothed)</code> hist为之前添加的pitch角度计数，nr_bins为数据分组数量。原统计的直方图存在锯齿状波动，对直方图通过核&lt;1,3,5,3,1&gt;进行平滑以方便确定波峰和波谷。<code>hist_smoothed</code></p></li><li><p><code>GetPeakIndexAndMass(hist_smoothed,nr_bins,max_index,mass)</code> 获得波峰对应的索引(表示该计算得到的pitch数量最多)以及所有计数值之和<code>mass</code>,若<code>mass</code>即对应采样点的个数少于100，则缺少足够数据。</p></li><li><p><code>IsGoodShape(hist,nr_bins,max_index)</code>，对应于初始化时的先验<code>hist_hat_</code>判断当前的直方图形状是否正常 <span class="math display">\[hist\_hat(i)=e^{-\frac{(x-200)^2}{2\sigma ^2}}\ i\in[0,400],\sigma=6.25\]</span> <img src="/2020/04/04/apollo_calibration/C:/Users\jia_z\Desktop\blogrepo\source\_posts\apollo_calibration\hist_hat.jpg" style="zoom:30%;"></p><p>判断标准<span class="math inline">\(hist(i)&gt;hist(max\_index)\times hist\_hat(i-(max\_index-200))\)</span> 则认为直方图形状<strong>不符合</strong>要求。</p></li><li><code>GetValFromIndex(max_index)</code> 将对应直方图的索引值转换为角度值-&gt;<code>val_estimation</code></li><li><p><code>Decay(hist,nr_bins)</code> 将直方图中的技术值逐步衰减 * 0.8908987</p></li></ul></li></ul></li></ul><blockquote><p>总的来说，获取各个消失点所要求的最低直行距离为20m,而通过各个消失点计算的pitch角度更新标定值所需最低直行距离为100m,但是需要注意的是，一旦行驶过程中，出现不是直行的状态，则消失点缓存即刻清零，而用于更新标定值的累计前行距离只有到达可更新的阈值才会清零，不会因为没有直行而清零。</p></blockquote><p>通过上述标定得到的pitch角度，校正相机<code>CameraStatus</code> 其中相机状态(camera_status)主要包含以下信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraStatus</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> camera_ground_height = <span class="number">-1.f</span>;</span><br><span class="line">  <span class="keyword">float</span> pitch_angle = <span class="number">0.f</span>;</span><br><span class="line">  <span class="keyword">float</span> pitch_angle_diff = <span class="number">0.f</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; k_matrix = &#123;<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ground_plane = &#123;<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name_camera_status_map_[master_sensor_name_].pitch_angle = pitch_angle;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = name_camera_status_map_.<span class="built_in">begin</span>();</span><br><span class="line">         iter != name_camera_status_map_.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">      <span class="comment">// update pitch angle</span></span><br><span class="line">      iter-&gt;second.pitch_angle =</span><br><span class="line">          iter-&gt;second.pitch_angle_diff + iter-&gt;second.pitch_angle;</span><br><span class="line">      <span class="comment">// update ground plane param</span></span><br><span class="line">      iter-&gt;second.ground_plane[<span class="number">1</span>] = <span class="built_in">cos</span>(iter-&gt;second.pitch_angle);</span><br><span class="line">      iter-&gt;second.ground_plane[<span class="number">2</span>] = -<span class="built_in">sin</span>(iter-&gt;second.pitch_angle);</span><br></pre></td></tr></table></figure><h2 id="supplement-material">supplement material</h2><p>网络结构SCNN :https://arxiv.org/pdf/1712.06080.pdf</p><hr><h2 id="参考文章">参考文章</h2><blockquote><p>[1]崔洪柳. 基于车道线检测的车载摄像机在线标定算法[D].东北大学,2015.</p><p>多传感器标定：https://gitchat.blog.csdn.net/article/details/94420885</p><p>传感器标定: https://blog.csdn.net/m0_38087936/article/details/88536345</p></blockquote><h3 id="单应性矩阵">单应性矩阵</h3><p>由外参计算得到单应性矩阵 <code>visualizer</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get homography from projection matrix</span></span><br><span class="line"><span class="comment">// ====</span></span><br><span class="line"><span class="comment">// Version 1. Direct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the homography matrix, such that H [u, v, 1]' ~ [X_l, Y_l, 1]</span></span><br><span class="line">Eigen::Matrix3d R = adjusted_camera2car_.block(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">Eigen::Vector3d T = adjusted_camera2car_.block(<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">Eigen::Matrix3d H;</span><br><span class="line">Eigen::Matrix3d H_inv;</span><br><span class="line"></span><br><span class="line">H.block(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>) = (K_ * R.transpose()).block(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">H.block(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>) = -K_ * R.transpose() * T;</span><br><span class="line">H_inv = H.inverse();</span><br><span class="line">homography_ground2image_ = H;</span><br><span class="line">homography_image2ground_ = H_inv;</span><br></pre></td></tr></table></figure><p>https://blog.csdn.net/ganguowa/article/details/60765691</p><h3 id="相机畸变校正brown模型">相机畸变校正　Brown模型</h3><p>在摄影测量和计算机视觉中都需要对含有畸变的影像进行改正操作，常用到的模型是对透视影像改正的Brown模型</p><h3 id="计算两直线交点坐标车道线消失点">计算两直线交点坐标（车道线消失点）</h3><p>https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect</p><h3 id="地平面参数和相机pitch角度之间的关系">地平面参数和相机pitch角度之间的关系</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter-&gt;second.ground_plane[<span class="number">1</span>] = <span class="built_in">cos</span>(iter-&gt;second.pitch_angle);</span><br><span class="line">iter-&gt;second.ground_plane[<span class="number">2</span>] = -<span class="built_in">sin</span>(iter-&gt;second.pitch_angle);</span><br></pre></td></tr></table></figure><p><strong>多传感器标定：</strong></p><p>https://blog.csdn.net/qq_41204464/article/details/102945454</p>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
            <tag> 标定 </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo坐标转换组件</title>
      <link href="/2020/04/04/apollo-transfom_wrapper/"/>
      <url>/2020/04/04/apollo-transfom_wrapper/</url>
      
        <content type="html"><![CDATA[<p>Apollo 中的坐标转换组件 Transform和感知部分transform wrapper的相关内容</p><a id="more"></a><p>Transform部分的文件依赖关系如下： `third_party/tf2(ros) -&gt; modules/transform -&gt; perception/onboard/transform_wrapper</p><p>Tranform组件的原型为<code>ros/tf2</code>包，本文首先介绍modules/transrom组件的相关内容，然后针对感知部分介绍 transform_wrapper的相关功能。</p><h2 id="static-transform-component">1 Static Transform Component</h2><p>转换关系存在静态(static)和动态转换，所谓静态转换，即转换关系是固定的，一般是物体之间是刚性连接，位置不会发生改变，这样的转换关系正常只需要发送一次即可；而对于动态转换关系，需要实时的发布自己的转换关系，涉及到时间戳的问题(比如由于车辆运动，则世界坐标系下车辆的位置一直在变化)。</p><p>组件结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTransformComponent</span> <span class="title">final</span> :</span> <span class="keyword">public</span> apollo::cyber::Component&lt;&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  StaticTransformComponent() = <span class="keyword">default</span>;</span><br><span class="line">  ~StaticTransformComponent() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SendTransforms</span><span class="params">()</span></span>; <span class="comment">//发送变换</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SendTransform</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TransformStamped&gt;&amp; msgtf)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ParseFromYaml</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; file_path, TransformStamped* transform)</span></span>; <span class="comment">//从yaml中解析数据</span></span><br><span class="line"></span><br><span class="line">  apollo::static_transform::Conf conf_; <span class="comment">//pb.txt配置文件</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;cyber::Writer&lt;TransformStampeds&gt;&gt; writer_; <span class="comment">//消息发布句柄</span></span><br><span class="line">  TransformStampeds transform_stampeds_; <span class="comment">//外参数格式定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="配置文件">1.1 配置文件</h3><p>​ 首先来看该组件的文件结构和配置文件的信息：</p><ul><li><p><code>transform.proto</code></p><p>对应着内外参配置文件的参数组成，例如<code>modules/perception/data/params/front_6mm_extrinsics.yaml</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> apollo.common.Point3D translation = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> apollo.common.Quaternion rotation = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">TransformStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">string</span> child_frame_id = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">optional</span> Transform transform = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">TransformStampeds</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> TransformStamped transforms = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>static_transform_conf.proto</code> 对应着所有静态转换的外参文件路径,例如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ExtrinsicFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">string</span> frame_id = <span class="number">1</span>; # destination sensor</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">string</span> child_frame_id = <span class="number">2</span>; # source sensor</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">string</span> file_path = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">bool</span> enable = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Conf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">repeated</span> ExtrinsicFile extrinsic_file = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体包含各传感器外参配置路径的文件为：<code>modules/transform/conf/static_transform_conf.pb.txt</code></p><p><strong>外参是在 destination sensor 下 source sensor的坐标，但是对应的是将source sensor下的检测信息转换到destination sensor下</strong></p></li></ul><h3 id="static-tf-初始化">1.2 Static TF 初始化</h3><p><strong>Init()</strong></p><p>初始化部分根据<code>dag</code>文件中的配置文件<code>static_transform_conf.pb.txt</code>进行参数的相应初始化，然后创建消息发布的句柄<code>node_-&gt;CreateWriter&lt;TransformStampeds&gt;(attr)</code> ,消息发布的格式为<code>transform.proto</code>中<code>TransformStampeds</code>,消息的通道名称由<code>adapter_gflags.cc</code>中的标志位确定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_string(tf_static_topic, <span class="string">"/tf_static"</span>, <span class="string">"Transform static topic."</span>);</span><br></pre></td></tr></table></figure><ul><li><p><strong>SendTransforms()</strong></p><p>对<code>static_transform_conf.pb.txt</code>中所有的外参文件路径进行遍历，并解析对应的外参文件(.yaml)将对应的参数广播。</p><ul><li><p><code>PraseFromYaml(extrinsic_file.file_path,&amp;transform)</code> ,将解析的参数对应到发布消息的格式数据类型中。</p></li><li><p><code>SendTransform(transform_stamped_vec)</code> ,transfrom_stamped_vec为yaml解析得到的各外参文件的参数，将源传感器(child_frame_id)不同的外参添加到<code>transfrom_stampeds_</code>, 通过该重构的函数发布到<code>/tf_static</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer_-&gt;Write(<span class="built_in">std</span>::make_shared&lt;TransformStampeds&gt;(transform_stampeds_));</span><br></pre></td></tr></table></figure><p>这里需要注意的是，child_frame_id一样的外参会被覆盖，child_frame_id不一样的外参会新建，所以要在写yaml外参文件时要注意不同传感器的child_fram_id不能重复，且child_frame_id以yaml中的为准。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it_in = msgtf.<span class="built_in">begin</span>(); it_in != msgtf.<span class="built_in">end</span>(); ++it_in) &#123;</span><br><span class="line">  <span class="keyword">bool</span> match_found = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it_msg : *transform_stampeds_.mutable_transforms()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it_in-&gt;child_frame_id() == it_msg.child_frame_id()) &#123;</span><br><span class="line">      it_msg = *it_in; <span class="comment">//child_frame_id 一致则会覆盖</span></span><br><span class="line">      match_found = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!match_found) &#123;</span><br><span class="line">    *transform_stampeds_.add_transforms() = *it_in;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/04/04/apollo-transfom_wrapper/transform.jpg" style="zoom: 33%;"></p><p>​ 图片来源于：https://github.com/daohu527/Dig-into-Apollo/tree/master/transform</p></li></ul><h2 id="transform_broadcaster">2 transform_broadcaster</h2><p>各个模块通过广播的方式发布动态变换，<code>transform broadcaster</code>提供了用于发布坐标转换信息的函数，其并没有作为一个单独的组件运行，而是编译为一个lib库供其他程序调用。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># `modules/transform/BUILD`</span><br><span class="line">cc_library(</span><br><span class="line">    name = <span class="string">"transform_broadcaster_lib"</span>,</span><br><span class="line">    srcs = [</span><br><span class="line">        <span class="string">"transform_broadcaster.cc"</span>,</span><br><span class="line">    ],</span><br><span class="line">    hdrs = [</span><br><span class="line">        <span class="string">"transform_broadcaster.h"</span>,</span><br><span class="line">    ],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">"//cyber"</span>,</span><br><span class="line">        <span class="string">"//modules/common/adapters:adapter_gflags"</span>,</span><br><span class="line">        <span class="string">"//modules/transform/proto:transform_proto"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>该功能类包含了三个函数： 构造函数<code>TransformBroadcaster()</code>，消息发布函数<code>SendTransform(transform)</code>,<code>SendTransform(transforms)</code></p><ul><li><p><code>TransformBroadcaster(&amp;node)</code>:构造函数需要传入<code>cyber::Node</code>节点，用于通过该传入的节点发布信息，发布通道为定义在<code>adapter_gflags.cc</code>中的<code>/tf</code>，发布消息的格式为<code>TransformStampeds</code>（定义于<code>transform.proto</code>中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer_ = node_-&gt;CreateWriter&lt;TransformStampeds&gt;(attr);</span><br></pre></td></tr></table></figure></li><li><p><code>SendTransform(transform)</code>:将<code>TransformStamped</code>格式的消息添加到向量<code>TransformStampeds</code>中，然后通过writer发布。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TransformBroadcaster::SendTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TransformStamped&gt;&amp; transforms)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> message = <span class="built_in">std</span>::make_shared&lt;TransformStampeds&gt;();</span><br><span class="line">  *message-&gt;mutable_transforms() = &#123;transforms.<span class="built_in">begin</span>(), transforms.<span class="built_in">end</span>()&#125;;<span class="comment">//将已有信息添加到message</span></span><br><span class="line">  writer_-&gt;Write(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="buffer">3 Buffer</h2><p>​ <code>buffer</code>提供了一个工具类给其他模块，主要作用是接收<code>/tf</code>和<code>/tf_static</code>通道的消息，并保持在buffer中，提供给其它节点进行查找和转换到对应的坐标系，buffer类继承了<code>BufferInterface</code>和<code>tf2::BufferCore</code>类。</p><h3 id="bufferinterface">3.1 BufferInterface</h3><p>​ 定义了Buffer类的接口，拓展了TFCore类和TFCpp 类，主要接口函数有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** \brief Get the transform between two frames by frame ID.</span></span><br><span class="line"><span class="comment">   * \param target_frame The frame to which data should be transformed</span></span><br><span class="line"><span class="comment">   * \param source_frame The frame where the data originated</span></span><br><span class="line"><span class="comment">   * \param time The time at which the value of the transform is desired. (0</span></span><br><span class="line"><span class="comment">   *will get the latest)</span></span><br><span class="line"><span class="comment">   * \param timeout How long to block before failing</span></span><br><span class="line"><span class="comment">   * \return The transform between the frames</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Possible exceptions tf2::LookupException, tf2::ConnectivityException,</span></span><br><span class="line"><span class="comment">   * tf2::ExtrapolationException, tf2::InvalidArgumentException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> TransformStamped <span class="title">lookupTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; target_frame, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; source_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> cyber::Time&amp; time, <span class="keyword">const</span> <span class="keyword">float</span> timeout_second = <span class="number">0.01f</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** \brief Test if a transform is possible</span></span><br><span class="line"><span class="comment">   * \param target_frame The frame into which to transform</span></span><br><span class="line"><span class="comment">   * \param source_frame The frame from which to transform</span></span><br><span class="line"><span class="comment">   * \param time The time at which to transform</span></span><br><span class="line"><span class="comment">   * \param timeout How long to block before failing</span></span><br><span class="line"><span class="comment">   * \param errstr A pointer to a string which will be filled with why the</span></span><br><span class="line"><span class="comment">   * transform failed, if not nullptr</span></span><br><span class="line"><span class="comment">   * \return True if the transform is possible, false otherwise</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canTransform</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; target_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; source_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> cyber::Time&amp; time,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">float</span> timeout_second = <span class="number">0.01f</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="built_in">std</span>::<span class="built_in">string</span>* errstr = <span class="literal">nullptr</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transform, advanced api, with pre-allocation</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T&amp; <span class="title">transform</span><span class="params">(<span class="keyword">const</span> T&amp; in, T&amp; out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; target_frame,  <span class="comment">// NOLINT</span></span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> cyber::Time&amp; target_time, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fixed_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">float</span> timeout = <span class="number">0.0f</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do the transform</span></span><br><span class="line">    tf2::doTransform(</span><br><span class="line">        in, out,</span><br><span class="line">        lookupTransform(target_frame, target_time, tf2::getFrameId(in),</span><br><span class="line">                        tf2::getTimestamp(in), fixed_frame, timeout));</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上仅列出每种功能的一个实现方法，主要就是实现了两种功能<code>lookupTransform</code>查找转换关系,<code>canTransform</code>是否可以转换</p><h3 id="buffer-1">3.2 buffer</h3><p>除了上面的<code>BufferInterface</code>类，buffer还继承了ros/tf2中的<code>tf2:：BufferCore</code>。需要注意buffer为单例模式创建，接收转换消息，当其他模块用到转换时，从buffer中查询是否存在转换关系，并返回相应的转换。</p><ul><li><p><strong>Buffer::Init()</strong> :<code>buffer</code>初始化，创建了节点<code>node_</code>，节点名称为 <code>&quot;transform_listener_&quot; + std::to_string(cyber::Time::Now().ToNanosecond())</code></p><p>在该节点上首先创建了<code>Reader</code>用于监听<code>/tf</code>通道发布的动态坐标转换的消息。 同时又创建了一个<code>Reader</code>用于监听<code>/tf_static</code>通道发布的静态坐标信息。 回调函数均为<code>void Buffer::SubscriptionCallbackImpl(...,is_static)</code> is_static用于表示是否是静态坐标。</p></li><li><p><strong>Buffer::SubscriptionCallbackImpl()</strong>: 回调函数，接收处理<code>/tf</code> <code>/tf_static</code>通道的信息 首先判断如果当前时刻小于上次更新的时刻，说明发生了跳变，此时清空TF buffer，然后重新加载静态转换关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (now.ToNanosecond() &lt; last_update_.ToNanosecond()) &#123;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Detected jump back in time. Clearing TF buffer."</span>;</span><br><span class="line">  <span class="built_in">clear</span>();</span><br><span class="line">  <span class="comment">// cache static transform stamped again.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; msg : static_msgs_) &#123;</span><br><span class="line">    setTransform(msg, authority, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">//正常执行应该不会触发，如果是多线程则可能触发</span></span><br></pre></td></tr></table></figure><p>然后从监听到的<code>&lt;Transformateds&gt;</code>(transorm.proto)格式的消息中提取<code>header</code>,<code>child_frame_id</code>,<code>transform</code>等信息转存到<code>geometry_msgs::TransformStamped</code>(tf2格式)中（临时保存到trans_stamped），如果是静态坐标转换，则将信息添加到<code>static_msgs_</code>列表中保存,用于开始检查的时候重置时，重新加载静态转换关系时使用。</p><ul><li><p><strong>BufferCore::setTransform(trans_stamped,authority,is_static)</strong> 调用tf2的函数，保存转换关系到<code>cache</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TimeCacheInterfacePtr frame = getFrame(frame_number);</span><br><span class="line">    <span class="keyword">if</span> (frame == <span class="literal">NULL</span>) frame = allocateFrame(frame_number, is_static);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;insertData(TransformStorage(</span><br><span class="line">            stripped, lookupOrInsertFrameNumber(stripped.header.frame_id),</span><br><span class="line">            frame_number))) &#123;</span><br><span class="line">      frame_authority_[frame_number] = authority;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这部分基本都是调用的tf2包中的函数实现，而buffer相当于一个接口。</p></li><li><strong>Buffer::canTransform</strong> 在超时时间<code>timeout_second</code>时间范围内，每3000us执行下列函数查询是否有可用的Transform<ul><li><strong>BufferCore::canTransform</strong></li></ul></li><li><strong>Buffer::lookupTransform</strong><ul><li><strong>BufferCore::lookupTransform</strong> 返回tf2_trans_stamped</li><li><strong>Buffer::TF2MsgToCyber(tf2_trans_stamped,trans_stamped)</strong> 将tf2格式的信息转换为proto格式的信息</li></ul></li></ul><p><img src="/2020/04/04/apollo-transfom_wrapper/all.jpg" alt="图片来源于https://github.com/daohu527/Dig-into-Apollo/tree/master/transform" style="zoom:50%;"></p><p>动态转换主要是关于世界坐标系到本地坐标系的转换，实现于定位模块中，而各传感器之间的转换主要是静态转换，动态转换和静态转换最后同意由buffer管理，需要用到转换关系的模块通过查询接口获得对应的转换关系。</p></li></ul><h2 id="transform-wrapper">4 Transform Wrapper</h2><p>从该函数的<code>BUILD</code>文件中可以知道该函数文件依赖于<code>//modules/transform:tf2_buffer_lib</code> ，将感知部分用到的坐标转化关系的获取进行了进一步封装(封装了Buffer*),实现的功能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Attention: must initialize TransformWrapper first</span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">GetSensor2worldTrans</span><span class="params">(<span class="keyword">double</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Eigen::Affine3d* sensor2world_trans,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Eigen::Affine3d* novatel2world_trans = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">GetExtrinsics</span><span class="params">(Eigen::Affine3d* trans)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Attention: can be called without initlization</span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">GetTrans</span><span class="params">(<span class="keyword">double</span> timestamp, Eigen::Affine3d* trans,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; frame_id, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; child_frame_id)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">GetExtrinsicsBySensorId</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; from_sensor_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; to_sensor_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Eigen::Affine3d* trans)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> <span class="comment">//内部函数 封装了buffer中的canTransform,lookupTransform</span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">QueryTrans</span><span class="params">(<span class="keyword">double</span> timestamp, StampedTransform* trans,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; frame_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; child_frame_id)</span></span>;</span><br><span class="line">TransformCache transform_cache_; <span class="comment">//双端队列用于缓存transform信息</span></span><br></pre></td></tr></table></figure><p>Transofrom缓存的数据结构：<code>TransformCache</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddTransform</span><span class="params">(<span class="keyword">const</span> StampedTransform&amp; transform)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueryTransform</span><span class="params">(<span class="keyword">double</span> timestamp, StampedTransform* transform,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">double</span> max_duration = <span class="number">0.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SetCacheDuration</span><span class="params">(<span class="keyword">double</span> duration)</span> </span>&#123; cache_duration_ = duration; &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Init()</strong> 初始化主要将<code>frame_id</code>,<code>child_frame_id</code>赋值到类内成员变量，然后设置transform_cache的缓存间隔<code>SetCacheDuration()</code></p></li><li><p><strong>GetSensor2worldTrans(tiemstamp,sensor2world_trans,novatel2world_trans)</strong> 该函数要求先进行<code>Init()</code>,获取传感器和定位模块到世界坐标系的转换。 如果传感器到定位模块的外参为空，则首先先获取传感器到定位模块的转换关系（静态转换）</p><ul><li><p><strong>QueryTrans()</strong> 返回<code>trans_novatel2world</code> ，参数<code>timestamp</code>,<code>frame_id</code>,<code>child_frame_id</code></p><ul><li><code>Buffer::canTransform()</code></li><li><code>Buffer::lookupTransform(frame_id,child_frame_id,query_time)</code></li></ul><p>将<code>lookupTransform</code>得到的旋转平移矩阵转移到<code>Eigen</code>，并保存到类中定义的数据格式 <code>StampedTransform</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StampedTransform</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> timestamp = <span class="number">0.0</span>;  <span class="comment">// in second</span></span><br><span class="line">  Eigen::Translation3d translation;</span><br><span class="line">  Eigen::Quaterniond rotation;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这样获得了sensor2novatel的转换关系后，只需获得novatel2world的转换关系，就可以得到 sensor2world的转换关系，因此与上面相似通过<code>QueryTrans</code>查询是否有对应当前时间戳的转换关系，查询成功获得<code>trans_novatel2world</code>则调用：</p><ul><li><code>transform_cache_.AddTransform(trans_novatel2world)</code>添加到缓存中。</li></ul><p>查询不成功的调用缓存中的数据<code>TransformCache::QueryTransform()</code>进行推断，但是要求推断的时间延迟间隔最多不超过0.15s，通过历史信息进行插值得到<code>trans_novatel2world</code></p><p>然后很容易就可以得到sensor2world的坐标变换矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*sensor2world_trans = novatel2world * (*sensor2novatel_extrinsics_);</span><br></pre></td></tr></table></figure></li><li><p><strong>GetExtrinsics()</strong></p><p>该函数使用需要先进行<code>Init()</code>在<code>GetSensor2worldTrans()</code>中获得，此处返回sensor2novatel的变换矩阵</p></li><li><p><strong>GetTrans()</strong> 该函数执行不需要先执行<code>Init()</code>，获取任意的<code>frame_id</code>和<code>child_frame_id</code>的转换关系。</p></li><li><p><strong>GetExtrinsicsBySensorId()</strong></p><p>该函数执行不需要先执行<code>Init()</code>,首先根据传感器SensorId，通过SensorManager类查询得到对应的<code>frame_id</code>,然后通过<code>QueryTrans()</code>获得外参。</p></li></ul><h2 id="参考资料">参考资料：</h2><p>http://wiki.ros.org/tf2</p><p>https://github.com/daohu527/Dig-into-Apollo/tree/master/transform</p>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> transform </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 坐标转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo相机雷达的驱动</title>
      <link href="/2020/04/04/apollo-driver/"/>
      <url>/2020/04/04/apollo-driver/</url>
      
        <content type="html"><![CDATA[<p>apollo中Camera，Radar，Lidar，Can等驱动程序</p><a id="more"></a><h2 id="camera">1 Camera</h2><p>Camera包基于V4L USB相机设备实现封装，提供图像采集及发布的功能。</p><h3 id="camera_component">1.1 camera_component</h3><p><strong>组件配置</strong> <code>modules/drivers/camera/dag/camera.dag</code> 每个相机建立一个组件，这里以<code>front_6mm</code>为例,对应于dag文件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module_config&#123;</span><br><span class="line">module_library : <span class="string">"/apollo/bazel-bin/modules/drivers/camera/libcamera_component.so"</span></span><br><span class="line"></span><br><span class="line">components &#123;</span><br><span class="line">class_name : <span class="string">"CameraComponent"</span></span><br><span class="line">config &#123;</span><br><span class="line">name : <span class="string">"camera_front_6mm"</span></span><br><span class="line">             config_file_path : <span class="string">"/apollo/modules/drivers/camera/conf/camera_front_6mm.pb.txt"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由组件的配置文件路径可以得到该相机<code>front_6mm</code>组件对应于同级目录<code>proto/config.proto</code>中默认参数的修改。 <strong>组件初始化：</strong> 加载dag文件中config_file_path的参数<code>camera_config_</code>。 创建相机设备实例,并利用<code>camera_config_</code>来初始化该相机实例,相机类为<code>UsbCam</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apollo::cyber::common::GetProtoFromFile(config_file_path_,camera_config_.<span class="built_in">get</span>());</span><br><span class="line">camera_device_.reset(<span class="keyword">new</span> UsbCam());</span><br><span class="line">camera_device_.init(camera_config_);</span><br><span class="line">raw_image.reset(<span class="keyword">new</span> CameraImage);</span><br></pre></td></tr></table></figure><p>这里用到了两个类<code>UsbCam</code>和<code>CameraImage</code> 。其中<code>UsbCam</code>表示相机设备，该类包含了相机的硬件配置参数(像素编码格式，帧率，宽高，曝光及其他一些配置)。<code>CameraImage</code>则表示相机的图像结构信息（包括了图像的宽高和存储信息)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraImage</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">int</span> bytes_per_pixel;</span><br><span class="line">  <span class="keyword">int</span> image_size;</span><br><span class="line">  <span class="keyword">int</span> is_new;</span><br><span class="line">  <span class="keyword">int</span> tv_sec;</span><br><span class="line">  <span class="keyword">int</span> tv_usec;</span><br><span class="line">  <span class="keyword">char</span>* <span class="built_in">image</span>;</span><br><span class="line">  ~CameraImage() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">image</span> != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">free</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="built_in">image</span>)); <span class="comment">//！！！！</span></span><br><span class="line">      <span class="built_in">image</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>然后为CameraImage中的image分配内存（长度为imagesize）:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">raw_image_-&gt;<span class="built_in">image</span> =</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">calloc</span>(raw_image_-&gt;image_size, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))); </span><br><span class="line"><span class="comment">//注意在CameraImage的析构函数中，一定不能忘记释放内存</span></span><br></pre></td></tr></table></figure><p>根据<code>modules/driver/proto/sensor_iamge.proto</code>中定义的图像消息格式<code>&lt;Image&gt;</code>实例化<code>pb_iamge</code>进行相关参数的配置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer_size_; ++i) &#123; <span class="comment">//16</span></span><br><span class="line">  <span class="keyword">auto</span> pb_image = <span class="built_in">std</span>::make_shared&lt;Image&gt;();</span><br><span class="line">  pb_image-&gt;mutable_header()-&gt;set_frame_id(camera_config_-&gt;frame_id()); <span class="comment">//camera_front_6mm</span></span><br><span class="line">  pb_image-&gt;set_width(raw_image_-&gt;<span class="built_in">width</span>);</span><br><span class="line">  pb_image-&gt;set_height(raw_image_-&gt;<span class="built_in">height</span>);</span><br><span class="line">  pb_image-&gt;mutable_data()-&gt;reserve(raw_image_-&gt;image_size); <span class="comment">// 分配空间给data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (camera_config_-&gt;output_type() == YUYV) &#123;</span><br><span class="line">    pb_image-&gt;set_encoding(<span class="string">"yuyv"</span>);</span><br><span class="line">    pb_image-&gt;set_step(<span class="number">2</span> * raw_image_-&gt;<span class="built_in">width</span>); <span class="comment">//每一行像素所占的空间</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (camera_config_-&gt;output_type() == RGB) &#123;</span><br><span class="line">    pb_image-&gt;set_encoding(<span class="string">"rgb8"</span>);</span><br><span class="line">    pb_image-&gt;set_step(<span class="number">3</span> * raw_image_-&gt;<span class="built_in">width</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pb_image_buffer_.push_back(pb_image); <span class="comment">//缓存16个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在该节点上创建writer用于图像消息的发布,channel:&quot;/apollo/sensor/camera/front_6mm/image&quot;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writer_ = node_-&gt;CreateWriter&lt;Image&gt;(camera_config_-&gt;channel_name());</span><br><span class="line">async_result_ = cyber::Async(&amp;CameraComponent::<span class="built_in">run</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>注意对于<code>CameraComponent</code>的运行使用了异步编程，执行的函数为<code>CameraComponent::run()</code>,这样各个摄像头组件将会在多线程中运行。</p><p><strong>组件运行(run)</strong> <code>CameraComponent::run()</code>函数用于发布图像信息，该函数通过异步的方式运行(while{}循环一直执行,间隔1/200s)</p><p>异步循环执行，首先查询相机设备的状态(是否正常连接)，如果未正常连接，等待2000ms再次检测。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!camera_device_-&gt;wait_for_device()) &#123;</span><br><span class="line">  <span class="comment">// sleep for next check</span></span><br><span class="line">  cyber::SleepFor(<span class="built_in">std</span>::chrono::milliseconds(device_wait_)); <span class="comment">//device_wait_ms: 2000</span></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过<code>camera_device_-&gt;poll(raw_image_)</code>获取图像信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!camera_device_-&gt;poll(raw_image_)) &#123;</span><br><span class="line">  AERROR &lt;&lt; <span class="string">"camera device poll failed"</span>; <span class="comment">//轮询失败</span></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将图像和时间信息添加到<code>&lt;Image&gt;</code>数据结构中，通过writer发布，等待5000us-&gt;5ms再次执行。每秒200帧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">message Image &#123;</span><br><span class="line">  optional apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line">  optional <span class="built_in">string</span> frame_id = <span class="number">2</span>; <span class="comment">//传感器名称id</span></span><br><span class="line">  optional <span class="keyword">double</span> measurement_time = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  optional uint32 <span class="built_in">height</span> = <span class="number">4</span>;  <span class="comment">// image height, that is, number of rows</span></span><br><span class="line">  optional uint32 <span class="built_in">width</span> = <span class="number">5</span>;   <span class="comment">// image width, that is, number of columns</span></span><br><span class="line"></span><br><span class="line">  optional <span class="built_in">string</span> encoding = <span class="number">6</span>;</span><br><span class="line">  optional uint32 <span class="built_in">step</span> = <span class="number">7</span>;  <span class="comment">// Full row length in bytes   = bytes_per_pixel*width</span></span><br><span class="line">  optional bytes data = <span class="number">8</span>;   <span class="comment">// actual matrix data, size is (step * rows)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="compress_component">1.2 compress_component</h3><p><code>modules/drivers/camera/dag/camera.dag</code> <code>compress_component</code>的dag配置文件,同样以<code>front_6mm</code>为例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">components &#123;</span><br><span class="line">  class_name : <span class="string">"CompressComponent"</span></span><br><span class="line">  config &#123;</span><br><span class="line">    name : <span class="string">"camera_front_6mm_compress"</span></span><br><span class="line">    config_file_path : <span class="string">"/apollo/modules/drivers/camera/conf/camera_front_6mm.pb.txt"</span></span><br><span class="line">    readers &#123;</span><br><span class="line">      channel: <span class="string">"/apollo/sensor/camera/front_6mm/image"</span></span><br><span class="line">      pending_queue_size: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>该组件接收camera_component发布的图像信息然后进行压缩，等待队列的大小设置为10。 <strong>组件初始化：</strong> 加载图像压缩的配置信息，以camera_front_6mm.pb.txt中为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compress_conf &#123;</span><br><span class="line">    output_channel: <span class="string">"/apollo/sensor/camera/front_6mm/image/compressed"</span></span><br><span class="line">    image_pool_size: <span class="number">100</span> <span class="comment">//对象池的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化<code>std::shared_ptr&lt;CCObjectPool&lt;CompressedImage&gt;&gt; image_pool_;</code>对象，这里用到对象池，在需要某个类的多个实例时使用，此处对象池的大小为100。 创建节点writer,通道名称为<code>output_channel</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writer_ = node_-&gt;CreateWriter&lt;CompressedImage&gt;(</span><br><span class="line">     config_.compress_conf().output_channel());</span><br></pre></td></tr></table></figure><p><strong>组件处理程序Proc</strong> 当接收到原始的图像信息，设置<code>frame_id</code>,<code>header</code>,<code>measurement_time</code>与原图像信息一致，不同的是compress特有的 <code>format</code>设置为：<code>image-&gt;encoding() + &quot;; jpeg compressed bgr8&quot;</code></p><blockquote><p>原始图像的encoding为配置文件中的 output_type决定，默认为RGB</p></blockquote><p>接下来就是通过opencv将图像重新编码压缩</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; params;</span><br><span class="line">params.resize(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">params[<span class="number">0</span>] = CV_IMWRITE_JPEG_QUALITY;</span><br><span class="line">params[<span class="number">1</span>] = <span class="number">95</span>; <span class="comment">//压缩图像 100表示不压缩</span></span><br></pre></td></tr></table></figure><p>利用图像编码函数,压缩为jpeg格式，且RGB-&gt;bgr8</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::imencode(<span class="string">".jpg"</span>, tmp_mat, compress_buffer, params);</span><br><span class="line">compressed_image-&gt;set_data(compress_buffer.data(), compress_buffer.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure><p>然后将压缩的图像通过writer发布,通道名称为<code>&quot;/apollo/sensor/camera/front_6mm/image/compressed&quot;</code> 但是貌似好像实际<code>FusionCameraDetectionComponent</code>的接收图像信息还是未压缩的图像，即通道： <code>&quot;/apollo/sensor/camera/front_6mm/image&quot;</code> ,但是高清地图信息采集时貌似用的时压缩的图像。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CompressedImage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> frame_id = <span class="number">2</span>; <span class="comment">//对应的传感器的名称</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Specifies the format of the data</span></span><br><span class="line">  <span class="comment">//  Acceptable values: jpeg, png</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> format = <span class="number">3</span>; <span class="comment">//压缩的图像类型,eg. jpeg</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bytes</span> data = <span class="number">4</span>;  <span class="comment">// Compressed image buffer</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> measurement_time = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> frame_type = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="video_component">1.3 video_component</h3><p>首先看一下该组件的dag配置文件：(基本被注释了，表示正常情况下，该组件并没有运行)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Define all coms in DAG streaming.</span><br><span class="line">module_config &#123;</span><br><span class="line">    module_library : <span class="string">"/apollo/bazel-bin/modules/drivers/video/libvideo_driver_component.so"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#    components &#123;</span></span><br><span class="line">#      class_name : <span class="string">"CompCameraH265Compressed"</span></span><br><span class="line"><span class="meta">#      config &#123;</span></span><br><span class="line"><span class="meta">#        name : <span class="meta-string">"camera_front_6mm_compress"</span></span></span><br><span class="line">#        config_file_path : <span class="string">"/apollo/modules/drivers/video/conf/video_front_6mm.pb.txt"</span></span><br><span class="line">#      &#125;</span><br><span class="line">#    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#    components &#123;</span></span><br><span class="line">#      class_name : <span class="string">"CompCameraH265Compressed"</span></span><br><span class="line"><span class="meta">#      config &#123;</span></span><br><span class="line"><span class="meta">#        name : <span class="meta-string">"camera_front_12mm_compress"</span></span></span><br><span class="line">#        config_file_path : <span class="string">"/apollo/modules/drivers/video/conf/video_front_12mm.pb.txt"</span></span><br><span class="line">#       &#125;</span><br><span class="line">#    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组件初始化</strong> 根据配置文件创建<code>CameraDriver</code>实例<code>camera_device_</code>，然后进行CameraDriver初始化：</p><ul><li><code>CameraDriver::Init()</code> 创建<code>ScoketInput</code>实例，并通过配置文件中的<code>udp_port</code>进行初始化，初始化<code>sock_fd</code>和<code>port</code>,即生成套接字文件描述符和端口号</li></ul><blockquote><p>udp_port：为UDP 数据传输协议的端口，程序中从2000开始，每一个相机递增1</p></blockquote><ul><li><code>CameraDriver::Record()</code>返回配置文件中的record，若值为1，则使用环境变量<code>H265_SAVE_FOLDER</code>（当环境变量没有设置，则使用当前路径位置）位置创建文件路径用于保存record文件。</li><li>创建<code>&lt;CompressedImage&gt;</code>实例，并创建节点<code>writer</code>用于传输压缩的图像数据。</li><li>创建线程执行<code>CompCameraH265Compressed::VideoPoll</code></li></ul><p><strong>组件处理函数</strong> 循环执行下列程序，直到系统退出。</p><ul><li><p><code>CameraDriver::Poll(std::shared_ptr&lt;CompressedImage&gt; h265)</code></p><ul><li><p><code>PollByFrame(h265)</code> 轮询获取压缩图像信息</p><ul><li><p><code>SocketInput::GetFramePacket(h265)</code> 通过socket底层库<code>recvfrom</code>经socket获取数据到缓冲区<code>pdu_data</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功则返回实际接收到的字符数，失败返回-1</span></span><br><span class="line"><span class="keyword">ssize_t</span> pdu_len = recvfrom(sockfd_, pdu_data, H265_PDU_SIZE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>然后将接收到压缩图像通过节点发布，并记录二进制图像数据到record文件中，文件名：<code>encode_{端口号}.h265</code></p><hr><h3 id="image_decompress">1.4 image_decompress</h3><p>组件的<code>dag</code>配置文件：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module_config &#123;</span><br><span class="line">    module_library : <span class="string">"/apollo/bazel-in/modules/drivers/tools/image_decompress/libimage_decompress.so"</span></span><br><span class="line">    components &#123;</span><br><span class="line">      class_name : <span class="string">"ImageDecompressComponent"</span></span><br><span class="line">      config &#123;</span><br><span class="line">        name : <span class="string">"camera_front_6mm_decompress"</span></span><br><span class="line">        config_file_path : </span><br><span class="line">           <span class="string">"/apollo/modules/drivers/tools/image_decompress/conf/camera_front_6mm.pb.txt"</span></span><br><span class="line">        readers &#123;</span><br><span class="line">          channel: <span class="string">"/apollo/sensor/camera/front_6mm/image/compressed"</span></span><br><span class="line">          pending_queue_size: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>该组件接收压缩图像通道的信息，并进行解压缩，最后将图像信息发布到<code>&quot;/apollo/sensor/camera/front_6mm/image&quot;</code>通道中。</p><p><strong>组件初始化</strong> 创建该节点的消息发布通道例如，<code>channel_name: &quot;/apollo/sensor/camera/front_6mm/image&quot;</code></p><p><strong>组件处理函数Proc</strong> 当接受到<code>&quot;/apollo/sensor/camera/front_6mm/image/compressed&quot;</code>通道发布的压缩图像数据，进行解压缩操作： 方法是压缩图像(Compressed Component)的逆向操作，通过opencv函数<code>cv::imdecode()</code>解码获得cv::Mat格式图像,然后将图像由bgr转换为rgb，最后通过writer发布出去。</p><p>编码解码的用到的函数有：</p><ol type="1"><li><p>将原始的<code>&lt;Image&gt;</code>格式的图像转存到<code>cv::Mat</code>数据结构中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">mat_image</span><span class="params">(<span class="built_in">image</span>-&gt;<span class="built_in">height</span>(), <span class="built_in">image</span>-&gt;<span class="built_in">width</span>(), CV_8UC3,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">image</span>-&gt;data().data()), <span class="built_in">image</span>-&gt;<span class="built_in">step</span>())</span></span>;</span><br><span class="line"><span class="comment">//注意image data在proto中的定义为bytes,实际c++中对应std::string(可以包含任意顺序的字节数据)，</span></span><br><span class="line"><span class="comment">//string.data()返回char*指向数据的首地址，这里Mat的构造方法</span></span><br><span class="line"><span class="comment">//Mat::Mat(int rows, int cols, int type, void* data, size_t step=AUTO_STEP) </span></span><br><span class="line"><span class="comment">//step指一行元素的字节数</span></span><br></pre></td></tr></table></figure></li><li><p>将Mat格式图像编码为<code>std::vector&lt;uint8_t&gt;</code>压缩格式(byte格式的数组，用于方便传输)，即将图像数据转为二进制数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; compress_buffer;</span><br><span class="line">cv::imencode(<span class="string">".jpg"</span>, tmp_mat, compress_buffer, params)</span><br></pre></td></tr></table></figure></li><li><p>将byte格式的数组解码恢复到Mat,将内存中的二进制图像数据转换为opencv可处理的格式，首先创建一个byte数组用于存储二进制数据，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; <span class="title">compressed_raw_data</span><span class="params">(compressed_image-&gt;data().<span class="built_in">begin</span>(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                         compressed_image-&gt;data().<span class="built_in">end</span>())</span></span>;</span><br><span class="line">cv::Mat mat_image = cv::imdecode(compressed_raw_data, CV_LOAD_IMAGE_COLOR);</span><br></pre></td></tr></table></figure></li><li><p>最后将Mat结构数据转存到内部数据结构中<code>&lt;Image&gt;</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="built_in">size</span> = mat_image.<span class="built_in">step</span> * mat_image.rows;</span><br><span class="line"><span class="built_in">image</span>-&gt;set_data(&amp;(mat_image.data[<span class="number">0</span>]), <span class="built_in">size</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong> <strong>std::string 与字符数组并不是意味着文本格式，而是将string 作为二进制存储的容器。</strong></p><p>参考：https://blog.csdn.net/qq_37406130/article/details/78820176?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</p><hr><h3 id="启动脚本">1.5 启动脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in docker</span></span><br><span class="line">bash /apollo/scripts/camera.sh</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="built_in">cd</span> /apollo &amp;&amp; cyber_launch start modules/drivers/camera/launch/camera.launch</span><br></pre></td></tr></table></figure><p>如果报错： <code>sh: 1: v4l2-ctl: not found</code>,需要安装v4l2库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install v4l-utils</span><br></pre></td></tr></table></figure><p>如果图像被压缩了，运行image decompression module:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyber_launch start modules/drivers/tools/image_decompress/launch/image_decompress.launch</span><br></pre></td></tr></table></figure><hr><h3 id="参考">参考</h3><p>https://www.cnblogs.com/hgl0417/p/9190835.html</p><p>v4l2 API： https://baike.baidu.com/item/V4L2?sefr=enterbtn</p><p>https://www.cnblogs.com/aquafly/p/6474555.html</p><p>颜色空间的表示方法 https://www.cnblogs.com/x_wukong/p/4919774.html</p><p>c++异步编程： https://blog.csdn.net/u012372584/article/details/97108417</p><p>并发对象池： http://ifeve.com/generic-concurrent-object-pool/</p><p>Opencv压缩图像格式： https://www.jianshu.com/p/fed6a8a99625</p><p>UDP socket</p><p>https://www.cnblogs.com/HpeMephisto/p/11312193.html</p><p>protobuf :序列化与反序列化</p><p>https://cloud.tencent.com/developer/article/1176660</p>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中多传感器标定与坐标系统</title>
      <link href="/2020/04/04/apollo-sensor_calibration/"/>
      <url>/2020/04/04/apollo-sensor_calibration/</url>
      
        <content type="html"><![CDATA[<p>apollo中的坐标系统和多传感器标定及坐标转换(transform组件)</p><a id="more"></a><h2 id="坐标系统">1. 坐标系统</h2><p>参考：<code>docs/specs/coordination_cn.md</code></p><p>Apollo系统中采用的坐标系的定义：</p><h3 id="全球地理坐标系">全球地理坐标系</h3><p>使用全球地理坐标系来表示高精地图(HD Map)中各个元素的地理位置。全球地理坐标系通常用途是用来表示纬度，经度和海拔。Apollo采用的是WGS84(World Geodetic System 1984)作为标准坐标系来表示物体的纬度和经度。通过使用该标准坐标系统，可以使用两个数字：x坐标，y坐标来唯一确定地球表面上除北极点之外的所有点，其中x坐标表示经度，y坐标表示纬度。全球地理坐标系的定义如图所示：</p><p><img src="/2020/04/04/apollo-sensor_calibration/coordination_01.png" style="zoom:50%;"></p><h3 id="局部坐标系-东-北-天east-north-up-enu"><strong>局部坐标系-东-北-天(East-North-Up ENU)</strong>:</h3><p>在Apollo中，局部坐标系的定义为：</p><p>z轴-指向上方（与重力线为同一直线） y轴-指向北面 x轴-指向东面</p><p><img src="/2020/04/04/apollo-sensor_calibration/coordination_02.png" style="zoom:50%;"></p><p>ENU局部坐标系依赖于在地球表面上建立3D笛卡尔坐标系。</p><p>通用横轴墨卡托正形投影(Universal Transverse Mercator UTM),使用2D的笛卡尔坐标系来给出地球表面点的位置。该坐标系将地球划分为60个区域，每个区域表示为6度的经度带，并且每个区域上使用割线横轴墨卡托投影。在apollo系统中，UTM坐标系统在定位，规划等模块中作为局部坐标系使用。</p><p>关于UTM坐标系统的使用，遵从国际标准规范。开发者可以参考下述网站获取更多细节：</p><p><a href="http://geokov.com/education/utm.aspx" target="_blank" rel="noopener" class="uri">http://geokov.com/education/utm.aspx</a></p><p><a href="https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system" target="_blank" rel="noopener" class="uri">https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system</a></p><h3 id="车辆坐标系-右-前-上right-forward-up-rfu">车辆坐标系-右-前-上(Right-Forward-Up RFU)</h3><p>车辆坐标系的定义为： z轴-通过车顶垂直于地面指向上方 y轴-在行驶方向上指向车辆前方 x轴-面向前方时，指向车辆右侧 车辆坐标系的原点在车辆后轮轴的中心</p><p><img src="/2020/04/04/apollo-sensor_calibration/coordination_04.png" style="zoom: 50%;"></p><h3 id="传感器等硬件安装位置">传感器等硬件安装位置</h3><p>下面的示例中，不同颜色箭头代表不同的坐标方向，实心代表垂直向上，包括了4个环视相机，3个radar，1个IMU，1个lidar。</p><p><img src="/2020/04/04/apollo-sensor_calibration/C:/Users\jia_z\Desktop\blogrepo\source\_posts\apollo-sensor_calibration\calibration05.jpg" style="zoom: 33%;"></p><p>首先拿到车辆的CAD模型，然后在软件环境中去放置sensor（尽量在软件平台中标注传感器的感知角度距离），需要考虑的不仅仅是空旷环境下传感器的感知范围，也要考虑到真实环境中的遮挡情况，同时要便于传感器融合（不同传感器的感知视野需要overlap）。需要注意的是传感器的安装位置的稳定性和安全性。</p><hr><h2 id="多传感器标定">2. 多传感器标定</h2><p>标定本质就是要获得不同传感器之间的相对位置，然后将各传感器的坐标系对齐，分为内参和外参，有些是传感器厂家提供，有一些则需要自己去重新标定：</p><ul><li><p>内参：传感器自身性质，例如camera焦距，Lidar中各激光管的垂直朝向角。</p></li><li><p>外参：传感器之间的相对位置和朝向，用3自由度的旋转矩阵和3自由度的平移向量表示。</p><blockquote><p>内参虽然一般来说是固定的，但是随着长期的运行，也需要定期标定一下。</p></blockquote></li></ul><p><code>Lidar</code>,<code>Camera</code>,<code>radar</code>之间有不同的观测角度和数据表现形式，要融合它们的各自的优点的前提就是需要它们之间相对的坐标变换关系,传感器的相对相对位置关系可以通过4*4变换矩阵M表示，实际有12个量需要计算表示旋转位移。 <span class="math display">\[M=\begin{bmatrix}R_{3\times3}&amp; T_{3\times1}\\0_{1\times3}&amp;1\end{bmatrix}\]</span> 但是实际上<span class="math inline">\(R_{3\times3}\)</span>可以通过四元数表示转换为4个参数，实际上只需要标定7个参数。</p><p><img src="/2020/04/04/apollo-sensor_calibration/C:/Users\jia_z\Desktop\blogrepo\source\_posts\apollo-sensor_calibration\174722.png" style="zoom: 33%;"></p><h3 id="粗略标定">2.1粗略标定</h3><p>首先可以进行粗略的标定，在手凉传感器标定初值的时候，一定要分清楚是从哪一个源传感器到哪一个目标传感器，且这些数值是在目标传感器坐标系下，位移向量以米为单位，旋转以弧度为单位，如下所示，<code>frame_id</code>表示目标传感器， <code>child_frame_id</code>表示源传感器，而<code>translation</code>和<code>rotation</code>是在<code>frame_id</code>即目标传感器坐标系下的short_camera的位姿</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">header:</span></span><br><span class="line">  <span class="attr">stamp:</span></span><br><span class="line">    <span class="attr">secs:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">nsecs:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">seq:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">frame_id:</span> <span class="string">Velodyne64</span> <span class="comment"># Destination sensor</span></span><br><span class="line"><span class="attr">child_frame_id:</span> <span class="string">short_camera</span> <span class="comment"># source sensor</span></span><br><span class="line"><span class="attr">transform:</span></span><br><span class="line">  <span class="attr">translation:</span></span><br><span class="line">    <span class="attr">x:</span> <span class="number">0.9356324324557267</span></span><br><span class="line">    <span class="attr">z:</span> <span class="number">-0.5427650640523064</span></span><br><span class="line">    <span class="attr">y:</span> <span class="number">-0.2485193364771597</span></span><br><span class="line">  <span class="attr">rotation:</span></span><br><span class="line">    <span class="attr">w:</span> <span class="number">0.5171207069875965</span></span><br><span class="line">    <span class="attr">x:</span> <span class="number">-0.4789595241079692</span></span><br><span class="line">    <span class="attr">y:</span> <span class="number">0.5018481750475685</span></span><br><span class="line">    <span class="attr">z:</span> <span class="number">-0.5013305874094867</span></span><br></pre></td></tr></table></figure><h3 id="录取数据">2.2 录取数据</h3><p>在录取数据之前先通过<code>Cyber_montior</code>工具来检查安装的传感器的状态，对应传感器的消息通道名称和帧率信息。绿色代表消息正常首发，红色代表消息没有出现。通过<code>Cyber Monitor</code>可以检查相应传感器的帧率是否正常，例如，激光雷达的帧率是10hz,相机的帧率15hz-20hz,GPS和惯导信号帧率为100hz。 还需要注意GPS的信号是否正常，质量是否足够高，如图红色框中，<code>Narrow_INT</code>是正常状态，此时三个方向上的标准差应该为1-2厘米级别。</p><p><img src="/2020/04/04/apollo-sensor_calibration/gnss.png" style="zoom:75%;"></p><p>同样，也可以通过<code>cyber_visualizer</code>命令来查看传感器的原始数据，保证数据质量，如图像是否模糊，lidar是否点云噪音过多，这种问题一般是由于硬件安装和EOS系统的不匹配造成的。</p><p>上述初步检查完成后，按照Apollo的建议采集有效的传感器标定数据，脚本文件<code>($Apollo)/scripts/record_bag.py</code></p><p>对于激光雷达，只需采集原始点云数据；对于相机，建议采集未压缩的原始图像信息；对于惯导和GPS需要采集他们的odometry信息。右图的三个红框分别展示了典型的图像信息、点云信息以及GPS和惯导信息。在使用Apollo DreamView进行数据采集前，可以通过上述步骤修改对应脚本中的消息列表，以适配自己的传感器方案,例如lidar到gnss的标定不需要camera数据，则可以过滤图像数据，以减小数据包的大小。</p><p><img src="/2020/04/04/apollo-sensor_calibration/calibration06.jpg" style="zoom: 33%;"></p><p>gnss/odometry:100Hz通道的数据组成：</p><p><img src="/2020/04/04/apollo-sensor_calibration/C:/Users\jia_z\Desktop\blogrepo\source\_posts\apollo-sensor_calibration\odometry.png" style="zoom: 67%;"></p><h3 id="标定策略">2.3 标定策略</h3><ul><li><p><strong>相机内参标定：</strong></p></li><li><p><strong>Lidar内参标定：</strong></p></li><li><p><strong>Lidar-to-GPS外参标定：</strong> 在空旷的地方绕8字，每一个时间点GPS都会得到车辆的位置信息(原点是GPS安装点)，然后把每一帧点云都投影到GPS坐标原点的坐标系中，将点云拼接到一起解一个优化，在采集是，希望场景中没有过多的动态障碍物，地面平整，场景中有类似数目，电线杆之类的静态障碍物。由于组合惯导和Lidar没有直接的测量数据对应，所以采用<strong>手眼标定</strong>方法获得外参初值，然后采用基于点云拼接质量进行外参优化。 具体标定方法参考：https://github.com/ApolloAuto/apollo/blob/master/docs/specs/lidar_calibration.pdf</p><p><img src="/2020/04/04/apollo-sensor_calibration/230426.png" style="zoom: 50%;"></p><p><img src="/2020/04/04/apollo-sensor_calibration/cal06.jpg" style="zoom: 33%;"></p></li><li><p><strong>Lidar-to-Lidar外参标定：</strong> 每个Lidar与Rigel之间独立进行ICP，然后得到相对<code>Rigel</code>的位移旋转矩阵，再通过传递得到Lidar之间的相对位置。验证方法是将所有的点云都投影到真实的物理世界中，若边缘清晰则标定正常。</p><p><img src="/2020/04/04/apollo-sensor_calibration/205819.png"></p></li><li><p><strong>Lidar-to-Camera外参标定：</strong> 在标定间中，贴满二维码(April-Tag 具有高鲁棒性和识别精度的二维码)，每个二维码对应的ID都不一样，然后在标定间中间放置毫米级精度激光扫描仪<code>Rigel</code>,对标定间进行3D建模，这样就知道了标定间墙面上任意点的3D位置(包括了April-Tag的四个角点)。由于<code>Lidar</code>与<code>Rigel</code>都是点云数据，两个点云之间做ICP，得到对应的位移旋转矩阵，相机通过<code>Rigel</code>也可以得到对应的位移旋转矩阵，然后两个位移旋转矩阵进行传递即可得到相对的位置。验证方法是将3D点投影到图像中，观察边界是否一致。 <img src="/2020/04/04/apollo-sensor_calibration/205718.png"></p></li><li><p><strong>Camera-to-Camera外参标定</strong></p><p>在标定间中，长焦和短焦的相机都能够过的Tag的四个角点3D坐标，同时在相机中对应的2D坐标也已知，2D坐标 3D坐标都有了，那么通过多个点对求解这个<code>PNP</code>问题，可以得到短焦相机和长焦相机相对Rigel各自的位移旋转矩阵，最后就可以得到它们之间的相对坐标。标定完成后，需要验证标定结果，对于图像来说可以通过可视化，比如长焦的图像范围一般是包含在短焦的视野范围内的，那么将长焦图像投影到短焦图像上没有重影比较自然则应该比较标准。 <img src="/2020/04/04/apollo-sensor_calibration/204947.png" style="zoom:50%;"></p></li><li><p><strong>自然场景中的Lidar-to-Camera外参标定</strong></p><p>自然场景下的标定有一些要求，需要在场景中找到一些边缘(比如路边的标识牌)，针对lidar(边缘处lidar的深度会有变化)和camera各自对边缘的坐标作为考量的指标，将两个sensor对齐。 相机到lidar的标定，通过4个5的方法来指导开车数据采集过程，即在一个较为空旷，拥有大量静态障碍物的场景中，无人车以大约5英里每小时的速度直线行驶5米后刹车，之后完全停止大约5秒，重复以上步骤5-6次。</p><p>完成数据采集后，可以通过命令<code>cyber_recorder info ${bagname}</code>来检查采集的数据包。通过计算每秒钟采集的数据的帧率，可以大致了解数据是否完整的被存放，例如，Gps惯导信息，帧率为100HZ,在4秒左右的数据包中有大约430个数据，符合预期。而红框中所示的相机，其消息数为0，如果我们需要涉及到相机的标定，那么这个数据集的采集是不成功的。 <img src="/2020/04/04/apollo-sensor_calibration/C:/Users\jia_z\Desktop\blogrepo\source_posts\apollo-sensor_calibration\recorder.png"></p></li><li><p><strong>自然场景中的Bifocal Camreas外参标定</strong> 自然场景下，视野有重叠的多个相机之间的对齐，同样在重叠的视野中找到一个边缘比较锐利的物体，进行外参标定。</p></li><li><p><strong>Camera-to-Radar外参标定</strong> 由于radar不知道高度，其返回的是一个平面内的距离角度信息，需要得到radar相对相机的高度。一般是假设radar是水平安装，安装位置已在汽车的cad模型中固定好了，然后通过CAD模型的测量可以得到这个高度。但是相机的pitch角度即相对radar的俯仰角度(假设radar是水平的)是需要标定的。在假设radar水平的前提下，标定问题退化为相机与地面（水平面）的pitch角度问题，这样就可以借助Lidar,通过Lidar可以得到地面水平面，Camera相对于Lidar已经标定好了，则Camera相对于地面的pitch角度就可以测量出来，这个角度就等同于Camera相对radar的水平角度。</p></li></ul><h3 id="通过apollo工具提供有效数据">2.4 通过Apollo工具提供有效数据</h3><p><img src="/2020/04/04/apollo-sensor_calibration/calibration10.jpg" style="zoom: 33%;"></p><p>当完成数据采集后，可以通过Apollo平台中数据分析提取工具，提取有用的标定信息，仅需一行命令，就可以自动完成数据的提取和压缩，可以将原50GB的数据压缩到3-5GB（5lidars/5Cameras/gps calibration needs）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /apollo/modules/tools/sensor_calibration/extract_data.py --config /apollo/modules/tools/sensor_calibration/config/camera_to_lidar_calibration.config</span><br></pre></td></tr></table></figure><p><code>*.config</code>配置文件中分为三个部分：第一个部分是io配置，主要是指定标定任务的名称，以及相应的输出路径；第二个部分，主要为指定输入的数据包路径，可以是完整的数据包路径列表，也可以是一个包含多个数据包的文件夹路径。最后一部分主要是指定所需提取的消息名称以及采样率。对于小容量信息(比如GNSS里程计信息)，建议完整保留，采样率为1.</p><p><img src="/2020/04/04/apollo-sensor_calibration/config.png" style="zoom:40%;"></p><h3 id="通过apollo产生准确的标定参数">2.5 通过Apollo产生准确的标定参数</h3><p>对于相机内参，由于需要采集棋盘格图像，要求棋盘格的成像能够覆盖图像的各个区域，并且图片中的棋盘格完整。采集步骤如下： 将设备固定在三脚架上，开启相机，观察标定板在相机上的成像。将图像分为图片中的五个区域，将标定板正对相机并移动标定板将成像置于这5个区域内，在每个区域中，分别绕标定板的X,Y轴旋转正负30度左右各一次，绕z轴旋转正负45度左右各一次，并采集图像。</p><p><img src="/2020/04/04/apollo-sensor_calibration/caliop.png" style="zoom: 33%;"></p><p>采集完相应的棋盘格图像后，可以使用OpenCV自带的摄像机内参标定工具完成标定。完成内参标定后，按照Apollo建议内参格式，生成对应的内参文件。</p><p><img src="/2020/04/04/apollo-sensor_calibration/accurate.png" style="zoom:33%;"></p><p>当完成上述步骤后，可以将数据提取工具产生的压缩包以及摄像头的内参文件，发给 Apollo 服务团队，完成传感器的标定。https://github.com/ApolloAuto/apollo/blob/master/docs/quickstart/multiple_lidar_gnss_calibration_guide.md</p><p>https://login.bce.baidu.com/?redirect=http%3A%2F%2Fconsole.bce.baidu.com%2Fapollo%2Fcalibrator%2Findex%2Flist</p><p><img src="/2020/04/04/apollo-sensor_calibration/C:/Users\jia_z\Desktop\blogrepo\source\_posts\apollo-sensor_calibration\103354.png" style="zoom: 50%;"></p><h3 id="多传感器数据融合-关系">多传感器数据融合 关系</h3><h2 id="transform-wrapper">3. Transform Wrapper</h2><p>整个Transform部分的封装格式和相互关联应该为</p><blockquote><p><code>third_party/tf2(ros) -&gt; modules/transform -&gt; perception/onboard/transform_wrapper</code></p></blockquote><p>此部分详细参考文件<code>apollo-transfom_wrapper.md</code></p><h2 id="apollo提供的标定工具">4. Apollo提供的标定工具</h2><p>参考文件：docs/quickstart/multiple_lidar_gnss_calibration_guide_cn.md</p><p>参考文件：https://github.com/ApolloAuto/apollo/blob/master/docs/specs/apollo_lidar_imu_calibration_guide.md</p><h2 id="参考资料">参考资料</h2><p>https://blog.csdn.net/qq_41204464/article/details/102945454</p><p>https://gitbook.cn/books/5cd8e067d7a0dd4c0f47391a/index.html</p><p>https://bit.baidu.com/productsBuy?id=81&amp;chapterId=224</p>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传感器标定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中Cyber RT脚本启动流程</title>
      <link href="/2020/04/04/apollo-cyber_bash/"/>
      <url>/2020/04/04/apollo-cyber_bash/</url>
      
        <content type="html"><![CDATA[<p>Apollo中Cyber RT组件脚本启动流程</p><a id="more"></a><h2 id="cyberrt功能模块启动过程">1. CyberRT功能模块启动过程</h2><p>Apollo通过组件注册的形式构建</p><p>https://zhuanlan.zhihu.com/p/116782645</p><h2 id="cyber-api">2. Cyber API</h2><h3 id="talk-listener">2.1 Talk-Listener</h3><p>首先引入三个概念：<code>node</code>(base unit),<code>reader</code>(facility to read message),<code>writer</code> (facility to write message)，即<code>reader</code>和<code>writer</code>是建立在<code>node</code>上的。 <strong>创建node</strong>： 在CyberRT框架下，node是最基本的单元（wirter和reader的基础），创建node的接口如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Node&gt; apollo::cyber::CreateNode(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; node_name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name_space = <span class="string">""</span>);</span><br></pre></td></tr></table></figure><ul><li>Parameters:<ul><li>node_name:<code>node</code>的名称，需要是全局唯一的标识符（名字不能重复）</li><li>name_space: 表明<code>node</code>位于的命名空间,默认为空，它最终与<code>node_name</code>相连接作为最终节点名，形式 是<code>/namespace/node_name</code></li></ul></li><li>Return value - 指向<code>Node</code>的指针(unique_ptr)</li><li>Error Conditions - 当<code>Cyber::Init()</code>没有执行，系统没有进行初始化，则不能创建节点，会返回<code>nullptr</code></li></ul><blockquote><p>注意，一般一个功能组件仅仅只有一个node,但是在node上可以创建多个writer和reader。</p></blockquote><p><strong>创建writer</strong>: <code>writer</code>是CyberRT中用于消息发送的&quot;设备&quot;，每一个<code>writer</code>都与一个对应特定数据类型的<code>channel</code>关联。<code>writer</code>通过<code>Node</code>类中的<code>CreateWriter</code>接口创建，接口(位于node.h)如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">CreateWriter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; channel_name)</span></span></span><br><span class="line">-&gt; std::shared_ptr&lt;Writer&lt;MessageT&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">CreateWriter</span><span class="params">(<span class="keyword">const</span> proto::RoleAttributes&amp; role_attr)</span></span></span><br><span class="line">-&gt; std::shared_ptr&lt;Writer&lt;MessageT&gt;&gt;;</span><br></pre></td></tr></table></figure><ul><li>Parameters:<ul><li>channel_name: 发布消息的channel名称</li><li>MessageT:发送消息的类型</li></ul></li><li>Return value - 指向<code>Writer</code>类实例的指针</li></ul><p><strong>创建reader:</strong> <code>reader</code>的创建与<code>writer</code>类似，是CyberRT中用于接收消息的&quot;设备&quot;，<code>reader</code>在创建的时候必须与一个回调函数绑定，当channel中新的消息到来时，将会调用回调函数。<code>reader</code>的创建的函数接口为(node.h)：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">CreateReader</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; channel_name,<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MessageT&gt;&amp;)&gt;&amp; reader_func)</span></span></span><br><span class="line">-&gt; std::shared_ptr&lt;Reader&lt;MessageT&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">CreateReader</span><span class="params">(<span class="keyword">const</span> ReaderConfig&amp; <span class="built_in">config</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> CallbackFunc&lt;MessageT&gt;&amp; reader_func = <span class="literal">nullptr</span>)</span></span></span><br><span class="line">    -&gt; std::shared_ptr&lt;cyber::Reader&lt;MessageT&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MessageT&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">CreateReader</span><span class="params">(<span class="keyword">const</span> proto::RoleAttributes&amp; role_attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> CallbackFunc&lt;MessageT&gt;&amp; reader_func = <span class="literal">nullptr</span>)</span></span></span><br><span class="line">-&gt; std::shared_ptr&lt;cyber::Reader&lt;MessageT&gt;&gt;;</span><br></pre></td></tr></table></figure><blockquote><p>CallbackFunc 封装了<code>std:function&lt;void(const std::shared_ptr&lt;M0&gt;&amp;)&gt;</code></p></blockquote><ul><li>Parameters:<ul><li>MessageT: 读取的消息类型</li><li>channel_name:对应接收消息来自哪个channel</li><li>reader_func:回调函数用于处理接收到的消息</li></ul></li><li>Return value:指向Reader类实例的指针</li></ul><hr><h3 id="service-creation-and-use">2.2 Service Creation and Use</h3><p>在自动驾驶场景中，往往需要多个模块之间的信息交换，除了上述的接收和发送消息的方式。<code>Service</code>是<code>node</code>间通信的另一种方式。与channel的方式不同，<code>service</code>实现了<code>two-way</code>交流，例如一个node通过发送一个请求来获得一个回复。</p><p>下面举例说明通过创建<code>client-server</code>模型将<code>Driver.proto</code>信息来回传递，当client发送一个请求，对应的server解析或处理请求并进行回复。通过以下几个步骤即可实现：</p><p><strong>定义request and response messages</strong> 在cyber中所有的信息传递通过<code>protobuf</code>的形式传递。任何的protobuf消息通过序列化/反序列化(相关函数接口实现)可以作为<code>service</code>的请求 回复的消息格式，例如这里采用的Driver消息类型位于examples.proto:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename: examples.proto</span></span><br><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line">package apollo.cyber.examples.proto;</span><br><span class="line">message Driver &#123;</span><br><span class="line">    optional <span class="built_in">string</span> content = <span class="number">1</span>;</span><br><span class="line">    optional uint64 msg_id = <span class="number">2</span>;</span><br><span class="line">    optional uint64 timestamp = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Create a service and a client</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filename: cyber/examples/service.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/cyber.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/examples/proto/examples.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> apollo::cyber::examples::proto::Driver;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    apollo::cyber::Init(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Node&gt; <span class="title">node</span><span class="params">(apollo::cyber::CreatNode(<span class="string">"strat_node"</span>))</span></span>;</span><br><span class="line">    atuo server = node-&gt;CreateService&lt;Driver,Driver&gt;(<span class="string">"test_server"</span>,[](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Driver&gt;&amp; request,<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Drive&gt;&amp; response))&#123;</span><br><span class="line">        AINFO &lt;&lt; <span class="string">"server: I am driver server"</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">uint64_t</span> id = <span class="number">0</span>;</span><br><span class="line">        ++id;</span><br><span class="line">        response-&gt;set_msg_id(id);</span><br><span class="line">        response-&gt;set_timestamp(<span class="number">0</span>);</span><br><span class="line">      &#125;); <span class="comment">//lambda函数实现回调信息</span></span><br><span class="line">    </span><br><span class="line">      <span class="keyword">auto</span> client = node-&gt;CreateClient&lt;Driver, Driver&gt;(<span class="string">"test_server"</span>);</span><br><span class="line">  <span class="keyword">auto</span> driver_msg = <span class="built_in">std</span>::make_shared&lt;Driver&gt;();</span><br><span class="line">  driver_msg-&gt;set_msg_id(<span class="number">0</span>);</span><br><span class="line">  driver_msg-&gt;set_timestamp(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> (apollo::cyber::OK()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> res = client-&gt;SendRequest(driver_msg);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      AINFO &lt;&lt; <span class="string">"client: response: "</span> &lt;&lt; res-&gt;ShortDebugString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      AINFO &lt;&lt; <span class="string">"client: service may not ready."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apollo::cyber::WaitForShutdown();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bazel编译文件的构建：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc_binary(</span><br><span class="line">    name = <span class="string">"service"</span>,</span><br><span class="line">    srcs = [ <span class="string">"service.cc"</span>, ],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">"//cyber"</span>,</span><br><span class="line">        <span class="string">"//cyber/examples/proto:examples_cc_proto"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>编译运行：</strong></p><ul><li>编译service/client: <code>bazel build cyber/examples/...</code></li><li>运行：<code>./bazel-bin/cyber/examoles/service</code></li><li>结果：<code>apollo/data/log/service.INFO</code>中可以查看<code>AINFO</code>的信息。</li></ul><p><strong>注意事项：</strong></p><ul><li>在注册<code>service</code>，<code>node</code>时 注意不能出现重复的名称</li></ul><hr><h3 id="parameter-service">2.3 Parameter service</h3><p>参数服务用于节点之间的参数共享，提供的基本操作为<code>set</code>,<code>get</code>以及<code>list</code>。参数共享是基于上面<code>Service</code>(包含<code>service</code>和<code>client</code>)实现的。</p><p><strong>Parameter Object:</strong> <strong>（1）支持的数据类型：</strong> 通过cyber的所有参数传递是基于<code>apollo::cyber::Parameter</code>类型，下表给出了支持的5种参数类型：</p><table><thead><tr class="header"><th>参数类型</th><th>C++数据类型</th><th>protobuf数据类型</th></tr></thead><tbody><tr class="odd"><td>apollo::cyber::proto::ParamType::INT</td><td>int64_t</td><td>int64</td></tr><tr class="even"><td>apollo::cyber::proto::ParamType::DOUBLE</td><td>double</td><td>double</td></tr><tr class="odd"><td>apollo::cyber::proto::ParamType::BOOL</td><td>bool</td><td>bool</td></tr><tr class="even"><td>apollo::cyber::proto::ParamType::STRING</td><td>std::string</td><td>string</td></tr><tr class="odd"><td>apollo::cyber::proto::ParamType::PROTOBUF</td><td>std::string</td><td>string</td></tr><tr class="even"><td>apollo::cyber::proto::ParamType::NOT_SET</td><td>-</td><td>-</td></tr></tbody></table><p>除了以上五种类型，Parameter同时还有支持protobuf对象作为输入参数的接口。通过序列化处理对象将其转换为STRING类型用于传递。 <strong>（2）创建Parameter对象：</strong> 支持的构造方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parameter();  <span class="comment">// Name is empty, type is NOT_SET</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Parameter</span><span class="params">(<span class="keyword">const</span> Parameter&amp; parameter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Parameter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span></span>;  <span class="comment">// type为NOT_SET</span></span><br><span class="line">Parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="keyword">bool</span> bool_value);</span><br><span class="line">Parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="keyword">int</span> int_value);</span><br><span class="line">Parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="keyword">int64_t</span> int_value);</span><br><span class="line">Parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="keyword">float</span> double_value);</span><br><span class="line">Parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="keyword">double</span> double_value);</span><br><span class="line">Parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; string_value);</span><br><span class="line">Parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="keyword">char</span>* string_value);</span><br><span class="line">Parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg_str,</span><br><span class="line">          <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; full_name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; proto_desc);</span><br><span class="line">Parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> google::protobuf::Message&amp; msg);</span><br></pre></td></tr></table></figure><p>具体使用举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Parameter <span class="title">a</span><span class="params">(<span class="string">"int"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">// proto message Chatter</span></span><br><span class="line">Chatter chatter;</span><br><span class="line"><span class="function">Parameter <span class="title">f</span><span class="params">(<span class="string">"chatter"</span>, chatter)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>（3）接口和数据读取：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ParamType <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">TypeName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Descriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">AsBool</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int64_t</span> <span class="title">AsInt64</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">AsDouble</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">AsString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">DebugString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Parameter <span class="title">a</span><span class="params">(<span class="string">"int"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">a.Name();  <span class="comment">// return int</span></span><br><span class="line">a.Type();  <span class="comment">// return apollo::cyber::proto::ParamType::INT</span></span><br><span class="line">a.TypeName();  <span class="comment">// return string: INT</span></span><br><span class="line">a.DebugString();  <span class="comment">// return string: &#123;name: "int", type: "INT", value: 10&#125;</span></span><br><span class="line"><span class="keyword">int</span> x = a.AsInt64();  <span class="comment">// x = 10</span></span><br><span class="line">x = a.value&lt;<span class="keyword">int64_t</span>&gt;();  <span class="comment">// x = 10</span></span><br><span class="line">x = a.AsString();  <span class="comment">// Undefined behavior, error log prompt</span></span><br><span class="line">f.TypeName();  <span class="comment">// return string: chatter</span></span><br><span class="line"><span class="keyword">auto</span> chatter = f.value&lt;Chatter&gt;();</span><br></pre></td></tr></table></figure><p><strong>Parameter Service</strong> 如果一个node 想要提供Parameter Service给其他节点，则需要创建<code>ParameterService</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Construct a new ParameterService object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param node shared_ptr of the node handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ParameterService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt;&amp; node)</span></span>;</span><br></pre></td></tr></table></figure><p>因为参数存储在<code>parameter service object</code>中，因此可以在ParameterService直接处理，而不需要service request。 <strong>(1）设置parameter对象：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Set the Parameter object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param parameter parameter to be set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetParameter</span><span class="params">(<span class="keyword">const</span> Parameter&amp; parameter)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>(2) 获取parameters对象中参数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the Parameter object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param param_name</span></span><br><span class="line"><span class="comment"> * @param parameter the pointer to store</span></span><br><span class="line"><span class="comment"> * @return true</span></span><br><span class="line"><span class="comment"> * @return false call service fail or timeout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetParameter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; param_name, Parameter* parameter)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>（3）获取parameters对象列表：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get all the Parameter objects</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param parameters pointer of vector to store all the parameters</span></span><br><span class="line"><span class="comment"> * @return true</span></span><br><span class="line"><span class="comment"> * @return false call service fail or timeout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListParameters</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Parameter&gt;* parameters)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Parameter Client:</strong> 如果一个node想要使用其他节点的parameter services,则需要创建一个<code>ParamterClient</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Construct a new ParameterClient object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param node shared_ptr of the node handler</span></span><br><span class="line"><span class="comment"> * @param service_node_name node name which provide a param services</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ParameterClient(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt;&amp; node, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; service_node_name);</span><br></pre></td></tr></table></figure><p>与<code>Parameter Service</code>类似，也可以使用<code>SetParameter</code>,<code>GetParameter</code>和<code>ListParamters</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  apollo::cyber::Init(*argv);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Node&gt; node =</span><br><span class="line">      apollo::cyber::CreateNode(<span class="string">"parameter"</span>);</span><br><span class="line">  <span class="keyword">auto</span> param_server = <span class="built_in">std</span>::make_shared&lt;ParameterServer&gt;(node);</span><br><span class="line">  <span class="keyword">auto</span> param_client = <span class="built_in">std</span>::make_shared&lt;ParameterClient&gt;(node, <span class="string">"parameter"</span>);</span><br><span class="line">  param_server-&gt;SetParameter(Parameter(<span class="string">"int"</span>, <span class="number">1</span>));</span><br><span class="line">  Parameter parameter;</span><br><span class="line">  param_server-&gt;GetParameter(<span class="string">"int"</span>, &amp;parameter);</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"int: "</span> &lt;&lt; parameter.AsInt64();</span><br><span class="line">  param_client-&gt;SetParameter(Parameter(<span class="string">"string"</span>, <span class="string">"test"</span>));</span><br><span class="line">  param_client-&gt;GetParameter(<span class="string">"string"</span>, &amp;parameter);</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"string: "</span> &lt;&lt; parameter.AsString();</span><br><span class="line">  param_client-&gt;GetParameter(<span class="string">"int"</span>, &amp;parameter);</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"int: "</span> &lt;&lt; parameter.AsInt64();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="log-api">2.4 Log API</h3><p>Cyber的log库建立在<code>glog</code>的基础上，需要包含以下头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/common/log.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/init.h"</span></span></span><br></pre></td></tr></table></figure><p><strong>Log configuration:</strong> 默认的配置路径<code>cyber/setup.sh</code> 以下的配置信息可以由开发者自行更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GLOG_log_dir=/apollo/data/<span class="built_in">log</span></span><br><span class="line"><span class="built_in">export</span> GLOG_alsologtostderr=0</span><br><span class="line"><span class="built_in">export</span> GLOG_colorlogtostderr=1</span><br><span class="line"><span class="built_in">export</span> GLOG_minloglevel=0</span><br></pre></td></tr></table></figure><p><strong>Log initialization:</strong> 在代码入口调用<code>Init</code>来初始化log:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apollo::cyber::cyber::Init(argv[<span class="number">0</span>]) is initialized.</span><br><span class="line">If no macro definition is made in the previous component, the corresponding <span class="built_in">log</span> is printed to the binary <span class="built_in">log</span>.</span><br></pre></td></tr></table></figure><p><strong>Log output macro:</strong> 封装的log输出宏：(严重程度依次递推)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADEBUG &lt;&lt; <span class="string">"hello cyber."</span>;</span><br><span class="line">AINFO  &lt;&lt; <span class="string">"hello cyber."</span>;</span><br><span class="line">AWARN  &lt;&lt; <span class="string">"hello cyber."</span>;</span><br><span class="line">AERROR &lt;&lt; <span class="string">"hello cyber."</span>;</span><br><span class="line">AFATAL &lt;&lt; <span class="string">"hello cyber."</span>;</span><br></pre></td></tr></table></figure><p><strong>Log输出Format:</strong> <code>&lt;MODULE_NAME&gt;.log.&lt;LOG_LEVEL&gt;.&lt;datetime&gt;.&lt;process_id&gt;</code></p><p><strong>关于Log文件：</strong> 与原始<code>glog</code>不一样的仅仅在于不同的log级别将会写入相同的log文件中。</p><hr><h3 id="building-a-module-based-on-component">2.5 Building a module based on Component</h3><h4 id="component">2.5.1 component</h4><p><code>component</code>是CyberRT提供用于构建应用模块的基础类。每一个特定功能的应用模块都可以继承<code>Component</code>类并定义它们自己的<code>Init</code>和<code>Proc</code>函数，这样该模块将会被加载到<code>Cyber</code>框架中运行。</p><h4 id="binary-vs-component">2.5.2 Binary vs Component</h4><p>在CyberRT框架下应用有两种配置方式：</p><ul><li><p>基于Binary:各个应用模块被分别编译成不同的binary(二进制可执行文件)，然后通过创建各自的<code>Reader</code>和<code>Writer</code>进行信息交换。</p></li><li><p>基于Component:各个应用模块被编译成shared library。通过继承Component类,并编写相应的dag描述文件,CyberRT框架将会动态的加载运行该应用模块。</p><p><strong>Component的基本组件接口：</strong></p><ul><li><code>Init()</code> 用于算法组件的初始化，是算法组件的入口(相当于各个组件的main)</li><li><code>Proc()</code> 当需要的通道信息发布时，Cyber框架将会调用该函数(实际是一个Reader的回调函数)</li></ul><p><strong>使用Component的优势：</strong></p><ul><li>组件可以通过<code>launch</code>文件加载到不同的进程中，部署更加灵活</li><li>组件可以通过修改<code>dag</code>文件更改接收通道的名称，而不需要重新编译</li><li>组件支持接收多种类型的数据</li><li>组件支持提供多种融合策略</li></ul></li></ul><h4 id="dag文件的形式">2.5.3 Dag文件的形式</h4><p>An example dag file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Define all coms in DAG streaming.</span><br><span class="line">module_config &#123;</span><br><span class="line">    module_library : &quot;lib&#x2F;libperception_component.so&quot;</span><br><span class="line">    components &#123;</span><br><span class="line">        class_name : &quot;PerceptionComponent&quot;</span><br><span class="line">        config &#123;</span><br><span class="line">            name : &quot;perception&quot;</span><br><span class="line">            readers &#123;</span><br><span class="line">                channel: &quot;perception&#x2F;channel_name&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    timer_components &#123;</span><br><span class="line">        class_name : &quot;DriverComponent&quot;</span><br><span class="line">        config &#123;</span><br><span class="line">            name : &quot;driver&quot;</span><br><span class="line">            interval : 100</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>module_library:</strong> 用于加载<code>.so</code>库的路径，其根路径是Cyber的工作路径(与<code>setup.sh</code>相同的路径)</li><li><strong>components/timer_components:</strong> 选择基础组件类型(是否是定时发布,一般传感器的组件用timer_component)</li><li><strong>class_name:</strong> 加载的组件类的名称</li><li><strong>name:</strong> 加载的组件类的标识符（同一组件类可能有不同的配置方式，比如16线，64线激光雷达）</li><li><strong>readers:</strong> 被当前组件接受的数据(Proc函数中处理)，支持1-3各不同通道的数据</li></ul><h4 id="timercomponent-example">2.5.4 (timer)component example</h4><ul><li><p>common_component_example 可以查看<code>cyber/examples/common_component_example/</code>中的示例程序 头文件基本组成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/class_loader/class_loader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/examples/proto/examples.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> apollo::cyber::examples::proto::Driver;</span><br><span class="line"><span class="keyword">using</span> apollo::cyber::Component;</span><br><span class="line"><span class="keyword">using</span> apollo;:cyber::ComponentBase;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommontestComponent</span> :</span> <span class="keyword">public</span> Component&lt;Driver,Driver&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Proc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Driver&gt;&amp; msg0,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Driver&gt;&amp; msg1)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">CYBER_REGISTER_COMPONENT(Commontestcomponent)</span><br></pre></td></tr></table></figure><p>源文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/examples/common_component_sample/common_component_example.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/class_loader/class_loader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/component/component.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Commontestcomponent::Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Commontest component init"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Commontestcomponent::Proc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Driver&gt;&amp; msg0,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Driver&gt;&amp; msg1)</span></span>&#123;</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Start commontest component Proc ["</span> &lt;&lt; msg0-&gt;msg_id() &lt;&lt; <span class="string">"] ["</span></span><br><span class="line">        &lt;&lt; msg1-&gt;msg_id() &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>timer_component_example 参考<code>cyber/examples/timer_component_example/</code> 头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/class_loader/class_loader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/component/component.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/component/timer_component.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/examples/proto/examples.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> apollo::cyber::examples::proto::Driver;</span><br><span class="line"><span class="keyword">using</span> apollo::cyber::Component;</span><br><span class="line"><span class="keyword">using</span> apollo::cyber::ComponentBase;</span><br><span class="line"><span class="keyword">using</span> apollo::cyber::TimerComponent;</span><br><span class="line"><span class="keyword">using</span> apollo::cyber::Writer;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimertestComponent</span> :</span> <span class="keyword">public</span> TimerComponent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Proc</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Writer&lt;Driver&gt;&gt; driver_writer_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line">CYBER_REGISTER_COMPONENT(TimertestComponent)</span><br></pre></td></tr></table></figure><p>源文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/examples/timer_component_example/timer_component_example.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/class_loader/class_loader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/component/component.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/examples/proto/examples.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TimertestComponent::Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">driver_writer_ = node_-&gt;CreateWriter&lt;Driver&gt;(<span class="string">"/carstatus/channel"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TimertestComponent::Proc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> out_msg = <span class="built_in">std</span>::make_shared&lt;Driver&gt;();</span><br><span class="line">    out_msg-&gt;set_msg_id(i++);</span><br><span class="line">    driver_writer_-&gt;Write(out_msg);</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"timertestcomponent: Write drivemsg-&gt;"</span></span><br><span class="line">        &lt;&lt;out_msg-&gt;ShortDebugString();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过bazel编译BUILD文件生成<code>.so</code>文件，通过<code>timer.dag</code>即可运行组件</p></li></ul><p>需要注意的是：</p><ul><li><p>需要注册组件，才能够从通过<code>SharedLiabray</code>加载功能类，注册的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CYBER_REGISTER_COMPONENT(DriverComponent)</span><br></pre></td></tr></table></figure><p>在组件类的头文件的最后添加,如果在注册时使用了<code>namespace</code>，那么在dag文件中也要添加对应的<code>namespace</code></p></li><li><p>Component和TimerComponent的配置是不同的，不要将它们搞混</p></li></ul><h3 id="launch">2.6 Launch</h3><p><code>cyber_launch</code>是CyberRT框架的启动程序。它根据<code>launch</code>文件启动<code>mainboards</code>进程(一个launch文件对应一个进程),并将不同的组件根据dag文件加载到不同的<code>mainboard</code>进程中。<code>cyber_launch</code>支持动态加载组件或启动二进制文件两种场景。 launch文件的格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cyber</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>driver<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dag_conf</span>&gt;</span>driver.dag<span class="tag">&lt;/<span class="name">dag_conf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">process_name</span>&gt;</span><span class="tag">&lt;/<span class="name">process_name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exception_handler</span>&gt;</span>exit<span class="tag">&lt;/<span class="name">exception_handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>perception<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dag_conf</span>&gt;</span>perception.dag<span class="tag">&lt;/<span class="name">dag_conf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">process_name</span>&gt;</span><span class="tag">&lt;/<span class="name">process_name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exception_handler</span>&gt;</span>respawn<span class="tag">&lt;/<span class="name">exception_handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>planning<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dag_conf</span>&gt;</span>planning.dag<span class="tag">&lt;/<span class="name">dag_conf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">process_name</span>&gt;</span><span class="tag">&lt;/<span class="name">process_name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cyber</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Module:</strong> 每一个被加载的组件或二进制文件都是一个module</p><ul><li><strong>name</strong> 被加载的模块的名称</li><li><strong>dag_conf</strong> 对应组件的dag文件</li><li><strong>process_name</strong> 是mainboard开启后对应的进程名称。相同的process_name的组件将会被加载和运行在同一进程中，如果没有设置，将会使用默认的进程。</li><li><strong>exception_handler</strong> 是当进程发生异常是的处理方法。值可以是<code>exit</code>或者<code>respawn</code>，为空则不进行处理。<ul><li>exit ,当异常发生时整个进程需要停止运行。</li><li>respawn，当异常发生时，进程需要重启。</li></ul></li></ul><hr><h3 id="timer">2.7 Timer</h3><p>Timer可用于创建定时任务，以定期运行或只运行一次。</p><h4 id="timer-interface">2.7.1 Timer Interface</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief Construct a new Timer object</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param period The period of the timer, unit is ms</span></span><br><span class="line"><span class="comment">  * @param callback The tasks that the timer needs to perform</span></span><br><span class="line"><span class="comment">  * @param oneshot True: perform the callback only after the first timing cycle</span></span><br><span class="line"><span class="comment">  *                False: perform the callback every timed period</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Timer(<span class="keyword">uint32_t</span> period, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; callback, <span class="keyword">bool</span> oneshot);</span><br></pre></td></tr></table></figure><p>另一种构造方法是，先封装Timer的配置参数，然后调用构造函数： period对应定时器周期，单位为ms,范围(1~512*64ms), callback:对应定时器的回调函数，即周期执行的任务 oneshot:是否只执行一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimerOption</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> period;                 <span class="comment">// The period of the timer, unit is ms</span></span><br><span class="line">  <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; callback;  <span class="comment">// The tasks that the timer needs to perform</span></span><br><span class="line">  <span class="keyword">bool</span> oneshot;  <span class="comment">// True: perform the callback only after the first timing cycle</span></span><br><span class="line">                 <span class="comment">// False: perform the callback every timed period</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Construct a new Timer object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param opt Timer option</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(TimerOption opt)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="start-timer">2.7.2 Start Timer</h4><p>在创建一个Timer实例后，通过<code>Timer::Start()</code>来开启定时器</p><h4 id="stop-timer">2.7.3 Stop Timer</h4><p>通过<code>Timer::Stop()</code>来手动停止一个已经开启的定时器</p><p><strong>Demo：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/cyber.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    cyber::Init(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="function">cyber::Timer <span class="title">timer</span><span class="params">(<span class="number">100</span>,[]()&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cyber::Time::Now() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;，<span class="literal">false</span>)</span></span>;</span><br><span class="line">    timer.Start();</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">//单位s</span></span><br><span class="line">    Timer.Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="time-api">2.8 Time API</h3><p>Time是用于管理时间的类（<strong>注意不不同于Timer</strong>），可以用于当前时间的获取，耗时的计算，时间转换等等。 Time类接口如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructor, passing in a different value to construct Time</span></span><br><span class="line">Time(<span class="keyword">uint64_t</span> nanoseconds); <span class="comment">//uint64_t, in nanoseconds</span></span><br><span class="line">Time(<span class="keyword">int</span> nanoseconds); <span class="comment">// int type, unit: nanoseconds</span></span><br><span class="line">Time(<span class="keyword">double</span> seconds); <span class="comment">// double, in seconds</span></span><br><span class="line">Time(<span class="keyword">uint32_t</span> seconds, <span class="keyword">uint32_t</span> nanoseconds);</span><br><span class="line"><span class="comment">// seconds seconds + nanoseconds nanoseconds</span></span><br><span class="line"><span class="function">Static Time <span class="title">Now</span><span class="params">()</span></span>; <span class="comment">// Get the current time</span></span><br><span class="line"><span class="function">Double <span class="title">ToSecond</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// convert to seconds</span></span><br><span class="line"><span class="function">Uint64_t <span class="title">ToNanosecond</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// Convert to nanoseconds</span></span><br><span class="line"><span class="function">Std::<span class="built_in">string</span> <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// Convert to a string in the format "2018-07-10 20:21:51.123456789"</span></span><br><span class="line"><span class="function">Bool <span class="title">IsZero</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// Determine if the time is 0</span></span><br></pre></td></tr></table></figure><p><strong>Demo:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/cyber.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/duration.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">cyber::Init(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">1531225311123456789U</span>L)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t1.ToString() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">// 2018-07-10 20:21:51.123456789</span></span><br><span class="line">    <span class="comment">//duration time interval</span></span><br><span class="line">    <span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Duration <span class="title">d</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line">    <span class="function">Time <span class="title">t2</span><span class="params">(<span class="number">300</span>)</span></span>;</span><br><span class="line">    assert(d == (t2-t1)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="record-flieread-and-write">2.9 Record flie:Read and Write</h3><h4 id="reading-the-reader-file">2.9.1 Reading the Reader file</h4><p><strong>RecordReader</strong>用于组件在Cyber框架下读取消息。每一个RecordReader可以打开一个已经存在的record文件通过该类的<code>open</code>方法，线程将异步读取recode文件中的信息。用户仅需要执行<code>ReadMessage</code>提取<code>RecordReader</code>中的最新信息，然后通过<code>GetCurrentMessageChannelName</code>,<code>GetCurrentRawMessage</code>,<code>GetCurrentMessageTime</code>来获取信息。 <strong>RecordWriter</strong>用于组件在Cyber框架下记录信息。每一个RecordWriter可以创建一个新的record文件通过<code>Open</code>方法。用户通过<code>WriteMessage</code>和<code>WriteChannel</code>来将<code>message</code>和<code>channel</code>信息写入到record中。</p><h3 id="c-api-directory">2.10 C++ API Directory</h3><h2 id="cyberrt提供的工具">3. CyberRT提供的工具</h2><p>Apollo CyberRT提供了一个可视化工具<code>cyber_visualizer</code>和两个命令行工具<code>cyber_monitor</code>和<code>cyber_recorder</code> 注意：使用工具需要使用apollo docker环境，同时由于所有来自CyberRT的工具都依赖于CyberRT库，因此，在使 用CyberRT的工具之前，需要使用<code>setup.bash</code>为环境设置源文件，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /your-path-to-apollo-install-dir/cyber/setup.bash</span><br></pre></td></tr></table></figure><p><strong>Cyber_visualizer:</strong> 运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyber_visualizer</span><br></pre></td></tr></table></figure><p>交互： 当数据在Cyber RT中通过通道时，所有通道的列表显示在通道名称下，可以通过Cyber RT的record tool(<code>cyber_recorder</code>)从另一个终端重放数据，则<code>cyber_visualizer</code>将接收所有活动通道的信息（来自重放数据）并显示出来。通过单击工具栏中的选项，可以启用参考网格，显示点云，添加图像，或同时显示多个相机的数据。</p><p><strong>Cyber_monitor：</strong> 命令行工具<code>cyber_monitor</code>提供了一个清晰的视图，显示终端中的Apollo Cyber RT实时通道列表信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyber_monitor</span><br></pre></td></tr></table></figure><p>通过<code>-h</code>选项可以获得<code>cyber_monitor</code>的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyber_monitor -h</span><br></pre></td></tr></table></figure><p>通过<code>-c</code>选项，可以指定<code>cyber_monitor</code>的监视通道，：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyber_monitor -c ChannelName</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/apollo-cyber_bash/cyber_monitor.png"></p><p>启动命令行工具后，显示通道名称和通道的数据类型，默认显示为红色，若有数据流经某通道，则通道的相应行显示为绿色。</p><p><strong>Cyber_recorder:</strong> <code>cyber_recorder</code>是Apollo Cyber RT提供的一种录制/回放工具，它提供了许多有用的功能，包括录制，回放，分割，检查录制文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cyber_recorder</span><br><span class="line">usage: cyber_recorder &lt;<span class="built_in">command</span>&gt;&gt; [&lt;args&gt;]</span><br><span class="line">The cyber_recorder commands are:</span><br><span class="line">info                               Show information of an exist record.</span><br><span class="line">play                               Play an exist record.</span><br><span class="line">record                             Record same topic.</span><br><span class="line">split                              Split an exist record.</span><br><span class="line">recover                            Recover an exist record.</span><br></pre></td></tr></table></figure><p>同时，Apollo提供了<strong>Rosbag_to_record</strong>将rosbag转换为Apollo Cyber rt提供的记录器文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rosbag_to_record</span><br><span class="line">Usage:</span><br><span class="line">rosbag_to_record input.bag output.record</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p>Apollo技术文档</p><p>https://github.com/ApolloAuto/apollo/tree/master/docs/cyber</p><p>https://github.com/ApolloAuto/apollo/blob/master/cyber/README.md</p><p>https://mp.weixin.qq.com/s?__biz=MzI1NjkxOTMyNQ==&amp;mid=2247489447&amp;idx=1&amp;sn=23269b689ce753dd541ea95309806d67&amp;chksm=ea1e05d5dd698cc30f044e3496a2d6e35b3fc674fb5ed56a2dd2da7372268abd2eb0b23df173&amp;mpshare=1&amp;scene=1&amp;srcid=0323lDwCkxxrmpZFEo8U6gZk&amp;sharer_sharetime=1584973075048&amp;sharer_shareid=65219e3b4371d83c28538a4abcff3ebf&amp;key=fee875bb7eca81fa43f2e06e9e7810d275a43a15d157bba99821fd3b9c932a98326c26ca8fee73c2d1c4f10cc1a6d3d374d349f695d11f1a66ce172b7899d78e5ba756bbc353a3067fc471e155a455a5&amp;ascene=1&amp;uin=MjU0MTcyMzYzNw%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=A6kdZxOOUE6g8mo3vOd%2BUcM%3D&amp;pass_ticket=oa8DHbLwjRZM4plOFN%2FM7RSGCCQVqNI9RMXwkHnIZDXY%2FJDdElalj3amy8OEJd3j</p><p>Apollo社区：</p><p>https://mp.weixin.qq.com/s/GEmCpKv1S5wSgJFIhr9PgQ</p><p>github:</p><p>https://github.com/daohu527/Dig-into-Apollo</p><p>知乎：</p><p>https://zhuanlan.zhihu.com/p/115046708</p>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> Cyber RT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中radar的相关算法</title>
      <link href="/2020/03/13/apollo-radar-algorithm/"/>
      <url>/2020/03/13/apollo-radar-algorithm/</url>
      
        <content type="html"><![CDATA[<p>apollo中radar的目标检测与跟踪算法</p><a id="more"></a><p>Apollo中<code>radar_detection_component</code>的算法处理入口为<code>Proc</code> ,根据该组件对应<code>dag</code>文件中的<code>reader</code>,在初始化组件时，<code>class RadarDetectionComponent : public cyber::Component&lt;ContiRadar&gt;</code>，该组件继承了含有一个message消息的<code>Component</code>基类，因此在该类初始化时，会创建接收<code>ContiRadar</code>消息类型的<code>reader</code>，回调函数为<code>Proc</code>。</p><p>Proc的输入信息(input_message)包括了：</p><ul><li><code>apollo::drivers::ContiRadar</code></li><li><code>apollo::localization::LocalizationEstimate</code></li></ul><p>输出信息(out_message)包括了：</p><ul><li><code>SensorFrameMessage</code></li></ul><h2 id="预处理">预处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: correct radar raw obstacles.</span></span><br><span class="line"><span class="comment">// @param [in]: raw obstacles from radar driver.</span></span><br><span class="line"><span class="comment">// @param [in]: options.</span></span><br><span class="line"><span class="comment">// @param [out]: corrected radar obstacles</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Preprocess</span><span class="params">(<span class="keyword">const</span> drivers::ContiRadar&amp; raw_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> PreprocessorOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                        drivers::ContiRadar* corrected_obstacles)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>SkipObjects</strong>(raw_obstacles,corrected_obstacles)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 根据时间戳过滤检测物体</span></span><br><span class="line"><span class="comment">// @param [in]: raw obstacles from radar driver.</span></span><br><span class="line"><span class="comment">// @param [out]: corrected radar obstacles</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ContiArsPreprocessor::SkipObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> drivers::ContiRadar&amp; raw_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">    drivers::ContiRadar* corrected_obstacles)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>判断每个原检测物体的时间戳，若该检测物体的时间戳在该数据帧时间戳的<code>(-1e6,0.074)</code>之间则进行处理。</p></li><li><p><strong>ExpandIds</strong>(corrected_obstacles)</p></li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 创建全局id</span></span><br><span class="line"><span class="comment">// @param [in]: corrected radar obstacles</span></span><br><span class="line"><span class="comment">// @param [out]: corrected radar obstacles</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ContiArsPreprocessor::ExpandIds</span><span class="params">(drivers::ContiRadar* corrected_obstacles)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>为corrected obstacles分配id:若目标的<code>meas_state</code>属性为<code>CONTI_NEW</code>即新创建的目标或者corrected obstacles的id未出现过，则为其添加一个，最终当所有的object_id都出现过<code>local2global_[ORIGIN_CONTI_MAX_ID_NUM]</code>将不再变化，同时每个object_id都对应一个固定的id。</p><ul><li><p><strong>CorrectTime</strong>(corrected_obstacles)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 校正时间戳延迟</span></span><br><span class="line"><span class="comment">// @param [in]: corrected radar obstacles</span></span><br><span class="line"><span class="comment">// @param [out]: corrected radar obstacles</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ContiArsPreprocessor::CorrectTime</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    drivers::ContiRadar* corrected_obstacles)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>通过初始化配置时的参数<code>delay_time_</code>(0.07)校正时间戳。</p></li></ul><h2 id="radar-perception">Radar Perception</h2><h3 id="initoptions">InitOptions</h3><p>初始化检测器配置:<code>DetectorOptions detector_options</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetectorOptions</span> &#123;</span></span><br><span class="line">  Eigen::Matrix4d* radar2world_pose = <span class="literal">nullptr</span>;  <span class="comment">//到世界坐标系下的转换</span></span><br><span class="line">  Eigen::Matrix4d* radar2novatel_trans = <span class="literal">nullptr</span>; <span class="comment">//到定位模块的转换</span></span><br><span class="line">  Eigen::Vector3f car_linear_speed = Eigen::Vector3f::Zero(); <span class="comment">//车辆线速度</span></span><br><span class="line">  Eigen::Vector3f car_angular_speed = Eigen::Vector3f::Zero(); <span class="comment">//车辆角速度</span></span><br><span class="line">  base::HdmapStructPtr roi = <span class="literal">nullptr</span>; <span class="comment">//高清地图提供的roi</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<code>TransoforWrapper</code>类根据当前的时间戳分别查询实时的转换矩阵<code>radar2worlld_pose</code> <code>radar2novatel_trans</code> 同时通过<code>GetCarLocalizatonSpeed</code>通过监听节点<code>localization_subscriber_</code>获取实时的车辆的线速度和角速度。</p><p>初始化<code>RoiFiler</code>的配置：<code>RoiFilterOptions roi_filter_options</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RoiFilterOptions</span> &#123;</span></span><br><span class="line">  base::HdmapStructPtr roi = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化一个指向<code>HdmapStruct</code>的指针:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">16</span>)</span> HdmapStruct </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RoadBoundary&gt; road_boundary; <span class="comment">//道路左右边界</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PointCloud&lt;PointD&gt;&gt; road_polygons; <span class="comment">//道路的区域</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PointCloud&lt;PointD&gt;&gt; hole_polygons; <span class="comment">//</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PointCloud&lt;PointD&gt;&gt; junction_polygons; <span class="comment">//道路交叉区域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据之前初始化时导入的<code>hd_map</code>文件，获取Roi区域:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 获取Roi区域(道路边界) 包含road_boundary,road_polygons,hole_polygons,junction_polygons</span></span><br><span class="line"><span class="comment">// @param [in]: pointd(radar相对于世界坐标系原点的位置)</span></span><br><span class="line"><span class="comment">// @param [in]: distance(radar前向探测距离 )</span></span><br><span class="line"><span class="comment">// @param [out]: hdmap_struct_ptr(对应于roi的hd_map数据结构)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HDMapInput::GetRoiHDMapStruct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> base::PointD&amp; pointd, <span class="keyword">const</span> <span class="keyword">double</span> distance,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::HdmapStruct&gt; hdmap_struct_ptr)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// @brief: 获取道路边界和交叉口</span></span><br><span class="line"> <span class="comment">// @param [in]: point(radar相对于世界坐标系原点的位置)</span></span><br><span class="line"> <span class="comment">// @param [in]: distance(radar前向探测距离 )</span></span><br><span class="line"> <span class="comment">// @param [out]: road_boundary_vec </span></span><br><span class="line">     <span class="comment">// @param [out]: junctions_vec </span></span><br><span class="line">     <span class="keyword">if</span> (hdmap_-&gt;GetRoadBoundaries(<span class="built_in">point</span>, distance, &amp;road_boundary_vec,</span><br><span class="line">                                &amp;junctions_vec) != <span class="number">0</span>)&#123; .. &#125;</span><br><span class="line">     ...</span><br><span class="line">      <span class="comment">// Merge boundary and junction</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RoadBoundary&gt; road_boundaries;</span><br><span class="line">      MergeBoundaryJunction(road_boundary_vec, junctions_vec, &amp;road_boundaries,</span><br><span class="line">                            &amp;(hdmap_struct_ptr-&gt;road_polygons),</span><br><span class="line">                            &amp;(hdmap_struct_ptr-&gt;junction_polygons));</span><br><span class="line">      <span class="comment">// Filter road boundary by junction</span></span><br><span class="line">      GetRoadBoundaryFilteredByJunctions(road_boundaries,</span><br><span class="line">                                         hdmap_struct_ptr-&gt;junction_polygons,</span><br><span class="line">                                         &amp;(hdmap_struct_ptr-&gt;road_boundary));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>到此，将detector的配置(主要是坐标的变换矩阵)和roi_filter的配置(主要是道路边界的获取)初始化完成，接下来是感知算法的实现。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 检测和跟踪算法的实现</span></span><br><span class="line"><span class="comment">// @param [in]: corrected_obstacles(经过preprocess之后的radar检测物体)</span></span><br><span class="line"><span class="comment">// @param [in]: options(detector,roifilter,tracker,sensor_name)等的初始化配置</span></span><br><span class="line"><span class="comment">// @param [out]: objects(最终得到的检测物体信息)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RadarObstaclePerception::Perceive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> drivers::ContiRadar&amp; corrected_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> RadarPerceptionOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt;* objects)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="detctor">Detctor:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 在预处理后的corrected_obstacle上检测物体</span></span><br><span class="line"><span class="comment">// @param [in]: corrected_obstacles(经过preprocess之后的radar检测物体)</span></span><br><span class="line"><span class="comment">// @param [in]: options(detector的初始化配置)</span></span><br><span class="line"><span class="comment">// @param [out]: radar_frame(带有所有障碍物信息的frame)</span></span><br><span class="line"><span class="comment">// @note: frame数据类型根据传感器类型和时间戳封装了object数据类型，而SensorFrameMessage又</span></span><br><span class="line"><span class="comment">// 进一步封装了frame数据类型用于各传感器相互之间的信息融合消息类型</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Detect</span><span class="params">(<span class="keyword">const</span> drivers::ContiRadar&amp; corrected_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> DetectorOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">              base::FramePtr radar_frame)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @brief: 将检测物体添加到radar_frame中</span></span><br><span class="line"><span class="comment">// @param [in]: corrected_obstacles(经过preprocess之后的radar检测物体)</span></span><br><span class="line"><span class="comment">// @param [in]: options(detector的初始化配置)</span></span><br><span class="line"><span class="comment">// @param [out]: radar_frame(带有所有障碍物信息的frame)</span></span><br><span class="line">    RawObs2Frame(corrected_obstacles, options, radar_frame);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>RawObs2Frame</code>的具体算法中： 首先根据车辆角速度(novatel坐标系下)计算得到旋转矩阵<code>rotation_novatel</code>,然后再根据<code>novatel</code>和<code>radar</code>之间的旋转关系计算得到<code>radar</code>坐标系下的角速度矩阵,由于角速度是局部坐标系<code>东-北-天</code>下的，因此其角速度矩阵也为相对于该坐标系下。然后，对于<code>corrected_obstacles</code>中的每一个检测物体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                x axis  ^</span></span><br><span class="line"><span class="comment">//                        | longitude_dist</span></span><br><span class="line"><span class="comment">//                        |</span></span><br><span class="line"><span class="comment">//                        |</span></span><br><span class="line"><span class="comment">//                        |</span></span><br><span class="line"><span class="comment">//          lateral_dist  |</span></span><br><span class="line"><span class="comment">//          y axis        |</span></span><br><span class="line"><span class="comment">//        &lt;----------------</span></span><br><span class="line"><span class="comment">//        ooooooooooooo   //radar front surface</span></span><br></pre></td></tr></table></figure><ul><li><p>将目标在radar下的(x,y)坐标转换到统一的世界坐标系(UMT)下存储到object-&gt;center中 <code>radar_object-&gt;center = radar2world * local_loc</code> <code>radar_object-&gt;anchor_point = radar_object-&gt;center</code></p></li><li><p>将radar坐标系下的横轴和纵轴速度转换到世界(相对于东-北-天坐标系)下的速度:</p><p>不同坐标系下角速度或线速度的相互转换需要乘上对应的旋转矩阵，因此由于<code>radar</code>直接得到的是目标相对<code>radar</code>的相对速度，需要将其检测目标的速度转换到(东-北-天)坐标系下,首先得到<code>radar</code>在(东-北-天)坐标系下由于车辆角速度引起的旋转：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rotation_novatel &lt;&lt; <span class="number">0</span>, -angular_speed(<span class="number">2</span>), angular_speed(<span class="number">1</span>), angular_speed(<span class="number">2</span>),</span><br><span class="line">      <span class="number">0</span>, -angular_speed(<span class="number">0</span>), -angular_speed(<span class="number">1</span>), angular_speed(<span class="number">0</span>), <span class="number">0</span>; <span class="comment">//角速度矢量的反对称阵</span></span><br><span class="line">rotation_radar = radar2novatel.topLeftCorner(<span class="number">3</span>, <span class="number">3</span>).inverse() *</span><br><span class="line">                                   rotation_novatel *</span><br><span class="line">                                   radar2novatel.topLeftCorner(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">angular_trans_speed = rotation_radar * local_loc.topLeftCorner(<span class="number">3</span>, <span class="number">1</span>);<span class="comment">//</span></span><br><span class="line">world_vel = radar2world_rotate * (local_vel + angular_trans_speed);</span><br><span class="line">vel_temp =  world_vel + options.car_linear_speed.cast&lt;<span class="keyword">double</span>&gt;();</span><br></pre></td></tr></table></figure><p><code>radar_object-&gt;velocity = vel_temp</code> <strong>注意线速度等于角速度叉乘失径，此处叉乘通过矩阵相乘实现，即为:</strong> <span class="math display">\[\vec{a}\times\vec{b}=\begin{bmatrix}0&amp;-a_3&amp;a_2\\a_3 &amp; 0 &amp;-a_1\\-a_2 &amp; a_1 &amp; 0\end{bmatrix}\vec{b}\triangleq a^{\land}\vec{b}\]</span></p></li><li><p>将<code>corrected_obstacles</code>中的横纵向距离和速度的标准差(<code>dist_rms/vel_res</code>)作为位置和速度不确定度： <code>radar_object-&gt;center_uncertainty = radar2world_rotate * dist_rms * dist_rms.transpose() * radar2world_rotate.transpose()</code> <code>radar_object-&gt;velocity_uncertainty =</code>radar2world_rotate * vel_rms * vel_rms.transpose() *<code>radar2world_rotate.transpose()</code></p></li><li><p>将原检测信息中目标的旋转角度(单位为度，逆时针旋转为正方向)转为弧度，并转换为方向向量,然后将此方向向量转换到世界坐标系下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> local_obj_theta = radar_obs.oritation_angle() / <span class="number">180.0</span> * PI;</span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">direction</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(local_obj_theta)),</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(local_obj_theta)), <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">direction = radar2world_rotate.cast&lt;<span class="keyword">float</span>&gt;() * direction;</span><br></pre></td></tr></table></figure><p><code>radar_object-&gt;direction = direction</code> <code>radar_object-&gt;theta = std::atan2(direction(1),direction(0))</code></p><p>角度的不确定度由检测信息中的<code>oritation_angle_rms</code>标准差确定，也是将角度改为弧度： <code>radar_object-&gt;theta_variance = (radar_obs.oritation_angle_rms() / 180.0 * PI)</code></p></li><li><p>置信度设置为原检测信息中的<code>probexist</code>,即目标存在的概率： <code>radar_object-&gt;confidence = radar_obs.probexist()</code></p></li><li><p>根据原检测信息中的<code>dynprop</code>属性进行确定目标的运动状态(相对于东-北-天坐标系(或者说相对于地面))是运动，静止，还是未知的,若是静止的，将速度置零。</p></li><li><p>根据原检测信息中的<code>obstacle_class</code>确定目标的类别。</p></li><li><p>根据原检测信息中的<code>length</code>,<code>width</code>确定目标的长度和宽度，因为<code>radar</code>无法检测高度信息，将此值设置为车辆模板 2m ,同时对于物体类别未知的点<code>CONTI_POINT</code>，将size设置为1.0m 。</p></li><li><p>最后根据相对<code>radar</code>的物体的x,y坐标，计算距离<span class="math inline">\(local\_range\sqrt{(x^2+y^2)}\)</span> ，即角度<span class="math inline">\(local\_angle = arctan(y/x)\)</span>作为radar检测目标的补充参数<code>radar_supplement</code>。</p></li></ul><h3 id="roifilterhdmapradarroifilter">RoiFilter(HdmapRadarRoiFilter)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// @brief: fliter the objects outside the ROI 过滤出roi区域之外的物体</span></span><br><span class="line"><span class="comment">// @param [in]: options.(hdmap_input信息)</span></span><br><span class="line"><span class="comment">// @param [in / out]: origin total objects / the objects in the ROI.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RoiFilter</span><span class="params">(<span class="keyword">const</span> RoiFilterOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                 base::FramePtr radar_frame)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><p>若<code>roimap</code>中存在有效信息，该函数根据目前检测物体的中心点坐标判断是否位于roi 的<code>road</code> 或者<code>juction</code>的polygons中,若目标中心点位于ROI的polygons中，则将该物体添加到<code>valid_objects</code>中。</p><h3 id="track">Track()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: </span></span><br><span class="line"><span class="comment">// @param [in]: options.</span></span><br><span class="line"><span class="comment">// @param [in]: detected_frame(the objects in the ROI)</span></span><br><span class="line"><span class="comment">// @param [in / out]: tracked_frame (被跟踪物体的信息)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Track</span><span class="params">(<span class="keyword">const</span> base::Frame &amp;detected_frame, <span class="keyword">const</span> TrackerOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">             base::FramePtr tracked_frame)</span></span></span><br></pre></td></tr></table></figure><ul><li><p><strong>TrackObjects(detected_frame)</strong> 获取跟踪目标tracks</p><p>首先跟踪目标的基本信息单位由封装<code>object</code>的<code>RadarTrack</code>定义，而该单元的删除和创建由封装了<code>RadarTrack</code>的<code>RadarTrackManager</code>管理(获取,改变,添加,删除track)，算法的具体由<code>ContiArsTracker</code>实现。</p><ol type="1"><li><p><strong>获取当前跟踪的物体</strong> GetTracks()</p></li><li><p><strong>匹配</strong> matcher_-&gt;Match 由hm_matcher进行检测物体与跟踪物体的关联。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief match radar objects to tracks</span></span><br><span class="line"><span class="comment">// @params[IN] radar_tracks: global tracks</span></span><br><span class="line"><span class="comment">// @params[IN] radar_frame: current radar frame</span></span><br><span class="line"><span class="comment">// @params[IN] options: matcher options for future use</span></span><br><span class="line"><span class="comment">// @params[OUT] assignments: matched pair of tracks and measurements</span></span><br><span class="line"><span class="comment">// @params[OUT] unassigned_tracks: unmatched tracks</span></span><br><span class="line"><span class="comment">// @params[OUT] unassigned_objects: unmatched objects</span></span><br><span class="line"><span class="comment">// @return nothing</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RadarTrackPtr&gt; &amp;radar_tracks,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> base::Frame &amp;radar_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> TrackObjectMatcherOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrackObjectPair&gt; *assignments,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; *unassigned_tracks,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; *unassigned_objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法是首先由于radar原始输出信息中包含了object_id(注意原始radar信息同一id不一定是同一物体)，但是作为一项判断依据，即进行<code>IDMatch</code>的匹配，同时还要求object和track的距离小于一定阈值,其中<span class="math inline">\(c_2\)</span> <span class="math inline">\(c_1\)</span>分别表示object和track的中心点位置,<span class="math inline">\(f(c)=\sqrt{x^2+y^2+z^2}\)</span> <span class="math display">\[0.5*f\{(c_2-(c_1+v_1\times\triangle t))\}+0.5*f\{(c_1-(c_2+v_2\times\triangle t))\}&lt;2.5m\]</span> 满足上述两个条件将对应索引的object关联到track中保存到<code>assignments</code>，并将未匹配的object或track的索引保存到 <code>unassigned_objects</code>和<code>unassigned_tracks</code>中。</p><p>然后将剩下的未分配的object和track建立<code>association_matrix</code>通过<code>gated_hungarian_matcher</code>进行进一步匹配，并将索引保存到<code>assignments</code>中，将此时未分配的<code>track</code>和<code>object</code>索引分别保存到<code>unassigned_tracks</code>和 <code>assigned_objects</code>中。</p><ol start="3" type="1"><li><p><strong>更新已匹配的tracks</strong> <code>UpdateAssignedTracks</code> 将已经有了新的匹配的tracks信息更新到当前新检测的object,更新信息包括目标的中心位置(x,y)速度(<span class="math inline">\(v_x,v_y\)</span>),时间戳，如果采用<code>Adaptive_Kalman_filter</code>,则先经过卡尔曼滤波器的校正然后再更新信息,最后将<code>tracked_times</code>加1,以及跟踪的生命周期<code>tracking_time_+=time_diff</code></p></li><li><p><strong>更新未匹配的tracks</strong> <code>UpdateUnassignedTracks</code> 对于所有未匹配<code>object</code>的<code>track</code>，判断其与当前帧的时间戳之差是否大于0.06s(即超过0.06s未有检测匹配),若是则将其<code>SetDead</code>,当然，若此未分配的<code>track</code>是一个空壳(没有跟踪目标信息),也将其设置为<code>dead</code>。</p></li><li><p><strong>删除跟丢的tracks</strong> <code>DeleteLostTracks</code> 判断当前所有的<code>tracks</code>，若其<code>is_dead</code>则将其从<code>tracks</code>列表中删除。</p></li><li><p><strong>创建新的track</strong> <code>CreateNewTracks</code> 对于剩下的未分配的<code>object</code>,将其创建新的<code>track</code>加入到<code>tracks</code>中。</p></li></ol></li><li><p><strong>CollectTrackedFrame(tracked_frame)</strong> 将<code>RadarTrack</code>数据类型中的对应数据转换到<code>Frame</code>数据结构中</p><ol type="1"><li><p><strong>跟踪确认</strong> <code>ConfirmTrack</code> 对于<code>tracked_times&gt;=3</code>的track,即有超过三次匹配到<code>object</code>，则认为是有一定可靠度的进行下一步处理</p></li><li><p><strong>添加到tracked_frame</strong> 将<code>RadarTrack</code>中的对应信息复制到<code>tracked_frame</code>帧数据结构中，以进行传输。</p></li></ol></li></ul><h2 id="radar-algorithm-supplement">Radar algorithm supplement</h2><h3 id="adaptive-kalman-filter">1.Adaptive Kalman Filter</h3><p><code>radar</code>或<code>camera</code>在进行目标检测时，由于外界环境的突然变化(光照，路面剧烈波动，上下坡等)导致传感器的检测精度受到影响，由于传统的KalmanFilter的更新依赖于先验的量测噪声协方差阵<span class="math inline">\(R\)</span>和过程噪声协方差阵<span class="math inline">\(Q\)</span>,那么此时传感器检测受到影响，而<code>Q,R</code>却并没有改变，即此时系统模型不准确，那么KalmanFilter的结果必然是存在问题的。 对于自适应卡尔曼滤波，</p>状态向量: <span class="math display">\[X=\begin{bmatrix}c_x\\c_y\\v_x\\v_y\end{bmatrix}\]</span> 状态转移矩阵: $$ F=<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; \triangle t &amp; 0\\0 &amp; 1 &amp; 0 &amp; \triangle t \\0 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span><span class="math display">\[过程噪声协方差矩阵：\]</span> Q=<span class="math display">\[\begin{bmatrix}0.074 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 0.074 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0.074 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 0.074\end{bmatrix}\]</span><p>$$ 量测噪声协方差矩阵：根据radar返回的横纵向速度和位置的标准差rms计算得到世界坐标系下的协方差。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dist_rms(<span class="number">0</span>, <span class="number">0</span>) = radar_obs.longitude_dist_rms(); <span class="comment">//纵向距离的标准差</span></span><br><span class="line">    dist_rms(<span class="number">1</span>, <span class="number">1</span>) = radar_obs.lateral_dist_rms(); <span class="comment">//横向距离标准差</span></span><br><span class="line">    vel_rms(<span class="number">0</span>, <span class="number">0</span>) = radar_obs.longitude_vel_rms(); <span class="comment">//纵向速度的标准差</span></span><br><span class="line">    vel_rms(<span class="number">1</span>, <span class="number">1</span>) = radar_obs.lateral_vel_rms(); <span class="comment">//横向速度标准差</span></span><br><span class="line">    radar_object-&gt;center_uncertainty =</span><br><span class="line">        (radar2world_rotate * dist_rms * dist_rms.transpose() *</span><br><span class="line">         <span class="keyword">radar2world_rotate_t</span>) <span class="comment">//世界坐标系下的协方差(R*rms)(R*rms)^T</span></span><br><span class="line">            .cast&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line"></span><br><span class="line">radar_object-&gt;velocity_uncertainty =</span><br><span class="line">    (radar2world_rotate * vel_rms * vel_rms.transpose() *</span><br><span class="line">     <span class="keyword">radar2world_rotate_t</span>)</span><br><span class="line">    .cast&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure><p><span class="math display">\[R=\begin{bmatrix}c_{x\ uncertainty} &amp; 0 &amp; 0 &amp; 0\\0 &amp; c_{y\ uncertainty} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; v_{x\ uncertainty} &amp; 0\\0 &amp; 0 &amp; 0 &amp; v_{y\ uncertainty}\end{bmatrix}\]</span></p><p><strong>预测部分</strong>: <span class="math display">\[x&#39;=Fx\\P&#39;=FPF^T+Q\]</span> <strong>更新部分</strong>: 首先根据该帧检测物体的位置速度的不确定性协方差阵更新<code>R</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r_matrix_.topLeftCorner(<span class="number">2</span>, <span class="number">2</span>) =</span><br><span class="line">    new_object.center_uncertainty.topLeftCorner(<span class="number">2</span>, <span class="number">2</span>).cast&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">r_matrix_.block&lt;<span class="number">2</span>, <span class="number">2</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) =</span><br><span class="line">    new_object.velocity_uncertainty.topLeftCorner(<span class="number">2</span>, <span class="number">2</span>).cast&lt;<span class="keyword">double</span>&gt;();</span><br></pre></td></tr></table></figure><p><span class="math display">\[y = z-Hx&#39;\\S = HP&#39;H^T+R\\K=P&#39;H^TS^{-1}\\x=x&#39;+Ky\\P=(I-KH)P&#39;(I-KH)^T+KRK^T\]</span></p><p>其中<span class="math inline">\(P=(I-KH)P&#39;(I-KH)^T+KRK^T\)</span>与<span class="math inline">\(P=(I-KH)P&#39;\)</span>等价，但是能够保证正定性。</p><p><img src="/2020/03/13/apollo-radar-algorithm/1.jpg" style="zoom:50%;"></p><p>可以看出毫米波雷达的卡尔曼滤波相较于传统的滤波器，<strong>在于其<code>R</code>阵会根据<code>radar</code>提供的标准差实时更新</strong>。</p><h3 id="gatedhungarianmatcher">2. GatedHungarianMatcher</h3>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perception </tag>
            
            <tag> radar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中毫米波雷达的初始化配置</title>
      <link href="/2020/03/11/apollo-radar-init/"/>
      <url>/2020/03/11/apollo-radar-init/</url>
      
        <content type="html"><![CDATA[<p>Apollo中毫米波雷达的初始化相关配置</p><a id="more"></a><h2 id="初始化">初始化</h2><h3 id="外部配置文件">外部配置文件</h3><ol type="1"><li><p>radar component 配置文件 <code>modules/perception/onboard/proto/radar_component_config.proto</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">message RadarComponentConfig &#123;</span><br><span class="line">  optional <span class="built_in">string</span> radar_name = <span class="number">1</span>;</span><br><span class="line">  optional <span class="built_in">string</span> tf_child_frame_id = <span class="number">2</span>;</span><br><span class="line">  optional <span class="keyword">double</span> radar_forward_distance = <span class="number">3</span>;</span><br><span class="line">  optional <span class="built_in">string</span> radar_preprocessor_method = <span class="number">4</span>;</span><br><span class="line">  optional <span class="built_in">string</span> radar_perception_method = <span class="number">5</span>;</span><br><span class="line">  optional <span class="built_in">string</span> radar_pipeline_name = <span class="number">6</span>;</span><br><span class="line">  optional <span class="built_in">string</span> odometry_channel_name = <span class="number">7</span>;</span><br><span class="line">  optional <span class="built_in">string</span> output_channel_name = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置接口：这种读取<code>.pb.txt</code>进行配置的方式是通过<code>GetProtoConfig()</code>函数读取。 这种配置文件一般用于组件的初始化配置，具体是通过<code>cyber</code>进行<code>Component</code>创建时，读取的<code>config_file</code>信息: 可参见文件<code>cyber/proto/component_conf.proto</code>,那么对于具体的每个<code>Component</code>的conf是怎么加载的呢？这个是通过对应功能组件的<code>dag</code>文件进行加载，例如radar的<code>pb.txt</code>加载，其存在前向和后向两种组件：</p><p><code>modules/perception/production/conf/perception/radar/front_radar_component_conf.pb.txt</code></p><p><code>modules/perception/production/conf/perception/radar/rear_radar_component_conf.pb.txt</code></p><p>以<code>front_radar</code>为例，在其<code>front_radar_component_conf.pb.txt</code>中的相关配置如下,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">radar_name: <span class="string">"radar_front"</span></span><br><span class="line">tf_child_frame_id: <span class="string">"radar_front"</span></span><br><span class="line">radar_forward_distance: <span class="number">200.0</span></span><br><span class="line">radar_preprocessor_method: <span class="string">"ContiArsPreprocessor"</span></span><br><span class="line">radar_perception_method: <span class="string">"RadarObstaclePerception"</span></span><br><span class="line">radar_pipeline_name: <span class="string">"FrontRadarPipeline"</span></span><br><span class="line">odometry_channel_name: <span class="string">"/apollo/localization/pose"</span></span><br><span class="line">output_channel_name: <span class="string">"/perception/inner/PrefusedObjects"</span></span><br></pre></td></tr></table></figure><p>那么该配置文件是通过何种方式加载到的程序中呢？正如前面所提到的，是通过 <code>production/dag/dag_sreamimg_perception.dag</code>加载到组件中，作为组件<code>Initialize</code>的参数，并最终在<code>Init()</code></p><p>中载入。</p><p><strong>组件配置总结如下</strong></p><p><strong>Component name</strong>:<code>RadarDetectionComponent</code> <strong>config</strong>: name: <code>&quot;FrontRadarDetection&quot;</code> //组件的node 名称,用于通信 config_file:<code>production/conf/perception/radar/front_radar_component_conf.pb.txt</code> reader_channel: <code>&quot;/apollo/sensor/radar/front&quot;</code> writer_channel: <code>&quot;/perception/inner/PrefusedObjects&quot;</code></p><p><strong>Component name</strong>:<code>RadarDetectionComponent</code> <strong>config</strong>: name: <code>&quot;RearRadarDetection&quot;</code> config_file:<code>production/conf/perception/radar/rear_radar_component_conf.pb.txt</code> reader_channel: <code>&quot;/apollo/sensor/radar/rear&quot;</code><br>writer_channel: <code>&quot;/Preception/inner/PrefusedObjects&quot;</code></p><p>上述两个<code>reader</code>对应<code>conti_radar</code>的<code>Topic</code> 。</p></li><li><p><code>conti_radar</code>硬件驱动配置文件</p><p>conti_radar驱动基于Apollo cyber开发，支持continental ARS。</p><p>radar的默认配置:<code>conf/conti_radar_conf.pb.txt</code>，在<code>radar</code>启动时，会先根据上述配置文件，向can卡发送指令，对<code>radar</code>进行配置，当接收到<code>radar</code>状态信息与用户信息一致是，才开始解析数据并发送消息。</p><p><code>modules/drivers/radar/conti_radar/conf/conti_radar_conf.pb.txt</code> (也有其对应的proto定义)</p><p>运行过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in docker</span></span><br><span class="line"><span class="built_in">cd</span> /apollo</span><br><span class="line"><span class="built_in">source</span> scripts/apollo_base.sh</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">./scripts/conti_radar.sh start</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">./scripts/conti_radar.sh stop</span><br></pre></td></tr></table></figure><p>对应的信息<code>Topic</code></p><p><strong>topic name</strong>:<code>/apollo/sensor/conti_radar</code> <strong>data type</strong>: <code>apollo::drivers::ContiRadar</code> <strong>channel ID</strong>:<code>CHANNEL_ID_ONE</code> <strong>proto file</strong>:<code>modules/drivers/proto/conti_radar.proto</code> (消息格式)</p><p>通过<code>conti_radar.dag</code>加载<code>ContiRadarCanbusComponent</code>和<code>ContiRadarCanbusComponent</code>这两个组件初始化<code>Initialize()</code>中所需的配置文件：</p><p><code>modules/drivers/radar/conti_radar/conf/radar_front_conf.pb.txt</code></p><p><code>modules/drivers/radar/conti_radar/conf/radar_rear_conf.pb.txt</code></p></li></ol><h3 id="初始化程序">初始化程序</h3><ol type="1"><li><p><code>radar_detection_component</code>初始化程序</p><p>通过<code>dag_sreaming_perception.dag</code>导入组件初始化的参数和配置，分别创建front和rear两个雷达组件，并建立其对应的节点node_，并在此节点上创建一个<code>Topic</code>(output_channel_name),同时通过<code>SensorManager</code>类查找是否有该传感器信息，以上是基本配置。</p><p>然后进行算法插件的初始化：<code>InitAlgorithmPlugin()</code> 其中主要包括了以下几个部分：</p><ul><li><p><strong>hdmap</strong>输入初始化 首先需要判断全局标志位<code>FLAGS_obs_enable_hdmap_input</code>是否设置为true,然后进行<code>hdmap_input</code>的初始化， 初始化配置文件亦通过<code>ConfigManager</code>加载<code>hdmap_input.config</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">model_configs &#123;</span><br><span class="line">    name: <span class="string">"HDMapInput"</span></span><br><span class="line">    version: <span class="string">"1.0.0"</span></span><br><span class="line">    integer_params &#123;</span><br><span class="line">        name: <span class="string">"hdmap_sample_step"</span></span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string_params &#123;</span><br><span class="line">        name: <span class="string">"hdmap_file"</span></span><br><span class="line"><span class="meta">#        value: <span class="meta-string">"/home/caros/adu_data/map/base_map.bin"</span></span></span><br><span class="line">        value: <span class="string">"/apollo/modules/map/data/sunnyvale_big_loop/base_map.bin"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面包含了<code>hdmap_file</code>路径，然而程序里貌似使用的是<code>modules/common/configs/config_gflag.cc</code>中的路径,然后加载对应<code>hdmap</code>中的信息,用于后续的<code>roi_filter</code></p></li><li><p><strong>preprocessor</strong> 预处理模块初始化 该算法组件的接口文件位于<code>../radar/lib/interface/base_preprocessor.h</code>中，用于校正<code>radar</code>原始的障碍物输出信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: correct radar raw obstacles.</span></span><br><span class="line"><span class="comment">// @param [in]: raw obstacles from radar driver.</span></span><br><span class="line"><span class="comment">// @param [in]: options.</span></span><br><span class="line"><span class="comment">// @param [out]: corrected radar obstacles</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Preprocess</span><span class="params">(<span class="keyword">const</span> drivers::ContiRadar&amp; raw_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> PreprocessorOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                        drivers::ContiRadar* corrected_obstacles)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>根据配置文件中的<code>radar_preprocessor_method</code>建立对应的preprocessor实例<code>ContiArsPreprocessor</code>。</p><p>这里<code>ContiArsPreprocessor</code>的配置文件加载用的是<code>config_manager.cc</code>中的<code>ConfigManager</code>这个类（这个类通过查找<code>perception_gflags.cc</code>中声明的路径&quot;production/conf/&quot;来载入配置文件<code>*.conf</code>）来载入配置文件 <code>production/conf/perception/radar/modules/conti_ars_preprocessor.config</code>中的参数 &quot;delay_time = 0.07&quot;</p><blockquote><p>注意Apollo中感知部分的全局标志位设置位于<code>../onboard/common_flags_common_flags.cc</code></p><p>默认启用HdMap:<code>DEFINE_bool(obs_enable_hdmap_input, true, &quot;enable hdmap input for roi filter&quot;);</code></p></blockquote></li><li><p><strong>perception</strong>感知模块初始化 该算法组件的接口文件位于<code>../radar/lib/interface/base_radar_obstacle_perception.h</code>中，用于校正<code>radar</code>感知主体算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Perceive</span><span class="params">(<span class="keyword">const</span> drivers::ContiRadar&amp; corrected_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> RadarPerceptionOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt;* objects)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>同样由组件配置文件的参数<code>radar_perception_method: &quot;RadarObstaclePerception&quot;</code>确定实例化的类。</p><p>类似地，该功能模块的参数配置文件为<code>*.config</code>类型，因此也通过<code>ConfigManager</code>类来进行参数加载,</p><p>对于不同的radar，需要加载不同的参数，通过组件配置类中的<code>radar_pipeline_name</code>来确定具体加载的参数配置文件： 对于rear_radar: <code>radar_pipeline_name: &quot;RearRadarPipeline&quot;</code>对应于配置文件<code>rear_radar_pipeline.config</code> 对于<code>front_radar</code>:</p><p>​ <code>radar_pipeline_name:&quot;FrontRadarPipeline&quot;</code>对应配置文件<code>front_radar_pipeline.config</code></p><p>根据对应的配置文件加载参数到<code>RadarObsaclePerception</code>类中,以<code>front_radar</code>为例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">model_configs &#123;</span><br><span class="line">  name: <span class="string">"RearRadarPipeline"</span></span><br><span class="line">  version: <span class="string">"1.0.0"</span></span><br><span class="line">  string_params &#123;</span><br><span class="line">    name: <span class="string">"Detector"</span></span><br><span class="line">    value: <span class="string">"ContiArsDetector"</span></span><br><span class="line">  &#125;</span><br><span class="line">  string_params &#123;</span><br><span class="line">    name: <span class="string">"RoiFilter"</span></span><br><span class="line">    value: <span class="string">"HdmapRadarRoiFilter"</span></span><br><span class="line">  &#125;</span><br><span class="line">  string_params &#123;</span><br><span class="line">    name: <span class="string">"Tracker"</span></span><br><span class="line">    value: <span class="string">"ContiArsTracker"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中包含了三个参数分别对应<code>Percepiton</code>中的三个主要算法的实现类:</p><ul><li><strong>Detector</strong> -&gt; <strong>ContiArsDetector</strong></li><li><strong>RoiFilter</strong> -&gt; <strong>HdmapRadarRoiFilter</strong></li><li><strong>Tracker</strong> -&gt; <strong>ContiArsTracker</strong></li></ul><p>对应的算法接口如下(<code>modules/perception/radar/lib/interface/..</code>)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: detect the objects from the corrected obstacles</span></span><br><span class="line"><span class="comment">// @param [in]: corrected obstacles.</span></span><br><span class="line"><span class="comment">// @param [in]: options.</span></span><br><span class="line"><span class="comment">// @param [out]: detected objects.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Detect</span><span class="params">(<span class="keyword">const</span> drivers::ContiRadar&amp; corrected_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> DetectorOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                    base::FramePtr detected_frame)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: fliter the objects outside the ROI</span></span><br><span class="line"><span class="comment">// @param [in]: options.</span></span><br><span class="line"><span class="comment">// @param [in / out]: origin total objects / the objects in the ROI.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">RoiFilter</span><span class="params">(<span class="keyword">const</span> RoiFilterOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                       base::FramePtr radar_frame)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: tracking objects.</span></span><br><span class="line"><span class="comment">// @param [in]: current object frame.</span></span><br><span class="line"><span class="comment">// @param [in]: options.</span></span><br><span class="line"><span class="comment">// @param [out]: current tracked objects frame.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Track</span><span class="params">(<span class="keyword">const</span> base::Frame &amp;detected_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> TrackerOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">                   base::FramePtr tracked_frame)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>Detect</code>和<code>RoiFilter</code>初始化过程较为简单，而<code>Track</code>的初始化则稍显复杂，其又包括了两个比较重要的实现类</p><p><code>matcher</code>和<code>track_manager</code>。</p><p>​ 进一步地，<code>ContiArsTracker</code>的初始化的参数配置也是由<code>*.config</code>加载的，由<code>ConfigManager</code>加载文件</p><p><code>production/conf/../radar/modules/conti_ars_tracker.config</code>,参数包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">model_configs &#123;</span><br><span class="line">  name:<span class="string">"ContiArsTracker"</span></span><br><span class="line">  version: <span class="string">"1.0.0"</span></span><br><span class="line">  double_params &#123;</span><br><span class="line">    name: <span class="string">"tracking_time_window"</span></span><br><span class="line">    value: <span class="number">0.06</span></span><br><span class="line">  &#125;</span><br><span class="line">  string_params &#123;</span><br><span class="line">    name: <span class="string">"macher_name"</span></span><br><span class="line">    value: <span class="string">"HMMatcher"</span></span><br><span class="line">  &#125;</span><br><span class="line">  string_params &#123;</span><br><span class="line">    name: <span class="string">"chosen_filter"</span></span><br><span class="line">    value: <span class="string">"AdaptiveKalmanFilter"</span></span><br><span class="line">  &#125;</span><br><span class="line">  integer_params &#123;</span><br><span class="line">    name: <span class="string">"tracked_times_threshold"</span></span><br><span class="line">    value: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  bool_params &#123;</span><br><span class="line">    name: <span class="string">"use_filter"</span></span><br><span class="line">    value: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化<code>HMMatcher</code>:</strong> 同样由<code>ConfigManager</code>根据模型名称加载配置文件<code>hm_matcher.config</code>:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model_configs &#123;</span><br><span class="line">  name: <span class="string">"HMMatcher"</span></span><br><span class="line">  version: <span class="string">"1.0.0"</span></span><br><span class="line">  string_params &#123;</span><br><span class="line">    name: <span class="string">"root_path"</span></span><br><span class="line">    value: <span class="string">"./data/perception/radar/models/tracker"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该路径下对应的文件<code>hm_matcher.conf</code>对应参数载入到<code>HMMatcher</code>类内成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max_match_distance : <span class="number">2.5</span></span><br><span class="line">bound_match_distance : <span class="number">10.0</span></span><br></pre></td></tr></table></figure></li></ul><p>最后，进行<code>TransformWrapper</code>类的初始化,包括<code>radar2world</code>和<code>radar2novatel</code>,和坐标转换相关。</p><p>需要注意的是，<code>radar</code>这里订阅了<code>localization</code>的消息，消息通道名称为：<code>/apollo/localization/pose</code>,</p><p><code>MsgBuffer&lt;LocalizationEstimate&gt; localization_subscriber_;</code>由MsgBuffer根据Component中的 <code>odometry_channel_name</code>创建<code>node</code>,名称为<code>pose_radar_front_subscriber</code>并由此node创建reader，以及消息的回调函数,在消息回调函数<code>MsgCallback</code>中，将消息及对应的时间戳存入到<code>buffer_queue_</code>中。</p><p><strong>至此，<code>radar_detection_component</code></strong>的初始化完成,主体算法将在<code>Proc</code>中周期执行。</p><p>​</p></li><li><p><code>conti_radar_canbus_component</code>初始化程序</p><p>通过<code>conti_radar.dag</code>注册组件类<code>conti_radar_canbus_component</code>，其中组件类的参数配置文件为 <code>radar_front(rear)_conf.pb.txt</code>。</p><p>(1)首先，通过配置文件中的<code>can_card_parameter</code>初始化对应的<code>can_client</code>,创建对应的<code>can_client</code>实例。 (2)然后，创建该节点的writer和reader,这里包含两类：</p><ul><li>节点消息发布radar数据:<code>node_-&gt;CreateWriter&lt;ContiRadar&gt;(conti_radar_conf_.radar_channel())</code></li><li>节点消息接收定位信息:<code>pose_reader_ = node_-&gt;CreateReader&lt;LocalizationEstimate&gt;()</code>对应的回调函数为<code>PoseCallback()</code></li></ul><p>(3)创建<code>ContiRadar</code>消息管理管理器<code>sensor_message_manager</code>,并管理radar配置文件和已创建的<code>can_client</code>。 (4)通过<code>can_client</code>和<code>sensor_message_manager</code>初始化创建<code>can_receiver</code>用于接受can信息。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> radar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep CRF with Inter-Object Constraints论文阅读</title>
      <link href="/2020/03/10/deep_crf_tracking/"/>
      <url>/2020/03/10/deep_crf_tracking/</url>
      
        <content type="html"><![CDATA[<p>Deep Continuous Conditional Random Fields With Asymmetric Inter-Object Constraints for Online Multi-Object Tracking</p><p>利用了目标之间的非对称关系。</p><a id="more"></a><p>论文：https://ieeexplore.ieee.org/document/8335792</p><p>DCCRF包含两项：</p><ul><li><p>一元(unary term)项通过基于深度网络提取得到的视觉外观信息(visual appearance)来估计被跟踪目标随时间的移动</p></li><li><p>异步二元(asymmetric pairwise)以异步的形式建模<strong>物体之间</strong>的联系。</p></li></ul><h3 id="疑问">疑问：</h3><ul><li>文章中提到之前的物体之间关联的建立是通过同步的方式(symmetric way),那么什么算是同步的方式，什么算是异步的方式呢？ 文章中给出的解释如图所示</li></ul><p><img src="/2020/03/10/deep_crf_tracking/1.png" style="zoom:75%;"></p><p>深度条件随机场所起到的作用到底是什么呢？</p><h3 id="movements">Movements</h3><ul><li>文章指出之前大部分建立物体间相互作用的模型是基于<code>symmetric</code>对称的数学形式,例如描述彼此之间的相互作用是通过一样的衡量标准</li><li>单个物体的运动以及物体之间的相互作用，在之前的一些工作中大部分是通过人手动去设计模型，而不是通过统一的框架学习得到的</li></ul><p>基于此，文章提出<code>Deep Continuous Conditional Random Field</code>(DCCRF)建立非对称的物体间的相互作用。对于两个临近的trajectories,high-confidence 的跟踪轨迹应该帮助low-confidence的跟踪轨迹更多一些(即所谓的非对称)。</p><p><img src="/2020/03/10/deep_crf_tracking/2.png" style="zoom:75%;"></p><h3 id="how-to-do-it">How to do it</h3><p>​ 通过向DCCRF中输入两帧（<code>t,t-1</code>）连续图像以及到<code>t-1</code>时刻被跟踪目标的跟踪轨迹(trajectories),然后估计在<code>t</code>时刻被跟踪目标的位置。 ​ DCCRF通过两个方面优化目标函数： ​ （1）估计单独个体的运动模式的一元项。通过CNN训练估计从<code>t-1</code>到<code>t</code>时刻物体的位移<code>(displacement)</code> ​ （2）建模被跟踪目标相互作用的非对称二元项。意在解决目标遮挡、目标误识别、相机移动产生的问题。</p><ul><li><p>条件随机场简介</p></li><li><p>改进的孪生网络</p><ul><li><p>视觉匹配置信度计算</p><p>将两个图像块在颜色通道上进行级联，具体操作：先裁剪要对比的目标，然后将大小统一为<code>224*224*3</code>，在颜色通道上进行级联得到<code>224*224*6</code> 输入到网络中，最后计算交叉熵损失。</p></li><li><p>位移预测网络</p><p>在该框架下，通过CNN预测目标从第<code>n-1</code>帧到<code>n</code>帧图像的像素位移。对于每一条跟踪链(trajecotry),通过裁剪第<code>n-1</code>帧图像和第<code>n</code>帧图像，然后在颜色通道上级联送入卷积神经网络，输出即为目标偏移量。</p><p><img src="/2020/03/10/deep_crf_tracking/3.png"></p><p>如图所示，在已知现有目标位置基础上，裁剪一个高为原始目标的2倍，宽为原始目标5倍的图像块，其中原始目标置于图像块的正中心。在将要跟踪的图像的同样位置裁剪一个同样大小的图像块，然后与上一步得到的图像块在颜色通道进行级联，作为CNN的输入。</p></li></ul></li><li><p>目标关系分析 通过高准确度的跟踪链来修正低准确度的跟踪链(trajectory),（小框对于大框的影响应该远大于大框对小框的影响，同理高confidence的跟踪链对于低confidence的跟踪链大于低confidence对高confidence的影响） <img src="/2020/03/10/deep_crf_tracking/5.png"> 上图中，图(a)展示两个跟踪目标咋i<code>t-1</code>时刻的跟踪位置，以及各自的速度。图(b)是其他方法假设的<code>对称性</code>约束，图(c)展示了当检测框不准确时，对称性目标关系约束的局限性。图(d)展示了非对称目标关系约束，通过小目标的运动关系修正大部表的错误预测。 因此，目标关系的建模必须考虑目标关系的不对称性，即单向性。常见的可以反映目标不对称性的信号有：目标大小、目标速度以及目标距离等。同时由检测得到的边界框的<strong>置信度</strong>也可以用于目标关系的建模，<strong>即用高置信度的检测框所匹配的跟踪链来推导低置信度的检测框所匹配的跟踪链。</strong>此时可以利用带置信度的位移预测网络，对目标间的非对称性建模。</p></li><li><p>目标交互建模</p><p>当处理第<code>n</code>帧图像时，第<code>n-1</code>帧图像中的跟踪链和第<code>n</code>帧图像中的检测框输入到整个网络，获得第n帧图像的跟踪链。整个框架由一个CNN构成的一元项和描述目标之间非对称关系的二元项组成。一元项为上述的<strong>位移预测网络</strong>，二元项由目标之间的<strong>速度差、置信度差和面积比例</strong>构成。在这套框架下，利用小框和高置信度的跟踪链去修正大框及低置信度的跟踪链。 之前的计算还未用到第<code>n</code>帧检测的物体，因此在上一步基础上，通过<code>匹配置信度计算网络</code>和<code>匈牙利算法</code>进行它们之间的数据关联。</p><ul><li><p>总体框架</p><p>基于卷积神经网络的一元项和基于条件随机场的非对称二元项。 <img src="/2020/03/10/deep_crf_tracking/6.png"></p><p><strong>一元项的定义：</strong>假设第<code>n-1</code>帧和第<code>n</code>帧之间存在<code>k</code>个运动的目标，并设这<code>k</code>个目标相对于上一帧图像中对应目标中心点的位移为<span class="math inline">\(d=d_1,\dots,d_k\)</span>。深度连续条件随机场通过其他目标的位移<span class="math inline">\((d_j)_{j\neq i}\)</span>来优化<span class="math inline">\(d_i\)</span>,所以需要较为精准的初始化<span class="math inline">\(\hat{d}=\hat{d_1},\dots,\hat{d_k}\)</span> ,此即为一元项。通过一元项让深度连续条件随机场的输出只能在一元项周围波动，即以位移预测网络的结果为准，但对某些错误的预测进行修正。 对于第<code>i</code>条跟踪链<span class="math inline">\(r_i\)</span>,<strong><u>一元项表示如下</u></strong> <span class="math display">\[\varphi(d_i,r_i,I)=w_{i,1}(d_i-f_d(r_i,I))^2\]</span> 其中<span class="math inline">\(f_d\)</span>为位移预测卷积神经网络，<code>I</code>为输入的第<code>n-1</code>和<code>n</code>帧图像，其中<span class="math inline">\(w_{i,1}\)</span>通过下式获得 <span class="math display">\[w_{i,1}=\sigma(a_1max(c_i)+b_1)\]</span> 其中<span class="math inline">\(a_1\)</span>和<span class="math inline">\(b_1\)</span>为权重参数，<span class="math inline">\(c_i\)</span>为位置预测卷积神经网络输出的位移置信度。位移预测网络定义了400个位置框，并从左到右依次编号，且最终每个位置框都有一个置信度，论文中采用最大的置信度位置作为唯一预测值。 <strong>非对称二元项的定义：</strong> 非对称二元项基于目标之间的关系，<strong>用来对目标的预测值做进一步修正</strong>。为了解决全局运动的问题，论文假设第<code>n-1</code>帧和第<code>n</code>帧的目标速度不变。 <span class="math display">\[\psi(d_i,d_j,r_i,r_j,I)=(1-w_{i,1})\sum_k{w_{ij,2}^{(k)}(\vartriangle d_{ij}-\vartriangle s_{ij})}^2\]</span> 其中<span class="math inline">\(\vartriangle d_{ij}=d_i-d_j\)</span>为目标<code>i</code>和目标<code>j</code>在第<code>n</code>帧图像的位移差分(可以看作是速度差分)， <span class="math inline">\(\vartriangle s_{ij}=s_i-s_j\)</span>为目标<code>i</code>和目标<code>j</code>在第<code>n-1</code>帧图像的速度差分， <span class="math inline">\(w_{ij,2}^{(k)}\)</span>为一系列可以学习的参数，用来控制不同目标之间非对称性的影响大小。</p><p>由于一般来说大目标的检测框往往比小的检测框催在更大的噪声，因此，小的目标的信息应该对大的目标信息影响大，而反过来大的目标的信息应该对小的目标影响小；位移预测网络中高置信度的位移预测用于修正低置信度的位移预测。 定义<strong>二元项</strong>的形式如下： <span class="math display">\[w_{ij,2}^{(k)}=\sigma(a_{21}^{(k)}log(area_i/area_j)+b_{21}^{(k)})\times\sigma(a_{22}^{(k)}(max(c_i)-max(c_j))+b_{22}^{(k)})\]</span> 其中，<span class="math inline">\(\sigma\)</span>为逻辑回归函数，<span class="math inline">\(area_i\)</span>表示第<code>i</code>条跟踪链在<code>n-1</code>帧图像上的大小。通过位移预测网络<span class="math inline">\(max(c_i)\)</span>从<span class="math inline">\({c_i^1,c_i^2,\dots,c_i^m}\)</span>中获得最大位移置信度，其中<span class="math inline">\(a_{21}^{(k)},b_{21}^{(k)},a_{22}^{(k)},b_{22}^{(k)}\)</span>为可学习的参数。</p></li></ul></li></ul><p>通过<code>mean-field</code>来近似求解全局最大后验边缘概率，<strong>最优位移估计值</strong>是能量函数均值，</p><h3 id="conclusion">Conclusion</h3><p>更多概率图模型的内容可参考： <a href="http://www.huaxiaozhuan.com/统计学习/chapters/16_CRF.html" target="_blank" rel="noopener">http://www.huaxiaozhuan.com/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/chapters/16_CRF.html</a></p><p>http://bjlkeng.github.io/posts/variational-bayes-and-the-mean-field-approximation/</p><p>https://www.jianshu.com/p/43318a3dc715</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> track </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中的标定</title>
      <link href="/2020/03/10/an-online-learned-crf/"/>
      <url>/2020/03/10/an-online-learned-crf/</url>
      
        <content type="html"><![CDATA[<p>An Onlined Learned CRF Model for Multi-Target Tracking 论文阅读： 通过CRF模型建立Target之间的关联</p><a id="more"></a><p>将Online learned CRF 转换为能量函数最小的问题</p><figure><img src="/2020/03/10/an-online-learned-crf/image-20200306210730340.png" alt="image-20200306210730340"><figcaption>image-20200306210730340</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标跟踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cuda-learn</title>
      <link href="/2020/03/10/cuda-learn/"/>
      <url>/2020/03/10/cuda-learn/</url>
      
        <content type="html"><![CDATA[<p>CUDA编程基础知识</p><a id="more"></a><h2 id="cuda程序层次结构">CUDA程序层次结构</h2><p>特点：</p><ul><li>GPU上有很多并行化的轻量级线程</li><li>kernel在device上执行时实际上时启动很多线程，一个kernel所启动的所有线程称为一个网格(grid)</li><li>同一个网格上的线程共享相同的全局内存空间，grid是线程结构的第一层次</li><li>网格又可以分为许多线程块(block),一个线程块里面有很多线程，这是第二个层次</li><li>wrap：32个线程为一组，这是第三个层次。</li></ul><p>其中grid和block都是定义为dim3类型的变量，dim3可以视为包含三个无符号整数(x,y,z)成员的结构变量，在定义时，缺省值为1，因此grid和block可以灵活的定义为1-dim,2-dim,3-dim。</p><p>定义的grid和block如下所示，kernel在调用时也必须通过执行配置的<code>&lt;&lt;&lt;grid,block&gt;&gt;&gt;</code>来指定kernel所使用的线程数及结构，需要注意的是不同的GPU架构，grid和block的维度有限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;<span class="comment">//grid含有3*2个block</span></span><br><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">5</span>,<span class="number">3</span>)</span></span>;<span class="comment">//每个块有5*3个线程 总共有6*15=90个线程</span></span><br><span class="line">kernel_func&lt;&lt;&lt;grid,block&gt;&gt;&gt;(prams...);</span><br><span class="line"></span><br><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">100</span>,<span class="number">120</span>,<span class="number">32</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">16</span>,<span class="number">16</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">kernel_func&lt;&lt;&lt;grid,block&gt;&gt;&gt;(prams...);</span><br></pre></td></tr></table></figure><h2 id="cuda内置变量">CUDA内置变量</h2><ul><li>一个线程需要两个内置的坐标变量（<code>blockIdx,threadIdx</code>）来唯一标识，它们都是dim3类型变量，其中blockIdx指明线程所在的grid中的位置，而threadIdx指明线程所在的block中的位置：</li><li>其中<code>threadIdx</code>包含三个值：<code>threadIdx.x,threadIdx.y,threadIdx.z</code></li><li><code>blockIdx</code>同样包含三个值：<code>blockIdx.x,blockIdx.y,blockIdx.z</code></li></ul><p>逻辑循序：x&gt;y&gt;z(按照一维排列)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">5</span>,<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>则block的一维排列为：(0,0),(1,0),(2,0),(0,1),(1,1),(2,1) 每个block中thread的排列为:(0,0),(1,0),(2,0),(3,0),(4,0),(0,1),(1,1),(2,1),(3,1),(4,1),(0,2),(1,2),(2,2),(3,2),(4,2) 即先x变</p><p>根据这个排列方式，可得全局一维索引。</p><h2 id="gpu内存模型">GPU内存模型</h2><ul><li>每个线程有自己的私有本地内存（local memory）</li><li>每个线程块(block)又包含共享内存(shared memory)，可以被线程块所有线程共享，其生命周期与线程块一致。</li><li>所有的线程都可以访问全局内存(Global Memory).</li><li>访问一些制度内存块：常量内存(Constant Memory)和纹理内存(Texture Memory)</li><li>L1 cache ,L2 cache</li></ul><blockquote><p>全局内存空间很大（就是所谓的显存），但访问速度很慢，而共享内存访问速度很快。</p></blockquote><p>在kernel核函数中使用如下修饰符的内存，称为共享内存： <code>__shared__</code> 可以被块<code>block</code>中所有的线程访问,使用共享内存时需要注意，不要因为过度使用共享内存而导致SM上活跃的线程束减少，一个线程块所使用的共享内存过多，导致更多的线程块没有办法被SM（shared memory）启动，影响活跃的线程束数量。 共享内存在核函数中声明，生命周期和线程块一致，线程块运行开始，此块的共享内存被分配，当此块结束，则共享内存被释放。</p><p>共享内存由于块内所有线程可见，所以存在竞争的问题，为了避免内存竞争，可以通过使用同步语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __syncthreads();</span><br></pre></td></tr></table></figure><p>语句相当于在线程块执行时各个线程的一个障碍点，当块内所有线程都执行到本障碍点的时候才能进行下一步的计算，显然频繁使用该函数会影响内核的执行效率。</p><h2 id="内存使用">内存使用</h2><ul><li>CUDA程序会使用GPU内存和CPU内存</li><li>GPU上内存设计分配和释放，使用CUDA提供的库函数实现</li><li>CUDA/GPU内存与CPU内存的互相传输</li></ul><h3 id="全局内存和共享内存的管理">全局内存和共享内存的管理</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>apollo编译遇到的一些问题</title>
      <link href="/2020/03/09/perception-build/"/>
      <url>/2020/03/09/perception-build/</url>
      
        <content type="html"><![CDATA[<p>apollo感知部分编译遇到的一些问题</p><a id="more"></a><p>glog cmake 编译的问题</p><p>glog 原生不支持cmake，将<code>FindGlog.cmake</code>添加到CMake的模块目录下</p><p>http://www.yeolar.com/note/2014/12/20/glog/</p><p>http://senlinzhan.github.io/2017/10/07/glog/</p><p>https://blog.csdn.net/dbzhang800/article/details/6329314</p><p>如果gflags也是从包管理器安装的，则使用cmake 也需要findGFlags.cmake</p><p>http://www.yeolar.com/note/2014/12/14/gflags/</p><p>glog学习</p><p>https://izualzhy.cn/glog</p><p>protobuf可能遇到的问题</p><p>https://111qqz.github.io/2018/04/protobuf-notes/</p><p>google 开源风格</p><p>https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/</p><p>https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/</p><p>命名空间相互污染</p><p>using namespace</p><p>glog的使用</p><p>https://www.cnblogs.com/JZ-Ser/articles/7909800.html</p><p>gtest的使用</p><p>https://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html</p><p>blob</p><p>原caffe中的blob不支持bool和uint8_t类型的数据</p><p>https://cloud.tencent.com/developer/article/1394880</p><p>并发编程</p><p>https://chenxiaowei.gitbook.io/cpp_concurrency_in_action/1.0-chinese</p><p>计算confidence处存在的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct CmpByValue &#123;</span><br><span class="line">    bool operator()(const PAIR &amp;lhs, const PAIR &amp;rhs) &#123;</span><br><span class="line">        return lhs.second &lt;&#x3D; rhs.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NMS排反了.</p><h3 id="blob-中的offset-与opencv中通过mat.ptrn快速实现各行像素元素的访问">blob 中的offset 与opencv中通过Mat.ptr(n)快速实现各行像素元素的访问</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习服务器搭建</title>
      <link href="/2020/03/09/dl-frame-build/"/>
      <url>/2020/03/09/dl-frame-build/</url>
      
        <content type="html"><![CDATA[<p><a href="https://aimuch.com/2019/03/17/搭建深度学习服务器环境/" target="_blank" rel="noopener">https://aimuch.com/2019/03/17/%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83/</a></p><a id="more"></a><p>安了一晚上的caffe,</p><p>​ caffe 与 anaconda有很多包冲突的地方，八字不合</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HMM隐马尔科夫模型</title>
      <link href="/2020/03/09/hmm/"/>
      <url>/2020/03/09/hmm/</url>
      
        <content type="html"><![CDATA[<p>隐马尔科夫模型的基础知识</p><a id="more"></a><p><img src="/2020/03/09/hmm/1.png"> <img src="/2020/03/09/hmm/2.png"> <img src="/2020/03/09/hmm/3.png"> <img src="/2020/03/09/hmm/4.png"> <img src="/2020/03/09/hmm/5.png"> <img src="/2020/03/09/hmm/6.png"> <img src="/2020/03/09/hmm/7.png"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中的detector</title>
      <link href="/2020/03/09/apollo-detector/"/>
      <url>/2020/03/09/apollo-detector/</url>
      
        <content type="html"><![CDATA[<p>Apollo中Detector的相关结构 <a id="more"></a></p><h2 id="kitti数据结构">KITTI数据结构</h2><p>kitti数据集采集方式参考http://www.cvlibs.net/datasets/kitti/setup.php <img src="/2020/03/09/apollo-detector/passat_sensors_920.png" style="zoom:50%;"></p><p>数据集的标签形式： <img src="/2020/03/09/apollo-detector/kitti_label.png" style="zoom:80%;"></p><p>label描述:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#Values    Name      Description</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">   1    type         Describes the type of object: &#39;Car&#39;, &#39;Van&#39;, &#39;Truck&#39;,</span><br><span class="line">                     &#39;Pedestrian&#39;, &#39;Person_sitting&#39;, &#39;Cyclist&#39;, &#39;Tram&#39;,</span><br><span class="line">                     &#39;Misc&#39; or &#39;DontCare&#39;</span><br><span class="line">   1    truncated    Float from 0 (non-truncated) to 1 (truncated), where</span><br><span class="line">                     truncated refers to the object leaving image boundaries</span><br><span class="line">   1    occluded     Integer (0,1,2,3) indicating occlusion state:</span><br><span class="line">                     0 &#x3D; fully visible, 1 &#x3D; partly occluded</span><br><span class="line">                     2 &#x3D; largely occluded, 3 &#x3D; unknown</span><br><span class="line">   1    alpha        Observation angle of object, ranging [-pi..pi]</span><br><span class="line">   4    bbox         2D bounding box of object in the image (0-based index):</span><br><span class="line">                     contains left, top, right, bottom pixel coordinates</span><br><span class="line">   3    dimensions   3D object dimensions: height, width, length (in meters)</span><br><span class="line">   3    location     3D object location x,y,z in camera coordinates (in meters)</span><br><span class="line">   1    rotation_y   Rotation ry around Y-axis in camera coordinates [-pi..pi]</span><br><span class="line">   1    score        Only for results: Float, indicating confidence in</span><br><span class="line">                     detection, needed for p&#x2F;r curves, higher is better.</span><br></pre></td></tr></table></figure></blockquote><h2 id="多任务yolo--3d">多任务YOLO -3D</h2><ul><li><p><strong>3D bounding box描述</strong></p><p><img src="/2020/03/09/apollo-detector/3d_bbox.png" style="zoom:80%;"></p><p>​ 对任意相机坐标系下的障碍物3D bbox有9个自由度，因此可以由9个参数表示（中心点<span class="math inline">\(T={\{X,Y,Z}\}\)</span>,长宽高<span class="math inline">\(D=\{L,W,H\}\)</span>,以及各坐标轴旋转角<span class="math inline">\(R=\{\phi,\varphi,\theta\}\)</span>）,等价与3D框的8点描述(需要24个参数)。</p><p>​ 由3D bbox通过相机内参投影即可获得2D bbox　但是反之直接由2D bbox得到完整3D bbox是不可行的。</p><p>​ 首先通过一些假设简化需要获取的3D框参数数量：</p><p>​ １）地面平行假设：</p><p>​ - 通过假设地面平行，则3D障碍物只沿垂直地面的坐标轴旋转，另两个方向并未旋转，即只有yaw偏移角度， 令roll和pitch的旋转角均为0</p><p>​ - 此时，障碍物中心高度与相机高度相当，可简化认为障碍物Z=0</p><p><img src="/2020/03/09/apollo-detector/2dto3d.png" style="zoom:80%;"></p><p>​ 通过成熟的2D障碍物检测算法，可以较准确的得到图像上2D边界框的像素位置(<span class="math inline">\(h,w,c_x,c_y\)</span>)</p><p>​ 对3D障碍物的6维描述中，可以选择神经网络来预测方差较小的参数，例如障碍物的真实物理大小(同类别的障碍物的物理大小不会出现量级上的偏差)，同时yaw旋转角度也能较容易的预测。</p><p>​ 目前，无法通过训练直接得到的参数是障碍物中心相对相机坐标系的偏移量X和Y,若得到X和Y，即通过<span class="math inline">\(\sqrt{X^2+Y^2}\)</span>计算得到在同一水平面上障碍物离相机的真实距离，也就是实现了单目测距。</p><p>实现单目相机3D障碍物检测所需的步骤总结如下：</p><ol type="1"><li>训练网络，预测大部分参数：</li></ol><ul><li>图像中障碍物2D bbox检测</li><li>障碍物物理（真实）尺寸（依据同类别物体的方差较小）</li><li>相对偏转角yaw(不因障碍物在图像中位置所影响)</li></ul><ol start="2" type="1"><li>通过图像几何学方法，计算障碍物中心点相对相机坐标系的偏移量X分量和Y分量( <span class="math inline">\(T={X,Y,0}\)</span>)</li></ol></li><li><p><strong>实现多任务的输出</strong>：</p><p>​ 目标检测的2D bbox(单位为像素),3D真实物体尺寸(长宽高，单位为米)，障碍物的类别以及障碍物的相对偏转角(alpha与kitti数据集定义相同)</p><p>​ 模型训练需要注意： ​ (1) 确保数据集标注质量，尤其是3D障碍物框。可借助激光雷达辅助标注</p><p>​ (2) 定义合适的损失函数，可以参考[3D Bounding Box Estimation Using Deep Learning and Geometry][https://arxiv.org/abs/1612.00496]</p><p>​ (3) 相关数据增强，避免过拟合，左右对称翻转有意义，上下翻转无意义。</p><p>​ (4) anchor和yolo相同，是通过聚类获得的。</p><p>​</p><p>在训练完成获得上述参数之后，接下来需要考虑如何计算出障碍物里相机的距离，通过内参矩阵和几何学关系，联系图像中3D障碍物大小（像素）和真实3D坐标系下障碍物大小(单位为米)之间的关系。</p><p><img src="/2020/03/09/apollo-detector/3dbox.png"></p><p>通过单视图衡量([single view metrology][http://ieeexplore-ieee-org-s.ivpn.hit.edu.cn:1080/document/791253])来解释此几何关系：任一物体，已知其实际的长宽高、朝向和距离，则它在图像中的具体形状大小唯一确定，反之亦然。（此处，我们通过物体图像尺寸、实际物理尺寸和朝向角推断物体距离）</p><p>对于每种障碍物，根据其平均尺寸，建立查询表，覆盖360度yaw角度变化，来映射不同的距离，查询表可以定义单位标尺(例如在图像某个2d位置上，高一米的障碍物在图像上有多高）通过单位标尺对应的像素数目，快速查到车的真实高度。</p><p>综上，Apollo中单目相机下的障碍物检测流程为如下图所示，检测速度可达30hz以上。 <img src="/2020/03/09/apollo-detector/3dobstacle_pipe.png"></p></li></ul><p>输入单幅图像－》通过网络预测大部分参数－》基于单视图度量方法，预测剩余参数(距离和中心点坐标) 其中,在车辆颠簸的情况下，相机内参基本不会发生变化，而外参可以借助在线标定(online calibration)得到实时的外参，提高单目测距的准确性。可以通过车道线来校准，两条平行线无穷远处相交，通过车道线信息，可以帮助我们在线调整传感器标定。</p><p>提高单目测距准确性的方法： (1)借助跟踪算法的上下帧之间的关联性，修正物体朝向和速度 (2)激光雷达和毫米波雷达能够提供准确的测距信息，进行传感器融合。 (3)若物体有遮挡，则要求神经网络能够预测遮挡程度的百分比，并根据遮挡情况给出更准确的距离判断。 (4)最终和其他传感器的融合进行测距是必不可少的，当地面坡度不平时，单目相机检测结果在进行传感器融合时，参考应 该降低，融合时是做graph-graph之间的匹配，不需要过度担心相机的准确率。</p><h2 id="apollo中的yolo3d">Apollo中的YOLO3D</h2><p><img src="/2020/03/09/apollo-detector/yolo3dr4.png"></p><p><img src="/2020/03/09/apollo-detector/areaid.png"></p><p><strong>outout_blobs</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">loc_pred</span><br><span class="line">obj_pred</span><br><span class="line">cls_pred</span><br><span class="line">ori_pred</span><br><span class="line">dim_pred</span><br><span class="line">brvis_pred</span><br><span class="line">brswt_pred</span><br><span class="line">ltvis_pred</span><br><span class="line">ltswt_pred</span><br><span class="line">rtvis_pred</span><br><span class="line">rtswt_pred</span><br><span class="line">area_id_pred</span><br><span class="line">vis_pred</span><br><span class="line">cut_pred</span><br><span class="line">conv9</span><br><span class="line">conv10</span><br><span class="line">conv3_3</span><br></pre></td></tr></table></figure><h2 id="cuda编程">CUDA编程</h2><p>核函数使用方法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;&lt;&lt;griddim,blockdim,<span class="keyword">extern</span> shared memory,GPU stream&gt;&gt;&gt;(param...);</span><br></pre></td></tr></table></figure></p><p>其中中间参数可以控制核函数运行所占用的资源： <code>griddim</code>为调用的block数，<code>blockdim</code>为调用的thread数，后面两个参数分别表示动态定义共享内存大小和可使用的SM处理器数。</p><p><img src="/2020/03/09/apollo-detector/cuda_block.png" style="zoom:50%;"></p><p>kernel函数的定义采用<code>__global__</code>修饰符修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resize_linear_kernel &lt;&lt; &lt; grid, block &gt;&gt; &gt;</span><br><span class="line">      (src.gpu_data(), dst-&gt;mutable_gpu_data(),</span><br><span class="line">          origin_channel, origin_height, origin_width,</span><br><span class="line">          stepwidth, height, width, fx, fy);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/09/apollo-detector/kenelprogram.png"></p><h2 id="tensorrt">TensorRT</h2><p>官方开发手册：https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#c_topics</p><p>参考博客:https://www.cnblogs.com/vh-pg/p/11680658.html</p><p>模型从导入TensorRT到执行<code>inference</code>大致经过一下三个阶段:</p><ul><li>Network Definition</li><li>Builder</li><li>Engine</li></ul><p>使用过程中首先通过<code>TensorRT</code>的全局方法<code>creatInferBuilder()</code>创建一个<code>IBuilder</code>类指针，然后由该指针调用<code>IBuilder</code>类创建<code>Network</code>和<code>Engine</code>类的指针。 <code>INetworkDefinition</code>类 <code>INetworkDefinition</code>类即为网络定义，可通过<code>IBuilder</code>类方法<code>creatNetwork()</code>返回其指针。 <code>ICudaEngine</code> <code>ICudaEngine</code>类即为Engine，可通过<code>IBuilder</code>类方法<code>buildCudaEngine()</code>/<code>buildEngineWithConfig()</code>返回其指针。 Engine的运行需要一个运行时的环境，通过<code>createExecutionContext()</code>方法为对应的<code>ICudaEngine</code>生成一个 <code>IExecutionContext</code>类型的运行环境context。</p><p><img src="/2020/03/09/apollo-detector/tensorrtinfer.png"></p><p><img src="/2020/03/09/apollo-detector/apollo_tensorrt.png"></p><p><img src="/2020/03/09/apollo-detector/coordination_04.png"></p><h2 id="transform">Transform</h2><h3 id="成员属性">成员属性</h3><p><img src="/2020/03/09/apollo-detector/trans.png"></p><p>类成员比较简单，但是内部定义的ObjMapper 类的主要内部成员包括了内参矩阵，图像的宽和高， <strong>ry_score_是啥待定</strong> ry是rotation_y的含义 ，以及目标映射参数,每个方向上的方差即位置的不确定度。</p><p><img src="/2020/03/09/apollo-detector/trans2.png"></p><p>​ <img src="/2020/03/09/apollo-detector/trans3.png" style="zoom:80%;"> <img src="/2020/03/09/apollo-detector/home/jachin/space/myblog/blog/source/_posts/apollo-detector/trans4.png" style="zoom:90%;"></p><p>还有objMapper的配置参数：</p><p><img src="/2020/03/09/apollo-detector/trans6.png"></p><p>ObjectTemplateManager 类中管理了物体类别与尺寸的关联：</p><p><img src="/2020/03/09/apollo-detector/trans88.png"></p><p>其初始化中主要执行下列文件：</p><p><img src="/2020/03/09/apollo-detector/trans66.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TemplateMap min_template_hwl_;</span><br><span class="line">TemplateMap mid_template_hwl_;</span><br><span class="line">TemplateMap max_template_hwl_;</span><br></pre></td></tr></table></figure><p>其内部成员变量表示物体类别与对应三个大中小尺寸的对应关系：<code>object_template.pt</code>中定义</p><p><img src="/2020/03/09/apollo-detector/trans99.png"></p><h3 id="transform-过程">Transform 过程</h3><p>具体执行过程，通过循环获取检测到的每一个目标，进行三步处理：</p><p><img src="/2020/03/09/apollo-detector/trans7.png"></p><ul><li><p>首先，通过参数输入检测到的目标，相机内参，图像高宽，以及theta_ray(应该是相机到目标的中心射线的角度)。然后为3d bbox的计算准备相关参数，将参数赋值给obj_mapper_options。</p><p>其中进行了函数<code>MatchTemplates(</code>base::ObjectSubType sub_type, float *dimension_hwl<code>)</code></p><p>分别获取了当前检测到物体类别所对应的模板，包含了大中小三个尺寸。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;base::ObjectSubType, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; &gt; TemplateMap;</span><br></pre></td></tr></table></figure><p>&lt;img src=&quot;apollo-detector8.png&quot; &quot; /&gt;</p><p><img src="/2020/03/09/apollo-detector/trans234.png"></p></li><li><p>有了上述信息之后，就可以开始3d BBox的处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 3d bbox处理</span></span><br><span class="line"><span class="comment">// @param [in]: obj_mapper_options</span></span><br><span class="line"><span class="comment">// @param [in/out]: obj_center,dimension_hwl,rotation_y 　其中obj_center未知</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObjMapper::Solve3dBbox</span><span class="params">(<span class="keyword">const</span> ObjMapperOptions &amp;options, <span class="keyword">float</span> center[<span class="number">3</span>],<span class="keyword">float</span> hwl[<span class="number">3</span>], <span class="keyword">float</span> *ry)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// call 3d solver</span></span><br><span class="line">  <span class="keyword">bool</span> success =Solve3dBboxGivenOneFullBboxDimensionOrientation(bbox, hwl, ry, center);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检查输入尺寸的合理性。</p><p>计算3dbox函数如下,主要就是求解3d bbox的位置即center</p><p><img src="/2020/03/09/apollo-detector/trans_over.png"></p><p><img src="/2020/03/09/apollo-detector/trans999.png"></p></li></ul><hr><p>分割一下，上面的有时间再补充</p><p><img src="/2020/03/09/apollo-detector/trans444.png"></p><p>如果2d bbox 么有被截断（在图像范围内）：</p><hr><h3 id="总体流程图">总体流程图：</h3><p><img src="/2020/03/09/apollo-detector/Transform.png"></p><h2 id="参考文献">参考文献</h2><blockquote><p>1.single view metrology[http://ieeexplore-ieee-org-s.ivpn.hit.edu.cn:1080/document/791253] 2.http://www.cvlibs.net/datasets/kitti/setup.php 3.https://cloud.tencent.com/developer/article/1418687</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perception </tag>
            
            <tag> detector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo 中的跟踪算法</title>
      <link href="/2020/03/09/apollo-track/"/>
      <url>/2020/03/09/apollo-track/</url>
      
        <content type="html"><![CDATA[<p>Apollo中的检测算法</p><a id="more"></a><p>跟踪的基本成员单位为封装object类为TrackObject类，最后<code>Target</code>类结构中包含<code>TrackObject</code>类及相关的估计方法。</p><h2 id="tracker_-predictframe预测部分">tracker_-&gt;Predict(frame):预测部分</h2><p>在新图像中预测候选障碍物 将输出赋值给frame-&gt;proposed_objects</p><h2 id="extractor_-extractframe特征提取部分">extractor_-&gt;Extract(frame):特征提取部分</h2><p>对每个检测到的对象进行特征提取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FeatureExtractorLayer</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;inference::Layer&lt;<span class="keyword">float</span>&gt;&gt; pooling_layer;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::Blob&lt;<span class="keyword">float</span>&gt;&gt; rois_blob;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::Blob&lt;<span class="keyword">float</span>&gt;&gt; top_blob;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feature_extractor_layer_ptr-&gt;pooling_layer-&gt;ForwardGPU(</span><br><span class="line">     &#123;feat_blob_, feature_extractor_layer_ptr-&gt;rois_blob&#125;,</span><br><span class="line">     &#123;frame-&gt;track_feature_blob&#125;);</span><br></pre></td></tr></table></figure><p>其中<code>feat_blob_</code>的现行定义是:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">feat_stride: <span class="number">32</span></span><br><span class="line">extractor &#123;</span><br><span class="line">  feat_blob: <span class="string">"conv4_3"</span></span><br><span class="line">  feat_type: ROIPooling</span><br><span class="line">  roi_pooling_param &#123;</span><br><span class="line">      pooled_h: <span class="number">3</span></span><br><span class="line">      pooled_w: <span class="number">3</span></span><br><span class="line">      use_floor: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样根据feat_blob_以及rois_blob(由bbox位置确定)进行<code>ROIPooling</code>将最终pool得到的最大值存到track_feature_blob中。</p><h2 id="tracker_-associate2dframe根据2d信息关联">tracker_-&gt;Associate2D(frame):根据2D信息关联</h2><h3 id="该部分的主要成员变量">该部分的主要成员变量</h3><ol type="1"><li><p>成员类帧列表:<code>FrameList</code> 包装了<code>CameraFrame</code>类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> frame_count_ = <span class="number">0</span>; <span class="comment">//添加帧的数量</span></span><br><span class="line"><span class="keyword">int</span> capability_ = <span class="number">0</span>;<span class="comment">//容量(14)表示14帧后开始覆盖</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CameraFrame *&gt; frames_;</span><br></pre></td></tr></table></figure></li><li><p>相似性map:<code>SimilarMap</code> 存储blob的嵌套vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::Blob&lt;<span class="keyword">float</span>&gt;&gt;&gt;&gt; map_sim;</span><br><span class="line"><span class="keyword">int</span> dim;<span class="comment">//=omt_param_.img_capability()=14</span></span><br></pre></td></tr></table></figure></li><li><p>相似性计算<code>BaseSimilar</code> <code>std::shared_ptr&lt;BaseSimilar&gt; similar_</code></p></li></ol><p><img src="/2020/03/09/apollo-track/2.png"></p><p>​ 其中GPUSimilar用到了BLAS(线性代数)库:https://blog.csdn.net/cocoonyang/article/details/58602654?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</p><ol start="4" type="1"><li><p><code>Target</code>类包含了跟踪物体的id和相关的状态信息,<code>tracked_objects</code>包含了被跟踪的物体vector,是<code>TrackObject</code>类 <code>Target</code>类为期望得到检测框匹配的跟踪物体</p><p><img src="/2020/03/09/apollo-track/4.png"></p></li><li><p><code>TrackObject</code>类则封装了跟踪目标<code>Object</code>类，记录该跟踪目标对应的帧id和传感器名称,是跟踪目标的最小封装单位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrackObject</span> &#123;</span></span><br><span class="line">  PatchIndicator indicator; <span class="comment">//保存了传感器的名称和目标在帧中的id</span></span><br><span class="line">  <span class="keyword">double</span> timestamp;</span><br><span class="line">  base::BBox2DF projected_box;<span class="comment">//由检测得到的原2dbox　经projected_matrix投影得到障碍物的bbox 这个矩阵是啥意思不太清楚 narrow to obstacle projected_matrix(应该是为了将不同的相机的bbox统一到一个尺度)</span></span><br><span class="line">  base::ObjectPtr object;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>PatchIndicator</code>类主要包含了两个变量,重载运算符&quot;==&quot;为frame_id和patch_id分别相等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> frame_id;<span class="comment">//为该检测目标对应的是第几帧(frame id )</span></span><br><span class="line"><span class="keyword">int</span> patch_id;<span class="comment">//该检测目标在该帧中的id(object id)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sensor_name;<span class="comment">//记录检测到的传感器名称</span></span><br></pre></td></tr></table></figure></li><li><p><code>ObstacleReference</code>类包含了与模板相关的参数：</p><p><img src="/2020/03/09/apollo-track/5.png"></p></li><li><p><code>reference</code>类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Reference</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> area = <span class="number">0.0f</span>;</span><br><span class="line">  <span class="keyword">float</span> k = <span class="number">0.0f</span>;</span><br><span class="line">  <span class="keyword">float</span> ymax = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>CameraGroundPlaneDetector</code>类，地平面检测的相关方法</p><p><img src="/2020/03/09/apollo-track/6.png"></p></li></ol><h3 id="d关联算法的实现">2D关联算法的实现</h3><ol type="1"><li>计算各帧与当前帧的余弦相似性:（第5步target和det_obj的Apperance的匹配分数会用到）</li><li>从已跟踪物体列表中去除最早帧之前的帧中检测到的目标</li><li>根据当前帧的检测物体，得到当前的检测跟踪列表</li></ol><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">ProjectBox(frame-&gt;detected_objects[i]-&gt;camera_supplement.box,</span><br><span class="line">             frame-&gt;project_matrix, &amp;(track_ptr-&gt;projected_box));<span class="comment">//图像2dbox投影到障碍物坐标系</span></span><br><span class="line">track_objects.push_back(track_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4" type="1"><li>校正当前帧检测目标的三维尺寸，执行了四种校正方式：分别为模板，参考地平面，标定，历史信息</li></ol><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reference_.CorrectSize(frame); <span class="comment">//</span></span><br></pre></td></tr></table></figure></p><ul><li><p>根据模板的最小最大尺寸校正检测目标的最小最大尺寸。(TypeRefinedBy<strong>Template</strong>)</p></li><li><p>根据障碍物参考校正检测目标的尺寸,可作为参考的目标类型类<code>CAR,VAN</code>,同时还需要一系列附加条件，可详见<code>ObstacleReference::UpdateReference(...)</code></p><p>(1). 根据sensor_name的不同 初始化ground_estiomator,执行<code>GameraGroundPlaneDetector</code>类的初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SyncGroundEstimator(sensor, frame-&gt;camera_k_matrix,</span><br><span class="line">                          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(img_width_),</span><br><span class="line">                          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(img_height_));</span><br></pre></td></tr></table></figure><p>该函数实际上执行<code>GameraGroundPlaneDetector</code>类的初始化,有相机内参相关参数初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ground_estimator.Init(k_mat, img_width, img_height, common::IRec(fx));</span><br></pre></td></tr></table></figure><p>(2).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ground_estimator.GetGroundModel(l)</span><br></pre></td></tr></table></figure><p>通过相机pitch和相机height(通过calibration获取)获取平面<span class="math display">\[a*X+b*Y+c*Z+d=0\]</span> （相机坐标系）</p></li><li><p>通过标定服务校正高度h</p></li><li><p>通过历史参考校正高度h</p></li></ul><figure><img src="/2020/03/09/apollo-track/21.png" alt="template"><figcaption>template</figcaption></figure><blockquote><p>此处矫正的三维尺寸在后面的<code>Transform</code>部分是否也被采用</p></blockquote><ol start="5" type="1"><li><p>生成假设</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 评估新检测目标与targets的相似性</span></span><br><span class="line"><span class="comment">// @param [in]: track_objects :该帧检测器新检测到的目标</span></span><br><span class="line"><span class="comment">// @param [in/out]: </span></span><br><span class="line"><span class="comment">// output:target匹配第(frame_id)帧中的第几个检测物(track_object),</span></span><br><span class="line"><span class="comment">//        并将该track_object加入到target的tracked_objects中</span></span><br><span class="line">GenerateHypothesis(track_objects);</span><br></pre></td></tr></table></figure><p>其中对应的主要成员变量类型<code>Hypothesis</code>的定义为:（此为target和object的）</p><p><img src="/2020/03/09/apollo-track/666.png"></p><p>处理函数：</p><p><img src="/2020/03/09/apollo-track/13.png"></p><p>得到target与对应det_obj的匹配分数后，根据分数由大到小分配,最终将检测物体(det_obj)加入到匹配分数最高的target的tracked_objects中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target.Add(det_obj); </span><br><span class="line"><span class="comment">//将det_obj添加到给定的target的tracked_objects中,并将该target的lost_age清零</span></span><br></pre></td></tr></table></figure><p>除了上面的四个分数，最终score还需要加上不同物体类型切换的代价值。</p><figure><img src="/2020/03/09/apollo-track/10.png" alt="type_change_cost"><figcaption>type_change_cost</figcaption></figure></li><li><p>创建新跟踪目标(target)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> new_count = CreateNewTarget(track_objects);</span><br></pre></td></tr></table></figure><p>由<code>track_objects</code>创建新的跟踪目标的条件有：</p><ol type="1"><li>首先该det_obj与现有的target的匹配分数很小，即该det_obj与现有target匹配失败<ol start="2" type="1"><li>该det_obj的box需要是有效的(bbox宽高大于20同时小于图像宽高)</li><li>该det_obj的box矩形没有被某个target的bbox覆盖 ,此处target的bbox指tracked_objects中最近检测的bbox</li><li>在上述条件都满足的前提下，需满足det_obj的高度大于最小模板的高度,也可以是未知类型(此时高度的模板未知)</li></ol></li></ol></li><li><p>超过存活周期(lost_age&gt;5)的target,否则执行(即正常跟踪的target)下列方法，通过<code>latest_object</code>进行相应更新.并调用对应的<code>滤波方法</code>进行预测</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target.UpdateType(frame);</span><br><span class="line">target.Update2D(frame);</span><br></pre></td></tr></table></figure><ul><li><p><strong>UpdateType():</strong></p><p>对于未丢失检测(lost_age=0)的target:</p><ol type="1"><li>计算该target的最近检测目标(latest_object-&gt;object)的高度与模板中等尺寸的高度接近程度,接近程度由高斯分布衡量:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//~N(mu=1.0,sigma=0.3)  反映了object的box_height与模板中等高度的接近程度</span></span><br><span class="line"><span class="keyword">float</span> alpha = gaussian(</span><br><span class="line">        <span class="built_in">rect</span>.<span class="built_in">height</span> /</span><br><span class="line">            (<span class="number">50</span> * (kMidTemplateHWL.at(object-&gt;sub_type).at(<span class="number">0</span>) + <span class="number">0.01f</span>)),</span><br><span class="line">        <span class="number">1.0f</span>, target_param_.type_filter_var());</span><br><span class="line"><span class="comment">//该target同类型的probs会往上叠加(在不同帧之间)，因为每帧该target都有一个对应的latest_object</span></span><br><span class="line">type_probs[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(object-&gt;sub_type)] += alpha;</span><br></pre></td></tr></table></figure><p>根据上述最大的<code>type_probs</code>更新target的对应目标类型</p><ol start="2" type="1"><li>将上述(alpha, object-&gt;size(0), object-&gt;size(1),object-&gt;size(2))组成4维向量，将此测量量添加到该target的<code>MaxNMeanFilter world_lwh</code>及<code>MeanFilter world_lwh_for_unmovable</code>中：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">world_lwh.AddMeasure(size_measurement); <span class="comment">//MaxNMeanFilter window=15 根据alpha由大到小</span></span><br><span class="line">world_lwh_for_unmovable.AddMeasure(size_measurement); <span class="comment">//测量值的均值和方差</span></span><br></pre></td></tr></table></figure><figure><img src="/2020/03/09/apollo-track/19.png" alt="MaxNMeanFilter"><figcaption>MaxNMeanFilter</figcaption></figure><p>这一步将得到该target 的15次测量值，按照alpha由大到小排序，并取平均更新3d object size,其中的object为该target的lastest_obj</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object-&gt;type == base::ObjectType::UNKNOWN_UNMOVABLE) &#123;</span><br><span class="line">  object-&gt;<span class="built_in">size</span> =</span><br><span class="line">      world_lwh_for_unmovable.get_state().block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">1</span>, <span class="number">0</span>).cast&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  object-&gt;<span class="built_in">size</span> = world_lwh.get_state().block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">1</span>, <span class="number">0</span>).cast&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>camera:</p><p>6mm : reliable z is 40(m) ,intrinsic(f) is approximate is 2000(像素)</p><p>12mm:reliable z is 80(m),instrinsic(f) is approximate si 4000(像素)</p></blockquote></li><li><p><strong>Update2D():</strong> 更新2d box的大小。</p><ol type="1"><li><p>向滤波器中添加测量值,进行滤波计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">measurement &lt;&lt; <span class="built_in">rect</span>.<span class="built_in">width</span>, <span class="built_in">rect</span>.<span class="built_in">height</span>;</span><br><span class="line">image_wh.AddMeasure(measurement);<span class="comment">//一阶低通filter</span></span><br><span class="line">measurement &lt;&lt; center.x, center.y;</span><br><span class="line">image_center.Correct(measurement);<span class="comment">//Kalman_Filter</span></span><br></pre></td></tr></table></figure></li><li><p>更新:得到该target最近最近检测物体(latest_object)的projected_box(单位：米)</p><figure><img src="/2020/03/09/apollo-track/20.png" alt="2d box update"><figcaption>2d box update</figcaption></figure></li></ol></li></ul><ol start="8" type="1"><li><p>在Association之后通过IOU合并重复的targets(可能是不同相机得到的)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CombineDuplicateTargets();</span><br></pre></td></tr></table></figure><ul><li><p>对目前的targets_两两之间计算其各自含有的tarcked_objects之间的IOU以及box宽和高的差异，计算得到score (此处计算的tracked_object要求他们的时间戳之差小于0.05，同时来自不同传感器)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">score += common::CalculateIOUBBox(box1, box2); </span><br><span class="line">...</span><br><span class="line">score -= <span class="built_in">std</span>::<span class="built_in">abs</span>((rect1.<span class="built_in">width</span> - rect2.<span class="built_in">width</span>) *</span><br><span class="line">                              (rect1.<span class="built_in">height</span> - rect2.<span class="built_in">height</span>) /</span><br><span class="line">                              (rect1.<span class="built_in">width</span> * rect1.<span class="built_in">height</span>));</span><br></pre></td></tr></table></figure><p>将最终平均得分作为这两个<code>target</code>之间的相似程度，并将结果保存到score_list中(包括了两个target的索引及其得分)</p></li><li><p>按照得分从大到小排序依次匹配，可以看出这一步骤与<code>OMTObstacleTracker::GenerateHypothesis()</code>相似不同的是我们这里要删除匹配成功的两个target中<code>id</code>大的那个,并将删除的那个target_del中的tracked_obj转移到target_save中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (targets_[pair.target].id &gt; targets_[pair.object].id) &#123;</span><br><span class="line">  index1 = pair.object;</span><br><span class="line">  index2 = pair.target;</span><br><span class="line">&#125;</span><br><span class="line">Target &amp;target_save = targets_[index1];</span><br><span class="line">Target &amp;target_del = targets_[index2];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target_del.Size(); i++) &#123;</span><br><span class="line">  <span class="comment">// no need to change track_id of all objects in target_del</span></span><br><span class="line">  target_save.Add(target_del[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并将target_save(target的引用)中的tracked_objects按照帧id(frame id)由小到大排序，并更新lastest_object。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(</span><br><span class="line">    target_save.tracked_objects.<span class="built_in">begin</span>(), target_save.tracked_objects.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="keyword">const</span> TrackObjectPtr object1, <span class="keyword">const</span> TrackObjectPtr object2) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> object1-&gt;indicator.frame_id &lt; object2-&gt;indicator.frame_id;</span><br><span class="line">    &#125;);<span class="comment">//将targe_save中的tracked_objects按照帧的id由小到大排序</span></span><br><span class="line">target_save.latest_object = target_save.get_object(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>然后将target_del中的tracked_objects给清零，最后调用<code>ClearTargets()</code>即可将<code>targets_</code>多余的target清除掉(将target从后往前填空)</p></li></ul></li><li><p>对经过滤波处理的box(单位：米)映射回图像坐标系（像素）</p><p>​</p></li></ol></li></ol><h2 id="tracker_-associate3dframe根据3d信息关联">tracker_-&gt;Associate3D(frame):根据3D信息关联</h2><h3 id="更新reference">1. 更新reference</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reference_.UpdateReference(frame,targets_);</span><br></pre></td></tr></table></figure><p>其中包含的数据结构有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Reference</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> area = <span class="number">0.0f</span>; <span class="comment">//box的面积</span></span><br><span class="line">  <span class="keyword">float</span> k = <span class="number">0.0f</span>;    <span class="comment">//object.H/box.h</span></span><br><span class="line">  <span class="keyword">float</span> ymax = <span class="number">0.0f</span>; <span class="comment">//box的bottom right</span></span><br><span class="line">&#125;;<span class="comment">//可参考的Target（CAR,VAN）所对应的属性</span></span><br></pre></td></tr></table></figure><p><code>Obstacle_reference</code>类中的主要参数:主要含义是<code>ref_map_</code>中存储了<code>reference_</code>对应元素的索引，即ref_map_中各个位置存储了索引，索引对应于<code>reference _</code>中的的对应Reference属性。</p><p><img src="/2020/03/09/apollo-track/22.png"></p><p>参数的相关默认值：</p><p><img src="/2020/03/09/apollo-track/27.png"></p><p><strong><code>ObstacleReference::Init</code>的初始化中执行的操作：</strong> 将图像下采样(ref_width_=width/25,ref_height_=height/25),将init_ref_map的大小设置为(ref_height_,ref_width_)的大小.然后对<code>init_ref_map</code>进行初始化,<code>init_ref_map</code>是一个嵌套vector结构,只对ref图像的下半部分处理，去除边缘，然后将这一部分区域的<code>init_ref_map</code>置为0，如蓝色区域所示。</p><p><img src="/2020/03/09/apollo-track/24.png"></p><p><img src="/2020/03/09/apollo-track/26.png"></p><p><strong><code>Reference update</code>中更新Reference中的相关参数</strong></p><ul><li><p><code>reference_</code>中的所有reference的area每次更新衰减0.98</p></li><li><p>​ 对于每个target中最近检测到的物体，如果是可以参考的类型(CAR,VAN)，同时其box的高度大于50，box的底边位置大于内参矩阵中的c_y(即box尽可能位于图像底部),此时该target可以被参考。将该box的底边中心点也进行下采样(y_discrete=y/25,x_discrete=x/25),这样可以与<code>ref_map</code>的尺寸对应。 ​ 如果此中心点所对应的<code>ref_map</code>为0(即该点对应的参考图第一次被使用)，将其对应的Reference信息push到数组<code>reference_</code>中存储，并将<code>ref_map</code>中对应位置置为当前<code>refs</code>存储的元素数(即将refs中对应的索引存储到ref_map的对应位置中);否则，若该点对应的ref_map大于零(表示该点已经存在某个物体，其中存储的值为当时的<code>refs</code>中对应的索引)，同时此时box的area大于之前存在的reference的area，则将属性进行替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.area = box.Area();</span><br><span class="line">r.ymax = y;</span><br><span class="line">r.k = obj-&gt;<span class="built_in">size</span>[<span class="number">2</span>] / (y - box.ymin); <span class="comment">// H/h</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>通过reference检测Ground</strong></p><p>​ 首先对于目前<code>refs</code>存储的所有<code>reference</code>，将其对应的box底边位置（y_max）以及深度倒数<code>1/z_ref</code>存储到<code>vd_samples</code>中,当reference的数量大于<code>min_nr_samples=6</code>时，可进行Ground的检测(需要在线标定的相机Pitch角度和相机离地平面的高度)</p><p><img src="/2020/03/09/apollo-track/28.png"></p><p><strong>DetetGround:</strong></p><p>若给定了相机坐标系下的平面，则由<span class="math inline">\(Ax+By+Cz+D=0 -&gt; a*y+b*disp+c=0\)</span> : ground4-&gt;ground3:</p><p><img src="/2020/03/09/apollo-track/29.png"></p><p><img src="/2020/03/09/apollo-track/IMG_0304.jpg" style="zoom:30%;"></p><p>否则根据之前的存储的<code>reference</code>进行地平面的检测,<code>CameraGroundPlaneDetector::DetectGroundFromSamples()</code></p><p>ground3与ground4的对应关系如上图所示，通过采样{y_max,1/z}即边界框下边界和深度的倒数即可通过一致性采样得到模型参数。</p><ul><li><p><strong>RobustBinaryFitRansac()</strong></p><p>两个功能函数：</p><ul><li>```c++ template <typename t> //a<em>y+b</em>disp + c = 0-&gt;disp = p0<em>y+p1 通过采样点建立模型 void GroundHypoGenFunc(const T </em>v, const T <em>d, T </em>p) { // disp = p0 * y + p1 -&gt; l = {p0, -1, p1} T x[2] = {v[0], d[0]}; T xp[2] = {v[1], d[1]}; T l[3] = {0}; common::ILineFit2d(x, xp, l); p[0] = -l[0] * common::IRec(l[1]); p[1] = -l[2] * common::IRec(l[1]); } <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;c++</span><br><span class="line">  template &lt;typename T&gt; &#x2F;&#x2F;平面拟合 代价函数</span><br><span class="line">  void GroundFittingCostFunc(const T *p, const T *v, const T *d, int n,</span><br><span class="line">                             int *nr_inlier,  &#x2F;&#x2F; NOLINT compatible for i-lib</span><br><span class="line">                             int *inliers,</span><br><span class="line">                             T *cost,  &#x2F;&#x2F; NOLINT</span><br><span class="line">                             T error_tol) &#123;</span><br><span class="line">    *cost &#x3D; static_cast&lt;T&gt;(0.0f);</span><br><span class="line">    *nr_inlier &#x3D; 0;</span><br><span class="line">    const T *refx &#x3D; v;</span><br><span class="line">    const T *refp &#x3D; d;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">      T d_proj &#x3D; refx[0] * p[0] + p[1];</span><br><span class="line">      T proj_err &#x3D; static_cast&lt;T&gt;(fabs(d_proj - refp[0]));</span><br><span class="line">      if (proj_err &lt; error_tol) &#123;</span><br><span class="line">        inliers[(*nr_inlier)++] &#x3D; i;</span><br><span class="line">        *cost +&#x3D; proj_err;</span><br><span class="line">      &#125;</span><br><span class="line">      ++refx;</span><br><span class="line">      ++refp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></typename></li></ul><p>以此为模板参数执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">common::RobustBinaryFitRansac&lt;<span class="keyword">float</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                              GroundHypoGenFunc&lt;<span class="keyword">float</span>&gt;,</span><br><span class="line">                              GroundFittingCostFunc&lt;<span class="keyword">float</span>&gt;, <span class="literal">nullptr</span>&gt;(</span><br><span class="line">          vs, ds, count_vd, p, &amp;nr_inliers, inliers, kThresInlier, <span class="literal">false</span>, <span class="literal">true</span>,</span><br><span class="line">          <span class="number">0.99f</span>, kMinInlierRatio)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部主要处理过程</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RobustBinaryFitRansac</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">int</span> nr_trials = IRansacTrials(s, confidence, inlierprob);<span class="comment">//获取Ransac尝试次数 (此处是16)</span></span><br><span class="line">    <span class="keyword">while</span> (nr_trials &gt; sample_count) &#123;</span><br><span class="line">        IRandomSample(indices, s, n, &amp;rseed); <span class="comment">//随机采样 从[0,n)中每次采2个索引</span></span><br><span class="line">        ...</span><br><span class="line">        HypogenFunc(samples_x, samples_xp, tmp_model); <span class="comment">//通过两个采样点获取模型参数</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//通过其他样本数据，验证获取的模型参数，计算代价 error_tol=KThresInlier判断内点的阈值</span></span><br><span class="line">        CostFunc(tmp_model, x, xp, n, &amp;nr_inliers, inliers + n, &amp;cost, error_tol);</span><br><span class="line">    <span class="keyword">if</span> ((nr_inliers &gt; *consensus_size) ||</span><br><span class="line">        (nr_inliers == *consensus_size &amp;&amp; cost &lt; best_cost)) &#123;</span><br><span class="line">      *consensus_size = nr_inliers; <span class="comment">//目前匹配的最多的内点数</span></span><br><span class="line">      best_cost = cost;</span><br><span class="line">      ICopy(tmp_model, model, k); <span class="comment">//将匹配内点数最多的模型导出</span></span><br><span class="line">        <span class="comment">// record inlier indices 将匹配最多的模型的内点索引记录</span></span><br><span class="line">      ICopy(inliers + n, inliers, *consensus_size);  </span><br><span class="line">      <span class="keyword">if</span> (adaptive_trial_count) &#123; <span class="comment">//自适应尝试</span></span><br><span class="line">        tmp_inlierprob = IDiv(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(*consensus_size), n);</span><br><span class="line">        <span class="keyword">if</span> (tmp_inlierprob &gt; actual_inlierprob) &#123;</span><br><span class="line">          actual_inlierprob = tmp_inlierprob;</span><br><span class="line">                <span class="comment">//调整(任意一个点为内点)的概率，以此调整trial次数</span></span><br><span class="line">          nr_trials = IRansacTrials(s, confidence, actual_inlierprob);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ILineFit2dTotalLeastSquare</strong>:最小二乘拟合 最后根据这些内点进行最小二乘拟合,得到平面<span class="math inline">\(a*y+b*disp + c = 0\ -&gt; p0*y - disp +p1=0\)</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common::ILineFit2dTotalLeastSquare(vd, l_best, count);</span><br></pre></td></tr></table></figure></li><li><p><strong>GetGroundPlanePitchHeight()</strong>:将ground3平面转换为相机坐标系下的ground4,并得到相机高度(height)和角度(pitch): <img src="/2020/03/09/apollo-track/31.png"></p></li><li><p><strong>GroundPlaneTracker()</strong> 构造函数： 注意到tracker的存储是从后往前添加(低索引存储新值)</p><p><img src="/2020/03/09/apollo-track/32.png"></p></li></ul><hr><blockquote><p>在机器人领域中，平面检测有多种方法，例如：</p><p>Plane segment finder:algorithm, implementation and applications[C].中采用了霍夫变换方法； Learning compact 3D models of indoor and outdoor environments with a mobile robot中通过随机选择3D点，并在其周围区域增长的方式查找最大点集拟合平面参数； Automatic 3D building reconstruction using plane-roof structures中通过随机一致性采样方法找到局部多边形并合并。</p></blockquote><p><strong>基于RANSAC随机一致性采样的鲁棒方法</strong></p><p>通过ransac算法不断的对平面方程参数进行估算，先介绍一下RANSAC算法:</p><p>RANSAC通过反复选取数据中的一组随机子集来达成目标，被选取的子集被假设为局内点，并通过下属方法进行验证： (1) 有一个模型适用于假设的局内点，及所有未知参数都能从假设的局内点中计算得出（<strong>拟合模型</strong>） (2) 用（1）中得到的模型去测试其他的数据，如果某个点适用于估计的模型(距离小于阈值)，认为它也是局内点。 (3) 如果有足够多的点被归类为假设的局内点，则估计的模型就足够合理。 (4) 然后，用所有假设的局内点重新估计模型，因为它仅仅被初始的假设局内点估计过。 (5) 最后根据估计局内点与模型的错误率来评估模型。</p><p>这个过程重复执行固定次数，每次产生的模型要么因为局内点太少而被舍弃，要么因为它比现有的模型更好而被采用。</p><p>相比于最小二乘采用了所有点，RANSAC仅采用局内点进行模型的计算，局外点并不影响模型效果。</p><p>对于平面的拟合基本步骤如下: (1) 随机取样：随机抽取数据作为样本 (2) 拟合模型：根据样本获取模型参数M (3) 判断距离: 判断所有数据点到模型的距离，将距离小于阈值的加入局内点，记录此时模型的局内点数 (4) 判断：局内点数目&gt;阈值，则利用此时的局内点重新估计模型，重复3-5次，将得到的局内点数最多的模型即为当前 的最佳模型；局内点数目&lt;阈值, 则跳出 (5) 跳到步骤(1)，循环N次</p><hr><h3 id="移除异常的移动">2. 移除异常的移动</h3><p>首先根据其位置信息，移除异常移动的target，并将这些target的最新检测目标创建新的target,同时更新这些新创建的target的2D和类型信息(通过相应的滤波器更新当前状态)</p><p><img src="/2020/03/09/apollo-track/30.png"></p><p>然后对target进行三维信息更新(target.Update3D),更新的状态有:</p><blockquote><p>FirstOrderRCLowPassFilter direction</p><p>MeanFilter world_center_for_unmovable;</p><p>KalmanFilterConstVelocity world_center;</p><p>KalmanFilterConstState&lt;2&gt; world_center_const; // constant position kalman state</p><p>MeanFilter world_velocity;</p><p>MeanFilter displacement_theta;//位移方向</p></blockquote><p>主要处理得到了<code>速度、位置和朝向</code></p><h2 id="section"></h2>]]></content>
      
      
      <categories>
          
          <category> Apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> track </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo中cipv检测</title>
      <link href="/2020/02/29/apollo-cipv/"/>
      <url>/2020/02/29/apollo-cipv/</url>
      
        <content type="html"><![CDATA[<p>Apollo中CIPV(Closest-In Path Vehicle)为当前车道最接近的车辆，对象由3D边界框表示，其从上到下视图的2D投影将对象定位在地面上，然后检查每个对象是否在当前的车道中。在当前车道的对象中，最接近的一个车辆将被选为CIPV.</p><a id="more"></a><p><code>CIPV</code>通过检测道路上的关键物体以进行纵向控制,利用的信息包括物体检测输出及自身所在车道线<code>(object detection,ego-lane line)</code>。其可用于跟车，从跟踪对象和当前车辆运动中，估计对象的轨迹。该轨迹将指导对象如何在道路上作为一组移动并且可以预测未来的轨迹。有两种跟车尾随，一种是跟随特定车辆的纯尾随，另一种是CIPV引导的尾随，当检测到无车道线时，当前车辆遵循<code>CIPV</code>的轨迹。 <img src="/2020/02/29/apollo-cipv/perception_visualization_apollo_3.0.png"></p><p><strong>apollo中感知输出的可视化，左上角是基于图像的输出，左下角显示了对象的3D边界框。右图显示了车道线和物体的三维俯视图。CIPV标有红色框，黄线表示每辆车的轨迹。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// We use "right handed ZYX" coordinate system for euler angles</span></span><br><span class="line"> <span class="comment">// adjust pitch yaw roll in camera coords</span></span><br><span class="line"> <span class="comment">// Remember that camera coordinate</span></span><br><span class="line"> <span class="comment">// (Z)----&gt; X</span></span><br><span class="line"> <span class="comment">//  |</span></span><br><span class="line"> <span class="comment">//  |</span></span><br><span class="line"> <span class="comment">//  V</span></span><br><span class="line"> <span class="comment">//  Y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"> <span class="comment">//    area ID, corner ID and face ID</span></span><br><span class="line"> <span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"> <span class="comment">//    8 | 1 | 2       a</span></span><br><span class="line"> <span class="comment">//    ---------    0-----1   ^</span></span><br><span class="line"> <span class="comment">//      |   |       |   |    |</span></span><br><span class="line"> <span class="comment">//    7 | 0 | 3    d|   |b</span></span><br><span class="line"> <span class="comment">//      |   |       |   |</span></span><br><span class="line"> <span class="comment">//    ---------    3-----2</span></span><br><span class="line"> <span class="comment">//    6 | 5 | 4       c</span></span><br><span class="line"> <span class="comment">//----------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><h2 id="配置">配置</h2><p>使能<code>CIPV</code>需要在<code>modules/perception/production/conf/perception/camera/fusion_camera_detection_component.pb.txt</code> 中设置<code>enable_cipv:able</code></p><h2 id="初始化">初始化</h2><p>基本数据结构的定义位于<code>modules/perception/camera/app/cipv_camera.h</code></p><p><code>cipv</code>初始化位于<code>FuisonCameraDetectionComponent::Init()</code> 初始化所需参数包括了:</p><ul><li><p>图像与地平面之间的单应性矩阵(<code>homography_im2car_</code>)</p><p>该矩阵由可视化<code>Visualizer</code>功能模块计算获得，计算过程可以参照<code>Visualizer::adjust_angles()</code>,这一部分的初始化<code>visualize_.Init_all_info_single_camera(...)</code>由此处执行。</p></li><li><p><code>cipv</code>所需要的车道线的最少点数(最短长度)<code>(kMinLaneLineLengthForCIPV)</code></p><p>该参数默认为2</p></li><li><p>车道线的平均宽度<code>(kAverageLaneWidthInMeter)</code> 默认为3.7(米)</p></li><li><p>最大车辆宽度<code>(kMaxVehicleWidthInMeter)</code></p><p>默认为1.87米</p></li><li><p>平均帧率<code>(kAverageFrameRate)</code> 默认0.05 s</p></li><li><p><code>image_based_cipv_</code></p><p>布尔值,<code>true</code>:在图像空间中检测目标是否位于车道线内，<code>false:</code>在地平面空间中检测目标是否位于车道线</p></li><li><p><code>debug_level</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0: no debug message</span><br><span class="line">&#x2F;&#x2F; 1: minimal output</span><br><span class="line">&#x2F;&#x2F; 2: some important output</span><br><span class="line">&#x2F;&#x2F; 3: verbose message</span><br><span class="line">&#x2F;&#x2F; 4: visualization</span><br><span class="line">&#x2F;&#x2F; 5: all</span><br><span class="line">&#x2F;&#x2F; -x: specific debugging, where x is the specific number</span><br></pre></td></tr></table></figure></li></ul><h2 id="cipv主体流程">CIPV主体流程</h2><p>运行位于<code>FusionCameraDetectionComponent::InternalProc()</code>中，在主体的相关算法(障碍物跟踪检测、车道线检测)处理完成后运行,同时该部分用到了<code>motion_service</code>的信息(<code>MotionBuffer</code>中存储的车辆状态信息<code>VehicleStatus</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Determine CIPV</span></span><br><span class="line"> <span class="keyword">if</span> (enable_cipv_) &#123;</span><br><span class="line">   CipvOptions cipv_options;</span><br><span class="line">   <span class="keyword">if</span> (motion_buffer_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (motion_buffer_-&gt;<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">       AWARN &lt;&lt; <span class="string">"motion_buffer_ is empty"</span>;</span><br><span class="line">       cipv_options.velocity = <span class="number">5.0f</span>;</span><br><span class="line">       cipv_options.yaw_rate = <span class="number">0.0f</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       cipv_options.velocity = motion_buffer_-&gt;back().velocity;</span><br><span class="line">       cipv_options.yaw_rate = motion_buffer_-&gt;back().yaw_rate;</span><br><span class="line">     &#125;</span><br><span class="line">     ADEBUG &lt;&lt; <span class="string">"[CIPV] velocity "</span> &lt;&lt; cipv_options.velocity</span><br><span class="line">            &lt;&lt; <span class="string">", yaw rate: "</span> &lt;&lt; cipv_options.yaw_rate;</span><br><span class="line">     cipv_.DetermineCipv(camera_frame.lane_objects, cipv_options, world2camera,</span><br><span class="line">                         &amp;camera_frame.tracked_objects);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Get Drop points</span></span><br><span class="line">     <span class="keyword">if</span> (motion_buffer_-&gt;<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       cipv_.CollectDrops(motion_buffer_, world2camera,</span><br><span class="line">                          &amp;camera_frame.tracked_objects);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       AWARN &lt;&lt; <span class="string">"motion_buffer is empty"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>主要有两个处理函数:<code>DetermineCipv</code>,<code>CollectDrops</code> ,下面分别分析其主要实现的功能:</p><h3 id="determinecipv">DetermineCipv</h3><h3 id="collectdrops">CollectDrops</h3>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中fusion_camera_deteciton组件消息类型</title>
      <link href="/2020/02/28/apollo-fusion-camera-detection/"/>
      <url>/2020/02/28/apollo-fusion-camera-detection/</url>
      
        <content type="html"><![CDATA[<p>本文主要涉及Apollo感知部分Apollo的消息接受和发送，不涉及算法程序</p><a id="more"></a><p>整个<code>fusion_camera_detection_component</code>组件的配置文件:</p><p><code>moudles/perception/production/conf/perception/camera/fusion_camera_detection_component.pb.txt</code></p><h2 id="接收reader">接收（reader）</h2><p><strong>MotionService</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;channel_name_local = <span class="string">"/apollo/perception/motion_service"</span>;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> MotionServiceMsgType &amp;)&gt; motion_service_callback =</span><br><span class="line">    <span class="built_in">std</span>::bind(&amp;FusionCameraDetectionComponent::OnMotionService, <span class="keyword">this</span>,</span><br><span class="line">              <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line"><span class="keyword">auto</span> motion_service_reader =</span><br><span class="line">    node_-&gt;CreateReader(channel_name_local, motion_service_callback);</span><br></pre></td></tr></table></figure><p>对应的回调函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On receiving motion service input, convert it to motion_buff_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FusionCameraDetectionComponent::OnMotionService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> MotionServiceMsgType &amp;message)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    motion_buffer_-&gt;push_back(vehicledata);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>消息格式定义：<code>modules/perception/proto/motion_service.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MotionType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m00 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m01 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m02 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m03 = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m10 = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m11 = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m12 = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m13 = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m20 = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m21 = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m22 = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m23 = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m30 = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m31 = <span class="number">14</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m32 = <span class="number">15</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m33 = <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">VehicleStatus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> roll_rate = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> pitch_rate = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> yaw_rate = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> velocity = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> velocity_x = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> velocity_y = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> velocity_z = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> time_ts = <span class="number">8</span>;                          <span class="comment">// time stamp</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> time_d = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">optional</span> MotionType motion = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Motion_Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> VehicleStatus vehicle_status = <span class="number">1</span>;  <span class="comment">// An array of vehicle_information stored for previous timestamps</span></span><br><span class="line">  <span class="keyword">optional</span> common.Header header = <span class="number">2</span>;                    <span class="comment">// Header</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CameraListeners</strong>:创建回调函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//modules/drivers/proto/sensor_image.proto 定义了Image的消息类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image&gt; ImageMsgType;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> ImageMsgType &amp;)&gt; camera_callback =</span><br><span class="line">    <span class="built_in">std</span>::bind(&amp;FusionCameraDetectionComponent::OnReceiveImage, <span class="keyword">this</span>,</span><br><span class="line">              <span class="built_in">std</span>::placeholders::_1, camera_name);<span class="comment">//jac!!20/1/14:回调</span></span><br><span class="line"><span class="keyword">auto</span> camera_reader = node_-&gt;CreateReader(channel_name, camera_callback);</span><br></pre></td></tr></table></figure><p>对应的回调函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FusionCameraDetectionComponent::OnReceiveImage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image&gt; &amp;message,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;camera_name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>图像消息格式定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> frame_id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> measurement_time = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> height = <span class="number">4</span>;  <span class="comment">// image height, that is, number of rows</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> width = <span class="number">5</span>;   <span class="comment">// image width, that is, number of columns</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> encoding = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> step = <span class="number">7</span>;  <span class="comment">// Full row length in bytes</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bytes</span> data = <span class="number">8</span>;   <span class="comment">// actual matrix data, size is (step * rows)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##　发送(writer)</p><h3 id="out_message">out_message</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::perception::PerceptionObstacles&gt; <span class="title">out_message</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) apollo::perception::PerceptionObstacles)</span></span>;</span><br></pre></td></tr></table></figure><p>该message的消息内容定义<code>modules/perception/proto/perception_obstacle.proto</code></p><p><strong>在<code>InternalProc()</code>函数进行的相关赋值：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MakeProtobufMsg(msg_timestamp, seq_num_, camera_frame.tracked_objects,</span><br><span class="line">camera_frame.lane_objects, *error_code,</span><br><span class="line">    out_message) != cyber::SUCC)</span><br></pre></td></tr></table></figure><h3 id="prefused_message">prefused_message</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; <span class="title">prefused_message</span><span class="params">(<span class="keyword">new</span> (<span class="built_in">std</span>::nothrow)</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          SensorFrameMessage)</span></span>;</span><br></pre></td></tr></table></figure><p>该message的消息内容定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorFrameMessage</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SensorFrameMessage() &#123; type_name_ = <span class="string">"SensorFrameMessage"</span>; &#125;</span><br><span class="line">  ~SensorFrameMessage() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetTypeName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> type_name_; &#125;</span><br><span class="line">  <span class="function">SensorFrameMessage* <span class="title">New</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SensorFrameMessage; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  apollo::common::ErrorCode error_code_ = apollo::common::ErrorCode::OK;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> sensor_id_;</span><br><span class="line">  <span class="keyword">double</span> timestamp_ = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> seq_num_ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> type_name_;</span><br><span class="line">  base::HdmapStructConstPtr hdmap_;</span><br><span class="line"></span><br><span class="line">  base::FramePtr frame_;</span><br><span class="line"></span><br><span class="line">  ProcessStage process_stage_ = ProcessStage::UNKNOWN_STAGE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在<code>InternalProc()</code>函数进行的相关赋值：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FusionCameraDetectionComponent::InternalProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image <span class="keyword">const</span>&gt; &amp;in_message,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;camera_name, apollo::common::ErrorCode *error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">  SensorFrameMessage *prefused_message,</span></span></span><br><span class="line"><span class="function"><span class="params">  apollo::perception::PerceptionObstacles *out_message)</span> </span>&#123;</span><br><span class="line">  ...  </span><br><span class="line">  prefused_message-&gt;timestamp_ = msg_timestamp;</span><br><span class="line">  prefused_message-&gt;seq_num_ = seq_num_;</span><br><span class="line">  <span class="comment">//单目相机检测阶段</span></span><br><span class="line">  prefused_message-&gt;process_stage_ = ProcessStage::MONOCULAR_CAMERA_DETECTION; </span><br><span class="line">  prefused_message-&gt;sensor_id_ = camera_name;</span><br><span class="line">  prefused_message-&gt;frame_ = base::FramePool::Instance().Get();</span><br><span class="line">  prefused_message-&gt;frame_-&gt;sensor_info = sensor_info_map_[camera_name];</span><br><span class="line">  prefused_message-&gt;frame_-&gt;timestamp = msg_timestamp</span><br><span class="line">  ...</span><br><span class="line">  prefused_message-&gt;frame_-&gt;sensor2world_pose = camera2world_trans;</span><br><span class="line">  prefused_message-&gt;frame_-&gt;objects = camera_frame.tracked_objects; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终发送"><strong>最终发送</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;PerceptionObstacles&gt;(output_obstacles_channel_name_); </span><br><span class="line">sensorframe_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(prefused_channel_name_);</span><br><span class="line">camera_viz_writer_ = node_-&gt;CreateWriter&lt;CameraPerceptionVizMessage&gt;(</span><br><span class="line">    camera_perception_viz_message_channel_name_);</span><br><span class="line">camera_debug_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;apollo::perception::camera::CameraDebug&gt;(</span><br><span class="line">        camera_debug_channel_name_);</span><br></pre></td></tr></table></figure><p>消息格式的定义基本可以在<code>modules/perception/proto/..</code>下找到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (output_camera_debug_msg_)&#123;</span><br><span class="line">    ...</span><br><span class="line">camera_debug_writer_-&gt;Write(camera_debug_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enable_visualization_) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">bool</span> send_viz_ret = camera_viz_writer_-&gt;Write(viz_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (output_final_obstacles_) &#123;</span><br><span class="line">    writer_-&gt;Write(out_message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> send_sensorframe_ret = sensorframe_writer_-&gt;Write(prefused_message);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中的kalman filter实现</title>
      <link href="/2020/02/28/apollo-kalmanfilter/"/>
      <url>/2020/02/28/apollo-kalmanfilter/</url>
      
        <content type="html"><![CDATA[<p>Apollo中的KalmanFilter实践</p><a id="more"></a><p>此部分更详细的解释可参考：https://zhuanlan.zhihu.com/p/45238681,此处仅为整理</p><h2 id="kalmanfilter基本形式">KalmanFilter基本形式</h2><figure><img src="/2020/02/28/apollo-kalmanfilter/1.jpg" alt="图片出处:优达学成(Udacity)无人驾驶学位课"><figcaption>图片出处:优达学成(Udacity)无人驾驶学位课</figcaption></figure><h3 id="代码实现">代码实现：</h3><p><code>modules/perception/cammera/lib/obstacle/tracker/commom/kalman_filter.cc</code></p><ul><li><p><strong>初始化：不同的运动模型，其状态量不同</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KalmanFilterConstVelocity::Init</span><span class="params">(Eigen::VectorXd x)</span> </span>&#123;</span><br><span class="line">  state_ &lt;&lt; x(<span class="number">0</span>), x(<span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">  inited_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>预测:使用历史信息对未来位置进行推测</strong> <span class="math display">\[x&#39;=Fx+u\\P&#39;=FPF^T+Q\]</span> 其中<code>F</code>为<strong>状态转移矩阵(state transistion matrix)</strong>,<code>u</code>为外部影响(比如加速度);<code>P</code>表示系统的不确定程度<strong>状态协方差矩阵(state covariance matrix)</strong>，初始值很大，随越来越多数据加入到滤波器中，不确定度会变小;<code>Q</code>表示<strong>过程噪声（process covariance matrix）</strong>，既无法用<code>x'=Fx+u</code>表示的噪声，比如车辆突然上坡。</p><p>恒速度模型的状态转移方程可以表示为:</p><p><img src="/2020/02/28/apollo-kalmanfilter/2.jpg"></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KalmanFilterConstVelocity::Predict</span><span class="params">(<span class="keyword">float</span> <span class="keyword">delta_t</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inited_) &#123;</span><br><span class="line">    state_transition_matrix_(<span class="number">0</span>, <span class="number">2</span>) = <span class="keyword">delta_t</span>;</span><br><span class="line">    state_transition_matrix_(<span class="number">1</span>, <span class="number">3</span>) = <span class="keyword">delta_t</span>;</span><br><span class="line">    state_ = state_transition_matrix_ * state_;</span><br><span class="line">    predict_state_ = state_;</span><br><span class="line">    variance_ = state_transition_matrix_ * variance_ *</span><br><span class="line">                    state_transition_matrix_.transpose() +</span><br><span class="line">                process_noise_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>校正，根据观测值对预测值进行校正：</strong> <span class="math display">\[y=z-Hx&#39;\]</span> 上式计算观测值<code>z</code>与预测值<code>x</code>的<code>残差y</code>。 其中<code>H</code>为<strong>测量矩阵</strong>，表示状态量和测量值之间的对应关系；<code>z</code>为实际观测值 <span class="math display">\[S=HP&#39;H^T+R\\K=P&#39;H^TS^{-1}\]</span> 上式计算得到了<strong>卡尔曼增益K(Kalman Gain)</strong> 其中<code>R</code>为<strong>测量噪声矩阵</strong>,表示的是测量值与真值的差异程度 <span class="math display">\[x=x&#39;+Ky\\P=(1-KH)P&#39;\]</span> 上述两个公式完成了卡尔曼滤波器的闭环，第一个公式完成了状态向量<code>x</code>的更新(综合考虑了预测值和观测值及系统噪声)；第二个公式由卡尔曼增益更新系统的不确定程度<code>P</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KalmanFilterConstVelocity::Correct</span><span class="params">(<span class="keyword">const</span> Eigen::VectorXd &amp;z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inited_) &#123;</span><br><span class="line">    Eigen::Vector2d measure;</span><br><span class="line">    measure &lt;&lt; z[<span class="number">0</span>], z[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// measurement covariance: S = H*P*H^T + R</span></span><br><span class="line">    Eigen::Matrix2d cov =</span><br><span class="line">        measure_matrix_ * variance_ * measure_matrix_.transpose() +</span><br><span class="line">        measure_noise_;</span><br><span class="line"></span><br><span class="line">    kalman_gain_ = variance_ * measure_matrix_.transpose() * cov.inverse();</span><br><span class="line">    variance_ = variance_ - kalman_gain_ * measure_matrix_ * variance_;<span class="comment">//不确定度更新</span></span><br><span class="line">    state_ = state_ + kalman_gain_ * (measure - measure_matrix_ * state_);<span class="comment">//状态更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute likelihood</span></span><br><span class="line">    <span class="keyword">auto</span> residual = measure - predict_state_.head(<span class="number">2</span>);<span class="comment">//获取predict_state_的前两个元素</span></span><br><span class="line">    likelihood_ =</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">exp</span>(<span class="number">-0.5</span> * residual.transpose() * cov.inverse() * residual) /</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">2</span> * M_PI * cov.determinant());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Init(z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到该函数最后计算了一个<strong>似然</strong>,<code>likelihood_</code>: 高斯分布 <span class="math display">\[likelihood=\frac{1}{\sqrt{2\pi|S|}}e^{-\frac{1}{2}r^TS^{-1}r}\]</span> 其中<code>r</code>为观测值与预测值之间的差值（残差residual）</p></li></ul><h2 id="扩展卡尔曼滤波extend-kalman-filter">扩展卡尔曼滤波(Extend Kalman Filter)</h2><p>实际车辆的运动并不能完全由恒定速度模型描述，补充非线性系统中使用的扩展卡尔曼滤波， 常见的其他运动模型有：</p><ul><li>一次运动模型（线性运动模型）<ul><li>恒定速度(Constant Velocity,CV)模型</li><li>恒定加速度(Constant Acceleration,CA)模型</li></ul></li><li>二次运动模型<ul><li>恒定转率和速度(Constant Turn Rate and Velocity,CTRV)模型</li><li>恒定转率和加速度模型(Constant Turn Rate and Acceleration,CTRA)模型</li></ul></li></ul><p>以毫米波雷达的感知为例:</p><figure><img src="/2020/02/28/apollo-kalmanfilter/3.jpg" alt="图片出处:优达学城无人驾驶学位课"><figcaption>图片出处:优达学城无人驾驶学位课</figcaption></figure><p>毫米波雷达基于多普勒效应检测，其检测的原始数据基于极坐标系，上图中包含了</p><blockquote><ol type="1"><li><span class="math inline">\(\rho\)</span> :毫米波雷达到障碍物的距离</li><li><span class="math inline">\(\varphi\)</span> :方向角</li><li><span class="math inline">\(\dot{\rho}\)</span> :距离的变化率，径向速度</li></ol></blockquote><p>与卡尔曼滤波器相似的步骤：</p><p><strong>1.初始化状态初值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExtendedKalmanFilter::Init</span><span class="params">(Eigen::VectorXd x)</span> </span>&#123;</span><br><span class="line">  Init();</span><br><span class="line">  state_ &lt;&lt; x(<span class="number">0</span>), x(<span class="number">1</span>), <span class="number">0</span>, x(<span class="number">2</span>);</span><br><span class="line">  inited_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.预测</strong> <span class="math display">\[x&#39;=Fx+u\\P&#39;=FPF^T+Q\]</span> <img src="/2020/02/28/apollo-kalmanfilter/4.jpg" alt="图片来自于知乎专栏https://zhuanlan.zhihu.com/p/63641680"></p><p>由于毫米波雷达测量障碍物径向位置和速度相对准确,不确定度较低，设置状态协方差阵:</p><p><img src="/2020/02/28/apollo-kalmanfilter/home/jachin/space/myblog/blog/source/_posts/apollo-kalmanfilter/5.jpg"></p><p>由于过程噪声Q对整个系统存在影响，但不确定影响程度，设置为单位阵或空值即可</p><p><strong>3.观测</strong> <span class="math display">\[y=z-Hx&#39;\]</span> 计算观测值<span class="math inline">\(z=[\rho,\varphi,\dot{\rho}]\)</span>和预测值<span class="math inline">\(x&#39;=[p_x,p_y,v_x,v_y]^T\)</span>之间的残差，由上面毫米波雷达的数据特性,其观测数据的维度是三维的并基于极坐标系，因此需要进行坐标转换,注意下式直接用转换后的坐标代替<span class="math inline">\(Hx&#39;\)</span>，并没有实际求<span class="math inline">\(H\)</span></p><figure><img src="/2020/02/28/apollo-kalmanfilter/7.jpg" alt="图片来源于知乎专栏"><figcaption>图片来源于知乎专栏</figcaption></figure><p>注意到这个转化过程是<strong>非线性</strong>的，因此习惯上将上述模型表示为: <span class="math display">\[y=z-h(x&#39;)\]</span> 其中<span class="math inline">\(h(x&#39;)\)</span>即为向量:</p><p><img src="/2020/02/28/apollo-kalmanfilter/8.jpg"></p><p>此时再看剩下的两个公式： <span class="math display">\[S=HP&#39;H^T+R\\K=P&#39;H^TS^{-1}\]</span> 在求解卡尔曼增益的过程中需要用到测量矩阵<span class="math inline">\(H\)</span>,所以还是要求解<span class="math inline">\(H\)</span></p><figure><img src="/2020/02/28/apollo-kalmanfilter/9.jpg" alt="图片来源于知乎专栏，侵删"><figcaption>图片来源于知乎专栏，侵删</figcaption></figure><p>上式可以更明显的看出，等式两边的转换是非线性的，即<span class="math inline">\(H\)</span>不再是常数。</p><p><strong>如果将高斯分布输入到一个非线性函数中，得到的结果将不再符合高斯分布，及卡尔曼滤波不再适用</strong>，因此需要将上面的非线性函数进行<strong>近似线性化</strong>，比较容易想到的方法就是一阶泰勒展开。</p><p>非线性函数<span class="math inline">\(y=h(x)\)</span>通过Taylor公式在<span class="math inline">\((x_0,y_0)\)</span>处展开为： <span class="math display">\[h(x)=h(x_0)+\frac{\dot{h}(x_0)}{1!}(x-x_0)+\frac{\ddot{h}(x_0)}{2!}(x-x_0)^2+\dots\]</span> 忽略二阶以上的高阶项，得到近似线性化方程： <span class="math display">\[h(x)\approx h(x_0)+\dot{h}(x_0)(x-x_0)\]</span> 扩展到多维向量： <span class="math display">\[h(x)\approx h(x_0)+\frac{\partial{h(x_0)}}{\partial{x}}(x-x_0)\]</span> 上述偏导可以通过<strong>雅克比(Jacobian)矩阵</strong>表示。</p><p><img src="/2020/02/28/apollo-kalmanfilter/10.jpg"></p><p>求得非线性函数<span class="math inline">\(h(x&#39;)\)</span>对<span class="math inline">\(p_x,p_y,v_x,v_y\)</span>的一阶偏导数，排列成矩阵，最终得到雅克比阵H</p><p><img src="/2020/02/28/apollo-kalmanfilter/11.jpg"></p><p>代入<span class="math inline">\(\rho,\varphi,\dot{\rho}\)</span>的函数，求偏导，即可得最终的结果：</p><p><img src="/2020/02/28/apollo-kalmanfilter/12.jpg"></p><p>最后在进行更新状态，即完成扩展卡尔曼滤波器的过程，整个过程与一般的卡尔曼滤波器相同，只不过多了非线性关系通过一阶泰勒展开局部线性化的过程</p><blockquote><p>本文中公式的图片来自于知乎专栏https://zhuanlan.zhihu.com/p/45238681</p><p>侵删</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中障碍物后处理</title>
      <link href="/2020/02/25/apollo-obstacle-postprocess/"/>
      <url>/2020/02/25/apollo-obstacle-postprocess/</url>
      
        <content type="html"><![CDATA[<p>Apollo中障碍物后处理</p><a id="more"></a><h2 id="对检测到的障碍物进行后处理的条件">对检测到的障碍物进行后处理的条件</h2><ul><li>bbox位于roi区域内(位于这一区域的其更容易投影到地平面),roi区域大概如图所示,红色部分</li><li>障碍物的中心距离相机中心小于阈值(30)</li></ul><p><img src="/2020/02/25/apollo-obstacle-postprocess/3.png" style="zoom:70%;"></p><h2 id="后处理的初始参数配置">后处理的初始参数配置</h2><p><img src="/2020/02/25/apollo-obstacle-postprocess/1.png"></p><p><code>object_center[1] +=dimension_hwl[0] / 2</code>则此时中心点接触地面 (即车辆坐标系中心下移至平面)</p><h2 id="postprocessobjwithground">PostProcessObjWithGround</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">postprocessor_-&gt;PostProcessObjWithGround(</span><br><span class="line">        obj_postprocessor_options, object_center, dimension_hwl, &amp;rotation_y);</span><br><span class="line"><span class="comment">//函数功能定义</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObjPostProcessor::PostProcessObjWithGround</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> ObjPostProcessorOptions &amp;options, <span class="keyword">float</span> center[<span class="number">3</span>], <span class="keyword">float</span> hwl[<span class="number">3</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span> *ry)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(hwl, options.hwl, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">float</span> bbox[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">memcpy</span>(bbox, options.bbox, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">4</span>);</span><br><span class="line">  *ry = options.ry;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// soft constraints</span></span><br><span class="line">  <span class="keyword">bool</span> adjust_soft =</span><br><span class="line">      AdjustCenterWithGround(bbox, hwl, *ry, options.plane, center);</span><br><span class="line">  <span class="keyword">if</span> (center[<span class="number">2</span>] &gt; params_.dist_far) &#123;</span><br><span class="line">    <span class="keyword">return</span> adjust_soft;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hard constraints</span></span><br><span class="line">  <span class="keyword">bool</span> adjust_hard = PostRefineCenterWithGroundBoundary(</span><br><span class="line">      bbox, hwl, *ry, options.plane, options.line_segs, center,</span><br><span class="line">      options.check_lowerbound);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> adjust_soft || adjust_hard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的的处理算法有两种：</p><ul><li><p><strong>AdjustCenterWithGround</strong>:软约束--通过中心点投影位于平面内的约束进行中心点的更新。</p><p>部分主要处理函数如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">iou_ini = GetProjectionScore(ry, bbox, hwl, center); <span class="comment">//获取角点投影box和检测box的交并比初始值</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//开始更新中心坐标</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">stop</span>)&#123;</span><br><span class="line">    common::IProjectThroughIntrinsic(k_mat_, center, x); <span class="comment">//center投影到图像坐标系 x</span></span><br><span class="line">    x[<span class="number">0</span>] *= common::IRec(x[<span class="number">2</span>]);</span><br><span class="line">    x[<span class="number">1</span>] *= common::IRec(x[<span class="number">2</span>]);<span class="comment">//齐次坐标</span></span><br><span class="line">    <span class="keyword">bool</span> in_front = common::IBackprojectPlaneIntersectionCanonical(</span><br><span class="line">        x, k_mat_, plane, center_test);<span class="comment">//再将此中心点根据平面约束投影回3d空间-&gt;center_test</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">float</span> iou_cur = GetProjectionScore(ry, bbox, hwl, center);</span><br><span class="line">    <span class="keyword">float</span> iou_test = GetProjectionScore(ry, bbox, hwl, center_test);</span><br><span class="line">        <span class="keyword">float</span> dist = common::ISqrt(common::ISqr(center[<span class="number">0</span>] - center_test[<span class="number">0</span>]) +</span><br><span class="line">                               common::ISqr(center[<span class="number">2</span>] - center_test[<span class="number">2</span>]));<span class="comment">//检测得到的center与平面内的center_test的距离</span></span><br><span class="line">    <span class="keyword">float</span> cost_cur = dist + WEIGHT_IOU * (<span class="number">1.0f</span> - (iou_cur + iou_test) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "cost___ " &lt;&lt; cost_cur &lt;&lt; "@" &lt;&lt; iter &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">if</span> (cost_cur &gt;= cost_pre) &#123;</span><br><span class="line">      <span class="built_in">stop</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cost_delta = (cost_pre - cost_cur) / cost_pre;</span><br><span class="line">      cost_pre = cost_cur;</span><br><span class="line">      center[<span class="number">0</span>] += (center_test[<span class="number">0</span>] - center[<span class="number">0</span>]) * lr;</span><br><span class="line">      center[<span class="number">2</span>] += (center_test[<span class="number">2</span>] - center[<span class="number">2</span>]) * lr; <span class="comment">//更新center,与之前"Transform模块中的center更新相似",此时的依据是点的反投影位于平面</span></span><br><span class="line">      ++iter;</span><br><span class="line">      <span class="built_in">stop</span> = iter &gt;= MAX_ITERATION || cost_delta &lt; EPS_COST_DELTA ||</span><br><span class="line">             cost_pre &lt; MIN_COST;</span><br><span class="line">    &#125;</span><br><span class="line">    lr *= params_.learning_r_decay; </span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">float</span> iou_res = GetProjectionScore(ry, bbox, hwl, center);</span><br><span class="line">  <span class="keyword">if</span> (iou_res &lt; iou_ini * params_.shrink_ratio_iou) &#123; <span class="comment">//0.9 IOu缩小比率，更新完center后若其iou反而缩减到原iou的0.9以下，则还是用初始值</span></span><br><span class="line">    <span class="built_in">memcpy</span>(center, center_input, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//更新失败</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/25/apollo-obstacle-postprocess/2.png"></p><p>由内参所表示的反投影关系：(x,y)-&gt;(X,Y,Z) <span class="math display">\[X=\frac{x-c_x}{f_x}*Z=umcx*Z\\Y=\frac{y-c_y}{f_y}*Z=vmcy*Z\\\]</span> 若X,Y,Z位于平面AX+BY+CZ+D=0内，则 <span class="math display">\[A*umcx*Z+B*vmcy*Z+C*Z+D=0\\A*umcx+B*vmcy+C=-\frac{D}{Z}\]</span></p></li><li><p><strong>PostRefineCenterWithGroundBoundary</strong>硬约束--</p><p>该函数通过<code>line_segs</code>(内部存储了当前帧检测物体的2D框信息),</p><p>部分主要处理如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// hard constraints</span></span><br><span class="line"><span class="keyword">bool</span> adjust_hard = PostRefineCenterWithGroundBoundary(</span><br><span class="line">      bbox, hwl, *ry, options.plane, options.line_segs, center,</span><br><span class="line">      options.check_lowerbound);</span><br><span class="line"><span class="comment">//该函数主要处理流程如下：</span></span><br></pre></td></tr></table></figure><p>GetDxDzForCenterFromGroundLineSeg</p><p>先通过平面约束得到2d box (两点)在 3d中的反投影，即将bbox2d中的两个点反投影到了3d平面中。</p><p>将坐标系转为车辆坐标系</p><p>得到障碍物中心与车辆中心的直线方程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateOffsetZ</span><span class="params">(T x_start, T z_start, T x_end, T z_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;T, T&gt; &amp;range, T *z_offset)</span> </span>&#123;</span><br><span class="line">  CHECK(range.first &lt; range.second);</span><br><span class="line">  <span class="keyword">if</span> (x_start &gt; x_end) &#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(x_start, x_end);</span><br><span class="line">    <span class="built_in">std</span>::swap(z_start, z_end);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T x_check_l = <span class="built_in">std</span>::<span class="built_in">max</span>(x_start, range.first);</span><br><span class="line">  T x_check_r = <span class="built_in">std</span>::<span class="built_in">min</span>(x_end, range.second);</span><br><span class="line">  T overlap_x = x_check_r - x_check_l;</span><br><span class="line">  <span class="keyword">if</span> (overlap_x &lt; <span class="number">1e-6</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T dz_divide_dx = (z_end - z_start) * common::IRec(x_end - x_start);</span><br><span class="line">  T z_check_l = z_start + (x_check_l - x_start) * dz_divide_dx;</span><br><span class="line">  T z_check_r = z_start + (x_check_r - x_start) * dz_divide_dx;</span><br><span class="line">  T z_nearest = <span class="built_in">std</span>::<span class="built_in">min</span>(z_check_l, z_check_r);</span><br><span class="line">  <span class="keyword">if</span> (z_nearest &lt; *z_offset) &#123;</span><br><span class="line">    *z_offset = z_nearest;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献：基于车载单目图像的3维地平面估计_向文辉</p><p><img src="/2020/02/25/apollo-obstacle-postprocess/66.png"></p><p><img src="/2020/02/25/apollo-obstacle-postprocess/67.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 障碍物检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tracking without bells and whistles论文阅读</title>
      <link href="/2020/02/23/tracking_without_bells_and_whistles/"/>
      <url>/2020/02/23/tracking_without_bells_and_whistles/</url>
      
        <content type="html"><![CDATA[<p>tracking without bells and whistles 论文阅读笔记 <strong>A detector is all you need for Multi-Object Tracking</strong></p><a id="more"></a><h2 id="fasterrcnn回顾">FasterRCNN回顾</h2><p><img src="/2020/02/23/tracking_without_bells_and_whistles/20170324121024882.png"></p><p>FasterRCNN将<strong>特征提取、Proposal提取、BoundingBox回归、分类</strong>整合到一个网络中：</p><ul><li><strong>特征提取</strong>：Faster R-CNN首先使用基础的conv+relu+pooling层提取候选图像的<strong>共享特征图</strong>，该特征图被共享用于后续的RPN(Region Proposal Network)层和全连接层(FC)</li><li><strong>区域候选网络</strong>（Region Proposal Network）：RPN网络用于生成候选图像块。该层通过<code>softmax</code>判断锚点<code>anchors</code>属于前景(foreground)或者背景(background)的概率，再利用边界框回归修正<code>anchors</code>获得获得较精确的proposals。(上面的分支分类anchor的前景和背景，下面的分支计算前景（即目标）anchor的偏移量(bbox回归)，实际上RPN实现了目标的定位)</li><li><strong>目标区池化</strong>(Roi Pooling):该层收集<code>输入特征图</code>和<code>候选的目标区域</code>，综合这些信息提取<code>目标区域的特征图</code>(proposal feature)，送入后续的全连接层进行目标类别的判断</li><li><strong>目标分类</strong>：利用<code>目标区域的特征图</code>计算目标区域的类别，同时再次边界框回归获得检测框最终的精确位置。</li></ul><p>FasterRCNN特征图每个点有9个anchor,而RPN实际就是在原图像的尺度上，设置了密密麻麻的anchor，然后通过CNN判断哪个anchor是没有目标的背景(background)，哪些anchor是有目标的前景(foreground)，boundingbox的回归用到了两次，实际训练过程如下，分为两次循环：</p><ol type="1"><li>在已经训练好的model上，训练RPN网络，对应stage1_rpn_train.pt (RPN出的bbox回归)</li><li>利用步骤1中训练好的RPN网络，收集proposals，对应rpn_test.pt</li><li>第一次训练Fast RCNN网络，对应stage1_fast_rcnn_train.pt(最终检测处的bbox回归)</li><li>第二训练RPN网络，对应stage2_rpn_train.pt</li><li>再次利用步骤4中训练好的RPN网络，收集proposals，对应rpn_test.pt</li><li>第二次训练Fast RCNN网络，对应stage2_fast_rcnn_train.pt</li></ol><p><img src="/2020/02/23/tracking_without_bells_and_whistles/23.jpg" style="zoom:80%;"></p><p><img src="/2020/02/23/tracking_without_bells_and_whistles/66.jpg" style="zoom:30%;"></p><blockquote><p>参考链接：</p><p>https://blog.csdn.net/shenziheng1/article/details/82907663</p><p>https://zhuanlan.zhihu.com/p/32404424</p></blockquote><h2 id="tracking-without-bells-and-whistles">tracking without bells and whistles</h2><h3 id="网络结构流程">网络结构流程</h3><p><img src="/2020/02/23/tracking_without_bells_and_whistles/tracking.png"></p><p>跟踪器： 轨迹(trajectory)由一系列针对k目标的有序bounding box组成的<span class="math inline">\(T_k=\{b_{t1}^k,b_{t2}^k,...\}\)</span>, <span class="math inline">\(b^k_t=(x,y,w,h)\)</span>，<span class="math inline">\(t\)</span>代表当前帧。 同时定义第<span class="math inline">\(t\)</span>帧中的目标边界框集合为<span class="math inline">\(B_t=\{b_{t}^{k1},b_t^{k2},...\}\)</span>,注意每个跟踪轨迹<span class="math inline">\(T_k\)</span>或者边界框集合<span class="math inline">\(B_t\)</span>包含的元素可以少于序列中轨迹或帧的总数量。</p><ol type="1"><li><strong>初始化</strong> 在t=0时，跟踪器初始化为第一次检测器检测到的目标的集合<span class="math inline">\(D_0=\{d_0^1,d_0^2,...\}=B_0\)</span>,在上图中，演示了接下来将要进行的两个步骤，对于给定帧<span class="math inline">\(t\)</span>的<strong>bounding box regression</strong> 和 <strong>track initialization</strong></li><li><p><strong>Bounding box regression</strong></p><p>首先，如图中蓝线所示，通过bbox regerssion扩展active trajectories到当前帧t:这是通过t-1帧的bbox <span class="math inline">\(b_{t-1}^k\)</span>回归得到t帧时物体新的位置<span class="math inline">\(b_t^k\)</span> ，将前一帧的坐标作为ROI Pooling的依据。</p><p>deactive一个trajectory的条件：</p><ul><li>物体消失或者被非检测物体类型遮挡(对应其类别分数<span class="math inline">\(s_t^k\)</span>低于<span class="math inline">\(\sigma_{active}\)</span>)</li><li>检测物体之间遮挡通过NMS处理（对于该帧中所有保留的边界框<span class="math inline">\(B_t\)</span> 根据它们之间的IOU阈值<span class="math inline">\(\lambda_{activate}\)</span>）</li></ul></li><li><p><strong>Bounding box initialization</strong></p><p>如何去判断一个新的<code>targets</code>?</p><p>如上图红色线所示，目标检测其同时提供了该帧(frame t)中的所有检测<span class="math inline">\(D_t\)</span> ，对应的检测物体想要组成新的trajectories,需要其与所有已经激活的trajectories的边界框<span class="math inline">\(b_t^k\)</span>小于<span class="math inline">\(\lambda_{new}\)</span> 。当该目标不能被现有的trajectories解释（即包含一个潜在的新目标时）才考虑该检测物体组成新的trajectories。</p></li></ol><p>疑问： 仅通过该帧边界框位置回归预测边界框下一帧的位置，会不会随时间积累产生偏移。因为并没有在下一帧进行相关的纠正，除非它采用上一帧的检测估计下一阵跟踪位置之后，在下一帧中采用新的检测框回归下下一帧的位置，</p><h3 id="motion-model">Motion Model</h3><h3 id="re-identification">Re-identification</h3><p>通过Siamese网络生成appearance vectors</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> track </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单视图衡量论文阅读</title>
      <link href="/2020/02/20/single-view-metrology/"/>
      <url>/2020/02/20/single-view-metrology/</url>
      
        <content type="html"><![CDATA[<p>Single View Metrology 和3D bbox estiomation using deep learning and geometry 论文阅读笔记</p><a id="more"></a><h2 id="d-bbox-estimation-using-deep-learning-and-geometry">3D bbox estimation using deep learning and geometry</h2><p>通过神经网络输出三维物体朝向(3D object orientation)，三维物体尺寸(3d object dimensions)，结合2Dbbox 的几何约束，使能够恢复一个稳定的3D物体姿态（<span class="math inline">\(R,T\)</span>），通过Kitti数据集上的三维物体尺寸信息和三维物体bbox进行评估。 kitti数据集只评估3Dbbox的方向(orientation estimate)；此方法另外引入了3个额外的度量信息评估3d Box的准确性</p><ul><li>distance to center of box</li><li>distance to the center of the closest bounding box face</li><li>the overall bounding box overlap with the ground truth box（3D IOU）</li></ul><h2 id="d-bounding-box-estimation">3D Bounding box estimation</h2><p>前提:一个3D bbox 的投影应该包裹2D bbox，并同时假设2D detector 训练得到的bbox 是与3d bbox 投影有关的。</p><p><strong>2D bbox 每一边至少匹配3D bbox的一个角</strong> 即2D bbox 需要包裹住 3D bbox</p><p>3D box的描述为:</p><ul><li>中心位置 <span class="math inline">\(T=[t_x,t_y,t_z]^T\)</span>, (center of translation)</li><li>尺寸 <span class="math inline">\(D=[d_x,d_y.d_z]\)</span> （dimension）</li><li>方向 <span class="math inline">\(R(\theta,\phi,\alpha)\)</span>, (orientation) 采用方向角、仰角、翻滚角</li></ul><h3 id="d-bbox的投影与2d-bbox之间的约束关系">3D bbox的投影与2D bbox之间的约束关系</h3><p>在相机坐标系下确定位姿<span class="math inline">\((R,T)\in SE(3)\)</span> ,相机内参矩阵<span class="math inline">\(K\)</span> ,则一个物体坐标系下的三维坐标点<span class="math inline">\(X_o=[X,Y,Z,1]^T\)</span>投影到图像中的坐标<span class="math inline">\(x=[x,y,1]\)</span>的转换关系： <span class="math display">\[x=K[R\ \ \ \ T]X_o\]</span> 假设原始的物体坐标系的原点位于3D bbox 的中心，并且物体尺寸已知，则3D bbox顶点的坐标可以描述为： <span class="math display">\[X_1 = [d_x/2,d_y/2,d_z/2]^T,X_2 = [-d_x/2,d_y/2,d_z/2]^T,...,X_8=[-d_x/2,-d_y/2,-d_z/2]\]</span> 约束条件是2D bbox(<span class="math inline">\(x_{min},y_{min},x_{max},y_{max}\)</span>)的每一顶点至少被一个3D bbox 角点的投影得到，例如： 考虑3d bbox 顶点 <span class="math inline">\(X_0=[d_x/2,-d_y/2,d_z/2]\)</span> 投影到2d bbox左边 坐标<span class="math inline">\(x_{min}\)</span>,这用点对边的约束表示为下列等式。</p><figure><img src="/2020/02/20/single-view-metrology/image-20200220152658062.png" alt="image-20200220152658062"><figcaption>image-20200220152658062</figcaption></figure><p>其中<span class="math inline">\((.)_x\)</span>表示透视投影的x坐标，同样的方式可以推导出2d bbox的参数(<span class="math inline">\(x_{min},y_{min},x_{max},y_{max}\)</span>),总体来说，2D bbox的顶点为3d bbox提供了四个约束，但是这不足以限制3d bbox的九自由度（three for translation, three for rotation, and three for box dimensions），需要bbox的几何特性以及视觉外观进一步约束3d box。</p><p><img src="/2020/02/20/single-view-metrology/image-20200220181624364.png" alt="image-20200220181624364" style="zoom:80%;"></p><h3 id="如何选择回归参数">如何选择回归参数</h3><ul><li><p>方向角<span class="math inline">\(R(\theta,\phi,\alpha)\)</span></p></li><li><p>物体尺寸 <span class="math inline">\(D=[d_x,d_y.d_z]\)</span></p><p>估计物体尺寸而不估计位置的原因是物体尺寸的方差较小(车辆的尺寸基本一致)，同时不会因为旋转而发生变化(因为我们同时也在回归方向角)，物体尺寸的估计更容易与得到的物体类别紧密联系。</p></li></ul><p>通过回归得到的物体尺寸、3D bbox 方向、2D bbox 可以求得 物体位置，</p><p>仅考虑一般情况，3D bbox的8个顶点可以投影到任意的2D bbox的4个边，总共就有<span class="math inline">\(8^4=4096\)</span>中情况，但在大多数场景下，可以假定目标是竖直的，因此，2D bbox的顶部和底部只对应于3D bbox的顶部和底部(1024中情况)，同时目标不发生翻滚时(roll=0)，则垂直边的2D bbox 坐标<span class="math inline">\(x_{min},x_{max}\)</span>只能与3D bbox中的垂直边相关联，kitti中默认(roll = 0 ,pitch =0)，因此，最终投影关系的匹配数量只有64种情况,下图给出了一些匹配的情况，正面为蓝色，背面为红色框。</p><p><img src="/2020/02/20/single-view-metrology/corre.png" style="zoom: 67%;"></p><p><img src="/2020/02/20/single-view-metrology/m248gym63e.jpg" style="zoom:80%;"></p><h3 id="orientation-estimation">Orientation Estimation</h3><p><img src="/2020/02/20/single-view-metrology/image-20200220162637624.png" alt="image-20200220162637624" style="zoom:80%;"></p><p>上图右面的全局图像中，汽车的行驶方向并没有改变，但是在左边截取的图像中 显然汽车的方向发生了变化。因此在相机参考系下通过检测窗口获取物体的方向是不可行的，因为其余在图像中的位置相关。</p><p><img src="/2020/02/20/single-view-metrology/2.png" style="zoom:75%;"></p><p>上图所示，全局方向为<span class="math inline">\(\theta\)</span> (3d bbox方向)，局部方向<span class="math inline">\(\theta_{l}\)</span>为相机中心与检测框中心(假设为目标中心)的射线确定。由于<span class="math inline">\(\theta_l\)</span>会随着检测框中图像的不同而变化，因此训练的参数为<span class="math inline">\(\theta_l\)</span> 。通过给定相机内参<span class="math inline">\(\theta_{ray}\)</span>的计算是很容易的，通过计算的到的<span class="math inline">\(\theta_{ray}\)</span>以及估计得到的局部方向<span class="math inline">\(\theta_{l}\)</span>很容易就可以得到全局方向<span class="math inline">\(\theta=\theta_l+\theta_{ray}-2\pi\)</span>。</p><h3 id="网络结构">网络结构</h3><p><img src="/2020/02/20/single-view-metrology/170408.png" style="zoom:80%;"></p><p>在方向估计时</p><p><img src="/2020/02/20/single-view-metrology/image-20200220173628484.png" alt="image-20200220173628484" style="zoom: 80%;"></p><p><img src="/2020/02/20/single-view-metrology/image-20200220173530008.png" alt="image-20200220173530008" style="zoom:80%;"></p><p>在尺寸估计时，由于同一类别的物体方差很小，因此估计的是相对于标准(平均)尺寸（通过训练集上的尺寸可以计算得到）的差值。</p><p><img src="/2020/02/20/single-view-metrology/173312.png" style="zoom:75%;"></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单视图衡量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo编译过程及存在的问题</title>
      <link href="/2020/02/19/detect_build/"/>
      <url>/2020/02/19/detect_build/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>bazel 降级</p><blockquote><p>Latest Versions of Bazel Doesn't support git_repository (which is still used by tensorflow_hub), so Uninstalling Bazel 0.24.1 and installing Bazel 0.18.1 worked.</p></blockquote><p>https://www.betaflare.com/3714.html</p>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sort和DeepSort论文阅读笔记</title>
      <link href="/2020/02/19/Sort_DeepSort_read/"/>
      <url>/2020/02/19/Sort_DeepSort_read/</url>
      
        <content type="html"><![CDATA[<p>Sort和DeepSort多目标跟踪论文阅读笔记</p><a id="more"></a><h2 id="sort和deepsort论文阅读笔记">Sort和DeepSort论文阅读笔记</h2><h3 id="概述">概述</h3><h4 id="一些术语">1.一些术语</h4><p><strong>Trajectory</strong>(轨迹)：一条轨迹对应这一目标在一个时间段内的位置序列</p><p><strong>Tracklet</strong>(轨迹段)：形成Trajectory过程中的轨迹片段。完整的Trajectory是由属于同一目标的Tracklets组成。</p><p><strong>ID switch</strong>(ID切换)：对于同一个目标，由于跟踪算法误判导致其ID发生切换的次数，理想的跟踪算法ID switch应为0。</p><h4 id="评价指标">2.评价指标</h4><p>最主要的评价指标是<code>MOTA</code> ,该指标包含了三个要素：FP、FN、identity switches(ID switch)。MOTA越高代表跟踪的综合性能越好。</p><h4 id="框架策略">3.框架策略</h4><ul><li><p>Tracking - by - detection(TBD)</p></li><li><p>Detection-Free Tracking(DFT)</p></li></ul><p>MOT问题本质上可以视为数据关联的问题，即如何将不同时刻的检测目标关联起来，关联目标主要以目标<code>motion</code>的建模和<code>apperance</code>即目标的外观作为关联的根据。</p><h3 id="sort">Sort</h3><p>在卡尔曼滤波的基础上+匈牙利算法将<strong>卡尔曼滤波预测的BBox</strong>与<strong>物体检测的BBox</strong>进行了匹配，选择合适的物体检测BBox作为下一时刻的<strong>物体跟踪BBox</strong>。</p><h4 id="detection">1.Detection</h4><p>采用了FasterRCNN，</p><h4 id="estimation-model">2. Estimation Model</h4><p>通过<code>linear constant velocity model</code>（线性恒速度模型）估计帧间物体的位移。 <span class="math display">\[x = [u,v,s,r,\dot{u},\dot{v},\dot{s}]^{T}\]</span> 每一个目标的状态采用上述模型描述，其中<code>u</code>和<code>v</code>分别表示目标中心水平和垂直方向像素位置；<code>s</code>和<code>r</code>分别表示面积(scale)和目标边界框的长宽比(aspect ratio)。当一个检测与目标相关联之后，检测得到的bbox被用于更新目标的状态（被更新的状态中，速度分量由卡尔曼滤波器估计得到）；若没有检测与目标关联，利用线性恒速度模型对其状态进行简单预测无需纠正。</p><h4 id="data-association">3.Data Association</h4><p>在分配检测结果到现有的跟踪目标过程中，每一个跟踪目标的bbox通过卡尔曼滤波器提前预测。然后计算每个检测目标和预测的跟踪目标的bbox的交并比(IOU)作为代价矩阵。最后通过<code>匈牙利算法(Hungarian algorithm)</code>解决最优分配问题，小于阈值<span class="math inline">\(IOU_{min}\)</span>的目标不会分配此检测器。</p><h4 id="creation-and-deletion-of-track-identities">4.Creation and Deletion of Track Identities</h4><p>当目标进入或者离开图像，相应需要创建和销毁跟踪的ID。</p><p>对于创建一个跟踪目标，根据是检测与目标的重叠(IOU)小于一定阈值 <span class="math inline">\(IOU_{min}\)</span> ，即认为此检测是一个未被跟踪的对象，并将其状态进行初始化(形状为检测的bbox形状，速度为0),由于此点速度无法估计，因此速度分量的协方差应初始化为一个较大的值，以表征此不确定性。同时，新加入的目标应经过一段试用期，目标需要与检测相关联，以积累足够的证据，防止<code>false positive</code>。</p><p>跟踪终止，当在<span class="math inline">\(T_{Lost}\)</span>帧没有检测到与之关联的检测。这可以防止跟踪器数量的无限增长和由于<u>长时间不根据检测修正的预测</u>导致的定位误差。一般<span class="math inline">\(T_{Lost}\)</span>被设置为1，因为<code>恒速度模型</code>不能很好的描述目标的动态特性，其次本工作关注于帧与帧之间的跟踪，<code>目标的重识别</code>超出了本工作的内容。另外，尽早地删除丢失的目标有利于提高效率。</p><hr><h3 id="deep-sort">Deep Sort</h3><p>由于Sort对于物体遮挡没有显式地处理，因此其<code>ID Switch</code>很高,因此DeepSort中融入了apperance information,即结合了运动和外观的信息。</p><h4 id="deep-association-metric">1. Deep Association Metric</h4><ul><li><strong>state space:</strong> <span class="math inline">\((u,v)\)</span> 为bbox中心位置，<span class="math inline">\(r\)</span>为纵横比，<span class="math inline">\(h\)</span>为高度，以及它们在图像坐标系下的相对速度</li></ul><p><span class="math display">\[(u,v,\gamma,h,\dot{x},\dot{y},\dot{\gamma},\dot{h})\]</span></p><p>依然采取恒速度的线性观测模型进行估计，直接估计的状态为<span class="math inline">\((u,v,r,h)\)</span>，</p><ul><li><p><strong>assignment problem</strong>:</p><p>Sort 中将新检测到的物体与状态估计得到的预测框进行匹配采用的是<code>匈牙利算法</code>。在DeepSort中需要综合运动和外观信息进行匹配,对此设计了两个合适的度量。</p><p><em>1.motion information:</em> Mahalanobis distance <span class="math display">\[d^{(1)}(i,j)=(d_j-y_i)^{T}S_i^{-1}(d_j-y_i)\]</span> 其中<span class="math inline">\(d_j\)</span>为第<span class="math inline">\(j\)</span>个检测到的bbox，<span class="math inline">\(y_i\)</span>为第<span class="math inline">\(i\)</span>个估计的bbox，马氏距离,指标为,本文阈值为<span class="math inline">\(t^{(1)} = 9.4877\)</span> <span class="math display">\[b_{i,j}^{(1)}=1[d^{(1)}(i,j)\leq t^{(1)}]\]</span> <em>2.apperance information:</em> cosine distance <span class="math display">\[d^{(2)}(i,j)=min\{1-r_j{}^{T}r_k^{(i)}|r_k^{(i)}\in R_i\}\]</span> 对于每个新检测到的bbox <span class="math inline">\(d_j\)</span>，我们计算外观描述（apperance descrioptor）<span class="math inline">\(r_j\)</span>,<span class="math inline">\(||r_j||=1\)</span>。同时，创建<span class="math inline">\(R_k=\{r_k^{(i)}\}_{k=1}^{L_k}\)</span>为最近<span class="math inline">\(L_k=100\)</span>次成功跟踪后 物体检测bbox对应的<span class="math inline">\(L_k\)</span>个特征向量集合。然后第二种度量方式通过第<span class="math inline">\(i\)</span>个跟踪物体特征向量与第<span class="math inline">\(j\)</span>个检测特征向量之间的最小余弦距离表示。</p><p>同样引入一个二元变量表示此关联是否被允许： <span class="math display">\[b_{i,j}^{(2)}=1[d^{(2)}(i,j)\leq t^{(2)}]\]</span> 外观描述特征向量如何获取？文章中采用了CNN网络获取，结构如下：</p><p><img src="/2020/02/19/Sort_DeepSort_read/cnn.png" style="zoom:75%;"></p><p>综上，通过加权获得最终的度量标准:<span class="math inline">\(c_{i,j}=\lambda d^{(1)}(i,j)+(1-\lambda)d^{(2)}(i,j)\)</span>，同时对应的关联标准<span class="math inline">\(b_{i,j}=\prod_{m=1}^{2}b_{i,j}^{(m)}\)</span>,当相机有较大运动时，取<span class="math inline">\(\lambda=0\)</span>是合适的选择。但基于卡尔曼滤波器推断的马氏距离仍用于忽视不可行的分配。</p></li><li><p><strong>Matching Cascade</strong></p><p>解决了度量问题后，如何匹配track 和 detect，文中提出如下方式：</p><p><img src="/2020/02/19/Sort_DeepSort_read/match.png"></p><p>输入为跟踪集合和检测集合，索引分别为<span class="math inline">\(T,D\)</span> ;首先根据之前的公式计算了代价矩阵<strong>C</strong>和门控矩阵<strong>B</strong>。然后对跟踪器最长存在时间进行迭代，在第6行中选择跟踪器子集<span class="math inline">\(T_n\)</span>(过去n帧都没有被检测器匹配的跟踪目标)，第7行根据代价矩阵匹配<span class="math inline">\(T_n\)</span>和为别分配的检测器目标。第8，9行更新匹配和未匹配的集合，最终返回<span class="math inline">\(M,U\)</span> 。</p><p>显然此循环保证了优先将检测的新目标分配给最近的跟踪。最终匹配阶段，通过和Sort中一样的IOU关联算法作用于age=1的未被匹配跟踪目标，这有助于解释外观的突然变化（例如由于被静态场景局部遮挡）。</p></li><li><p><strong>Deep Apperance Descriptor</strong></p><p>通过在行人重识别数据集上的训练CNN。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标跟踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>caffe 学习伊始</title>
      <link href="/2020/02/18/caffe-learn-start/"/>
      <url>/2020/02/18/caffe-learn-start/</url>
      
        <content type="html"><![CDATA[<p>caffe 学习系列 <a id="more"></a></p><p>打算系统学习caffe源码，现在这占个坑 目前打算阅读顺序:SyncedMemory-&gt;Blob-&gt;layer-&gt;Net-&gt;solver 将开一系列笔记： (1)caffe源码学习SyncedMemory (2)caffe源码学习Blob ...</p>]]></content>
      
      
      <categories>
          
          <category> caffe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> caffe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bazel C++编译入门</title>
      <link href="/2020/02/16/bazel-learn/"/>
      <url>/2020/02/16/bazel-learn/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="安装">安装</h2><p>参考：https://docs.bazel.build/versions/master/install.html</p><p>apt 安装失败，通过binary安装,安装文件下载：https://github.com/bazelbuild/bazel/releases</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install g++ unzip zip</span><br><span class="line"><span class="comment"># Ubuntu 16.04 (LTS) uses OpenJDK 8 by default:</span></span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu 18.04 (LTS) uses OpenJDK 11 by default:</span></span><br><span class="line">sudo apt-get install openjdk-11-jdk</span><br><span class="line">sudo bash bazel-&lt;version&gt;-installer-linux-x86_64.sh --user</span><br><span class="line"></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin"</span></span><br></pre></td></tr></table></figure><h2 id="编译">编译</h2><p>参考教程:https://docs.bazel.build/versions/master/tutorial/cpp.html</p><h3 id="工作区workspace">工作区(workspace)</h3><p>bazel基于工作区(workspace)的概念编译，工作区存放了所有的源代码和Bazel编译输出文件的目录，也就是整个项目的根目录，与bazel编译相关的文件:</p><ul><li>WORKSPACE文件，用于指定当前文件夹就是一个Bazel的工作区，所以WORKSPACE文件总是存在于项目的根目录下。</li><li>一个或多个BUILD文件，用于告诉Bazel怎么构建项目的不同部分。(如果工作区中的一个目录包含含BUILD文件，即为一个package)</li></ul><p>如果要指定一个目录为Bazel工作区，只要在该目录下创建一个空的WORKSPACE文件即可。当Bazel编译项目是，所有的输入和依赖想都必须在同一个工作区中，不同的工作区的文件，除非linked否则彼此独立。</p><p>WORKSPACE文件中可以设置第三方代码库，即外部引用</p><h3 id="build文件组成">BUILD文件组成</h3><p>BUILD文件中最重要的指令是编译指令，告诉Bazel如何编译输出，比如是生成可执行二进制文件还是链接库。BUILD文件中每一天编译指令被称为一个target，它指向一系列的源文件和依赖，一个target也可以指向别的target。</p><p>bazelbuild的简单例子可以参考：https://github.com/bazelbuild/examples</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"@rules_cc//cc:defs.bzl"</span>, <span class="string">"cc_binary"</span>)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">name = <span class="string">"hello-world"</span>,</span><br><span class="line">srcs = [<span class="string">"hello-world.cc"</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>name</code>即为该target名称，<code>src</code>包含了源文件，<code>cc_binary</code>为内置的生成二进制文件的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build //main:hello-world</span><br></pre></td></tr></table></figure><p>在WORSPACE目录下上述命令行指令即可实现编译，<code>main:hello-world</code>表示位于main目录下的target <code>helo-world</code>,同时获得如下输出，生成的二进制文件位于<code>bazel-bin/main/hello-world</code> <strong>路径相对于WORKSPACE</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO: Found 1 target...</span><br><span class="line">Target //main:hello-world up-to-date:</span><br><span class="line">  bazel-bin/main/hello-world</span><br></pre></td></tr></table></figure><h3 id="多个target同时编译">多个target同时编译</h3><p>对于大型项目来说，一般会把它拆分成多个<code>target</code>和多个<code>package</code>来实现快速增量的编译。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"@rules_cc//cc:defs.bzl"</span>, <span class="string">"cc_binary"</span>, <span class="string">"cc_library"</span>)                   </span><br><span class="line"></span><br><span class="line">cc_library(</span><br><span class="line">   name = <span class="string">"hello-greet"</span>,</span><br><span class="line">   srcs = [<span class="string">"hello-greet.cc"</span>],</span><br><span class="line">   hdrs = [<span class="string">"hello-greet.h"</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">    name = <span class="string">"hello-world"</span>,</span><br><span class="line">    srcs = [<span class="string">"hello-world.cc"</span>],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">":hello-greet"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在这个BUILD文件中，首先编译了<code>hello-greet</code>这个库(利用bazel内置的cc_library编译指令)，然后在编译<code>hello-world</code>这个二进制文件。<code>hellow-world</code>这个target的<code>deps</code>属性告诉Bazel，要构建<code>hello-world</code>这个二进制文件，首先需要<code>hello-greet</code>这个库。</p><h3 id="多个package同时编译">多个package同时编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">└── stage3</span><br><span class="line">    ├── lib</span><br><span class="line">    │   ├── BUILD</span><br><span class="line">    │   ├── hello-time.cc</span><br><span class="line">    │   └── hello-time.h</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── BUILD</span><br><span class="line">    │   ├── hello-greet.cc</span><br><span class="line">    │   ├── hello-greet.h</span><br><span class="line">    │   └── hello-world.cc</span><br><span class="line">    ├── README.md</span><br><span class="line">    └── WORKSPACE</span><br></pre></td></tr></table></figure><p>两个BUILD对应的为两个package,因此对于Bazel来说，整个工作区包含了两个package: lib和main。两个目录下的<code>BUILD</code>文件分别定义如下： main下的BUILD文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"@rules_cc//cc:defs.bzl"</span>, <span class="string">"cc_binary"</span>, <span class="string">"cc_library"</span>)                   </span><br><span class="line"></span><br><span class="line">cc_library(</span><br><span class="line">    name = <span class="string">"hello-greet"</span>,</span><br><span class="line">    srcs = [<span class="string">"hello-greet.cc"</span>],</span><br><span class="line">    hdrs = [<span class="string">"hello-greet.h"</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">    name = <span class="string">"hello-world"</span>,</span><br><span class="line">    srcs = [<span class="string">"hello-world.cc"</span>],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">":hello-greet"</span>,</span><br><span class="line">        <span class="string">"//lib:hello-time"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>lib/BUILD</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"@rules_cc//cc:defs.bzl"</span>, <span class="string">"cc_library"</span>)                                </span><br><span class="line"></span><br><span class="line">cc_library(</span><br><span class="line">    name = <span class="string">"hello-time"</span>,</span><br><span class="line">    srcs = [<span class="string">"hello-time.cc"</span>],</span><br><span class="line">    hdrs = [<span class="string">"hello-time.h"</span>],</span><br><span class="line">    visibility = [<span class="string">"//main:__pkg__"</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>显然main下的<code>hello-world</code>这个target依赖于<code>lib</code>这个package中的<code>hello-time</code>target 即(<code>deps = [&quot;//lib:hello-time&quot;]</code>),Bazel通过<code>deps</code>这个属性知道自己的依赖项。同时注意到<code>lib/BUILD</code>文件中的将<code>hello-time</code>这个target显示可见(通过<code>visibility</code>属性)，这是因为默认情况下targets只对同一个BUILD文件里的其他targets可见。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build //main:hello-world</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>doxygen</title>
      <link href="/2020/02/16/doxygen/"/>
      <url>/2020/02/16/doxygen/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>参考：https://www.ibm.com/developerworks/cn/aix/library/au-learningdoxygen/index.html</p></blockquote><h2 id="安装doxygen">安装doxygen</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install flex bison</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/doxygen/doxygen.git</span><br><span class="line"><span class="built_in">cd</span> doxygen</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. &amp; make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="使用doxygen生成文档">使用Doxygen生成文档</h2><p>--目前应用好像有困难　　暂时先不写了</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Component 组件注册过程</title>
      <link href="/2020/02/16/cyber-component/"/>
      <url>/2020/02/16/cyber-component/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CYBER_REGISTER_COMPONENT(FusionCameraDetectionComponent);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYBER_REGISTER_COMPONENT(name) \</span></span><br><span class="line">  CLASS_LOADER_REGISTER_CLASS(name, apollo::cyber::ComponentBase)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register class macro</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_LOADER_REGISTER_CLASS(Derived, Base) \</span></span><br><span class="line">  CLASS_LOADER_REGISTER_CLASS_INTERNAL_1(Derived, Base, __COUNTER__)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_LOADER_REGISTER_CLASS_INTERNAL_1(Derived, Base, UniqueID) \</span></span><br><span class="line">  CLASS_LOADER_REGISTER_CLASS_INTERNAL(Derived, Base, UniqueID)</span><br></pre></td></tr></table></figure><p>最终实际执行： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_LOADER_REGISTER_CLASS_INTERNAL(Derived, Base, UniqueID)     \</span></span><br><span class="line">  <span class="keyword">namespace</span> &#123;                                                             \</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ProxyType</span>##<span class="title">UniqueID</span> &#123;</span>                                            \</span><br><span class="line">    ProxyType##UniqueID() &#123;                                               \</span><br><span class="line">      apollo::cyber::class_loader::utility::RegisterClass&lt;Derived, Base&gt;( \</span><br><span class="line">          #Derived, #Base);                                               \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125;;                                                                      \</span><br><span class="line">  <span class="keyword">static</span> ProxyType##UniqueID g_register_class_##UniqueID;                 \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> Base&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterClass</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; base_class_name)</span> </span>&#123;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"registerclass:"</span> &lt;&lt; class_name &lt;&lt; <span class="string">","</span> &lt;&lt; base_class_name &lt;&lt; <span class="string">","</span></span><br><span class="line">        &lt;&lt; GetCurLoadingLibraryName();</span><br><span class="line"></span><br><span class="line">  utility::AbstractClassFactory&lt;Base&gt;* new_class_factrory_obj =</span><br><span class="line">      <span class="keyword">new</span> utility::ClassFactory&lt;Derived, Base&gt;(class_name, base_class_name);</span><br><span class="line">  new_class_factrory_obj-&gt;AddOwnedClassLoader(GetCurActiveClassLoader());</span><br><span class="line">  new_class_factrory_obj-&gt;SetRelativeLibraryPath(GetCurLoadingLibraryName());</span><br><span class="line"></span><br><span class="line">  GetClassFactoryMapMapMutex().lock();</span><br><span class="line">  ClassClassFactoryMap&amp; factory_map =</span><br><span class="line">      GetClassFactoryMapByBaseClass(<span class="keyword">typeid</span>(Base).name());</span><br><span class="line">  factory_map[class_name] = new_class_factrory_obj;</span><br><span class="line">  GetClassFactoryMapMapMutex().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列容器</title>
      <link href="/2020/02/13/sequence-containers/"/>
      <url>/2020/02/13/sequence-containers/</url>
      
        <content type="html"><![CDATA[<p>c++ 模板库中序列容器的使用</p><a id="more"></a><p>序列(顺序)容器以线性序列的方式存储元素。它没有对元素进行排序，元素的顺序和存储它们的顺序相同,主要有以下五种标准的序列容器：</p><blockquote><ul><li>array&lt;T,N&gt;(数组容器):长度固定的序列，存放N个T类型的对象，不能增加或删除元素。</li><li>vector<T>(向量容器):长度可变的序列，存放T类型的对象，只能在序列的末尾增删元素。</T></li><li>deque<T>(双向队列容器):长度可变的序列，两端均可增删元素。</T></li><li>list<T>(链表容器):长度可变的序列，存放T类型对象，在序列任何地方都可以增加或删除元素。(双向链表)</T></li><li>forward_list<T>(正向链表容器)，长度可变，由T类型对象组成的序列。(单向链表)</T></li></ul></blockquote><p>下面具体介绍容器中常见的函数成员用法(限于篇幅，主要介绍典型的vector容器和list容器)</p><p>为了方便介绍STL的相关内容，首先介绍STL库的相关前置知识和思想，主要包括：</p><blockquote><ul><li>模板</li><li>容器</li><li>迭代器</li><li>智能指针</li><li>算法</li></ul></blockquote><h3 id="一前置知识">一、前置知识</h3><ul><li><p><strong>模板</strong></p><p>模板是一组函数或类的参数实现，模板并不是可执行代码，而是用于生成代码的配方，没有使用的模板会被编译器忽略。</p><p><strong>模板函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp; <span class="title">larger</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;<span class="comment">//&amp;表示引用</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">first</span><span class="params">(<span class="string">"To be or not to be "</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">second</span><span class="params">(<span class="string">"This is a question"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; larger(first, second) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b =<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; larger(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; To be <span class="keyword">or</span> <span class="keyword">not</span> to be </span><br><span class="line">&gt;&gt;&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>模板函数可以隐式推断传入类型，当然也可以显式指定类型</p><p><strong>模板类</strong></p><p>引入以下实现一个数组类的实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; //memory 要置于shared_ptr之前　真神奇</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/shared_ptr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A *elements;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Array</span><span class="params">(<span class="keyword">size_t</span> arraySize)</span></span>;   <span class="comment">//显式构造函数</span></span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;other);          <span class="comment">//拷贝构造函数 </span></span><br><span class="line">    Array(Array &amp;&amp;other);               <span class="comment">//转移构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Array() &#123;&#125;;                   <span class="comment">//析构函数</span></span><br><span class="line">    A &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> index);        <span class="comment">//Subscript operator</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> index) <span class="keyword">const</span>;  <span class="comment">// Subscript operator</span></span><br><span class="line">    Array &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;rhs);   <span class="comment">// Assignment operator</span></span><br><span class="line">    Array &amp;<span class="keyword">operator</span>=(Array &amp;&amp;rhs);   <span class="comment">//Move assignment operator　&amp;&amp;:右值引用</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;     <span class="comment">//Accessor for count</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拷贝构造函数利用现有对象初始化创建新对象(Array<int> A2 =A1)，为防止shallow copy ,需要重载此函数。</int></p><p>如果想要将A3的属性赋值给A4(A4 = A3),则需要重载operator。</p><p>类成员模板函数定义(std::nothrow 用于申请内存不足时返回nullptr)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line">Array&lt;A&gt;::Array(<span class="keyword">size_t</span> arraySize) : elements(<span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) A[arraySize]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elements == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Memory allocation faliure in Array constructor."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//没有足够的内存会返回nullptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">inline</span> Array&lt;A&gt;::Array(<span class="keyword">const</span> Array &amp;other):elements(<span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) A[other.count]), count(other.count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elements == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Memory allocation faliure in Array constructor."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; count; i++)&#123;</span><br><span class="line">            elements[i] = other.elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>容器</strong></p><p>容器是STL各种功能的基础，是以特定形式存储和组织其他对象的对象，容器中数据的访问采用iterators,STL提供以下几种类型的容器：</p><ul><li><strong>序列容器(sequence containers)：</strong>以线性组织的方式存储对象，和数组类似，但是不需要连续的存储空间。</li><li><strong>关联容器(Associative Containers)：</strong>存储和键关联的对象。可以通过相关联的建从关联容器中获取对应的值，也可通过迭代器从关联容器中得到对象。</li><li><strong>容器适配器(Container Adapters):</strong> 是提供了替换机制的适配类模板，可以用来访问基础的序列容器和关联容器。</li></ul><p>STL容器存储的是对象的副本。STL要求移动构造函数和复制运算符必须被指定为noexcept，即不会抛出异常。容器在堆上存放对象，并自动管理它们所占用的内存，一个T类型的对象如果要存放在容器中，需要满足一些特定要求，这些要求取决与你对元素执行的操作，通常有复制、移动、交换等操作,下面给出一个满足在容器中存放的T类型对象的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T();<span class="comment">//default constructor</span></span><br><span class="line">    T(<span class="keyword">const</span> T &amp;t);<span class="comment">//copy constructor</span></span><br><span class="line">    ~T();<span class="comment">//Destructor</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> T &amp;t);<span class="comment">//重载＝运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在关联容器中使用对象的话，对象需要定义operator&lt;(),提供小于运算符，来使用sort()和merge()这类算法。</p></li><li><p><strong>迭代器</strong></p><p>​ 当使用容器时，不可避免地会使用到iterators去访问数据，迭代器是一个行为类似于指针的模板类对象，只要迭代器iter指向一个有效对象，就可以通过使用*iter解引用的方式来获取一个对象的引用。如果iter指向一个可以访问成员的类对象，类成员就可以通过iter-&gt;member来使用。</p><p>​ 迭代器将算法和不同类型容器的元素联系了起来，获取迭代器的方式有：</p><ul><li>调用容器对象<code>begin()</code>和<code>end()</code>，返回的这两个迭代器分别指向第一个和最后一个元素下一个位置。<code>end()</code>返回的迭代器并没有指向一个有效的元素，所以既不能解引用，也不能递增它。亦可以通过调用<code>std::beign(container)</code>和<code>std::end(contrainer)</code> 获取的迭代器是等价的。</li></ul><p>　不同的算法要求具有不同功能的迭代器，下面由简至繁依次列出不同类别的迭代器：</p><blockquote><ul><li><strong>输入迭代器(input iterators)</strong>提供对对象的只读访问，必须支持表达式<code>*iter</code>以引用它所指向的值，且输入迭代器无减量运算(iter--是错误的)。常用操作(iter++ 、iter1 == iter2、iter1 != iter2)</li><li><strong>输出迭代器(output iterators)</strong> 提供对对象的只写访问，必须支持表达式<code>*iter=new_value</code>,同样其无减量操作</li><li><strong>正向迭代器(forward iterators)</strong>结合了输入和输出迭代器的功能，可以使用多次。</li><li><strong>双向迭代器(bidirectional iterators)</strong>具有和正向迭代器同样的功能，但允许进行前向和后向遍历，一次可以使用减量操作和增量操作</li><li><strong>随机访问迭代器(random access iterators)</strong>提供了和双向迭代器同样的功能，但是能支持对元素的随机访问。同时支持<code>iter+n</code>,<code>iter-n</code>或者直接通过索引访问<code>iter[n]</code>,等同于<code>*(iter+n)</code>,还可通过<code>iter1-iter2</code>获得两个迭代器之间元素的个数。</li></ul></blockquote><ul><li><p>迭代器适配器</p><p>适配器类模板定义了三种不同的迭代器:反向迭代器(reverse iterators)、插入迭代器(insert iterators)和移动迭代器(move iterators)。</p><p>插入迭代器:</p><blockquote><p>后向插入迭代器(back_insert_itreator)通过调用成员函数<code>push_back()</code>将一个新元素添加到容器的尾部。<code>vecotr</code>、<code>list</code>、<code>deque</code>容器具有一个<code>push_back()</code>函数。</p><p>前向插入迭代器(front_insert_iterator)通过调用成员函数<code>push_front()</code>将一个新元素添加到容器的头部。<code>list</code> 、<code>forward_list</code> 、<code>deque</code>容器均有一个<code>push_front()</code>函数</p></blockquote></li></ul></li><li><p>智能指针</p><p>智能指针是一个可以模仿原生指针(指向静态变量或堆上生成的变量)的模板类，主要区别在于：</p><ul><li>智能指针只能用来保存<code>堆</code>上分配的内存的地址。</li><li>不能像对原生指针一样对智能指针进行一些自增或是自减这样的算数运算。</li></ul><p>对于在自由存储区创建的对象，通常使用智能指针而不是原生指针。智能指针的优势是不用担心内存的释放，可以在容器中使用智能指针，如果使用一个类的基类作为智能指针的类型参数，可以用它指向一个派生类对象，这保存了一个对象的指针而不是对象，因而能够保持这个对象的多态性,std明明空间中定义了三种不同类型的智能指针模板：</p><ul><li><p><code>unique_ptr&lt;T&gt;</code>对象就像一个指向类型T的指针，具有排它的特性，不存在多个<code>unique_ptr&lt;T&gt;</code> 指向同一个地址，即一个<code>unique_ptr&lt;T&gt;</code>完全拥有它所指向的内容。可以使用std::move()移出其存储的地址，移出后该<code>unique_ptr&lt;T&gt;</code>变为无效。</p></li><li><p><code>shared_ptr&lt;T&gt;</code>对象和<code>unique_ptr&lt;T&gt;</code>不同的是多个<code>shared_ptr&lt;T&gt;</code>可以指向同一个地址，共享对象的所有权，引用计数保存了指向给定地址的<code>shared_ptr&lt;T&gt;</code>的数量，当引用计数为0时，分配的内存自动释放。</p></li><li><p><code>weak_ptr&lt;T&gt;</code>可以从一个<code>shared_ptr&lt;T&gt;</code>创建，它们指向同一个地址，创建<code>weak_ptr&lt;T&gt;</code>不会增加<code>shared_ptr&lt;T&gt;</code>对象的引用次数，所以其会组织所指向对象的销毁。使用<code>weak_ptr&lt;T&gt;</code>主要原因是为了避免<strong>循环引用</strong>。</p><p><strong>unique_ptr<T></T></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">pname</span><span class="params">(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span> (<span class="string">"Algernon"</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>或者使用<code>memory</code>头文件中函数<code>make_unique&lt;T&gt;()</code>函数来生成<code>unique_ptr&lt;T&gt;</code>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pname = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"Algernon"</span>)</span><br></pre></td></tr></table></figure><p>​ 注意不能以传值的方式将一个<code>unique_ptr&lt;T&gt;</code>对象传入函数中，因为它们不支持拷贝，<strong>必须使用引用的方式</strong>,同时只能通过移动或生成它们的方式，在容器中存放<code>unique_ptr&lt;T&gt;</code>对象。<code>unique_ptr&lt;T&gt;</code>对象析构会释放它所指向对象的内存。在解引用一个指针时，需要先判断其是否为空,<code>if(!pname)</code> 可以将<code>pname</code>隐式转换为布尔型。</p><p>​ 类的<code>get()</code>成员函数可以返回一个<code>unique_ptr&lt;T&gt;</code>所包含的原生指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> pstr &#123;unique_p.<span class="built_in">get</span>()&#125;</span><br></pre></td></tr></table></figure><p><strong>shared_ptr<T></T></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">pdata</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">999.0</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>或者使用<code>memory</code>头文件中函数<code>make_shared&lt;T&gt;()</code>来生成<code>shared_ptr&lt;T&gt;</code>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">double</span>&gt;(<span class="number">999.0</span>);</span><br></pre></td></tr></table></figure><p>使用<code>shared_prt&lt;T&gt;</code>的成员函数<code>get()</code> 可以获得一个原生指针:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pvalue = pdata.<span class="built_in">get</span>() <span class="comment">//return double*</span></span><br></pre></td></tr></table></figure><p>使用<code>reset()</code>函数重置指针,<code>unique()</code>可以查看对象的实例数，<code>use_count()</code>返回当前被调用对象的实例个数</p><p><strong>weak_ptr<T></T></strong></p><p><code>weak_ptr&lt;T&gt;</code>只能由<code>shared_ptr&lt;T&gt;</code>对象或已有的<code>weak_ptr&lt;T&gt;</code>创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata = <span class="built_in">std</span>::make_shared&lt;X&gt;();</span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;X&gt; <span class="title">pwdata</span> <span class="params">(pdata)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;X&gt; <span class="title">pwdata2</span> <span class="params">(pwdata)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>算法</strong></p><p>算法提供了计算和分析的函数，算法通过迭代器访问数据元素。</p><p>将函数作为实参传入另一个函数主要由以下三种方式：</p><ol type="1"><li>使用函数指针。</li><li>传入一个<code>函数对象</code>作为实参</li><li>使用<code>lambda</code>表达式作为形参</li></ol><ul><li><p>函数对象</p><p>函数对象也称仿函数，是重载了函数调用运算符<code>operator()()</code>的类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volume</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x ,<span class="keyword">double</span> y ,<span class="keyword">double</span> z)</span></span>&#123;<span class="keyword">return</span> x*y*z;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Volume volume;<span class="comment">//create a functor</span></span><br><span class="line"><span class="keyword">double</span> room &#123;volume(<span class="number">16</span>,<span class="number">12</span>,<span class="number">8.5</span>)&#125;;</span><br></pre></td></tr></table></figure></li><li><p>lambda表达式</p><p>一个lambda表达式定义了一个匿名函数，lambda可以捕获它们作用域内的变量,然后利用它们.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="keyword">double</span> value) &#123;<span class="keyword">return</span> value*value*value;&#125;</span><br></pre></td></tr></table></figure><p><code>[ ]</code>称为<code>lambda</code>引入符，表示了<code>lambda</code>表达式的开始，内部为捕获列表，引入符后面圆括号<code>()</code>表示了参数列表，与一般函数类似，<code>{}</code>中即为函数主体,值得注意的是示例中并没有具体指定返回类型，返回类型默认由返回值的类型，无返回值则为<code>void</code>，若要指定返回值<code>[](double value)-&gt;double {return value*value*value;}</code></p><p>可以使用变量来保存<code>lambda</code>的地址,然后变量可以当做函数指针使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cube = [](<span class="keyword">double</span> value)&#123;<span class="keyword">return</span> value*value*value;&#125;</span><br><span class="line"><span class="keyword">double</span> x &#123;<span class="number">2.5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">"cubed is: "</span> &lt;&lt; cube(x) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>将lambda表达式传给函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIter,<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(ForwardIter first,ForwoardIter last,F fun)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = first;iter!= last;++iter)</span><br><span class="line">*iter = fun(*iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形参fun接受任意合适的lambda表达式，也接受函数对象或普通的函数指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">change(<span class="built_in">std</span>::<span class="built_in">begin</span>(data),<span class="built_in">std</span>::<span class="built_in">end</span>(data),[] (<span class="keyword">int</span> value)&#123;<span class="keyword">return</span> value*value;&#125;);</span><br></pre></td></tr></table></figure><p>标准库的<code>functional</code>头文件定义了一个模板类型<code>std::function&lt;&gt;</code> ,对任意类型函数指针的封装，又给定的返回类型和形参类型。前面表示lambda表达式的变量可以按如下方式定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span> (<span class="keyword">double</span>)&gt; op = [] (<span class="keyword">double</span> value)&#123;<span class="keyword">return</span> value*value*value;&#125;;</span><br></pre></td></tr></table></figure><p>op现在可以作为实参，传给任意接受函数实参且签名相同的函数。</p><p><strong>捕获列表</strong></p><p><img src="/2020/02/13/sequence-containers/lambda.png"></p><p>默认捕获子句捕获和lambda表达式定义同样范围的所有变量。若<code>[]</code>中有<code>=</code>则为按值传递;若为<code>&amp;</code>则为按引用传递。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 模板类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中的神经网络框架</title>
      <link href="/2020/02/13/apollo-nn/"/>
      <url>/2020/02/13/apollo-nn/</url>
      
        <content type="html"><![CDATA[<h3 id="模型类型">模型类型</h3><p>model_type</p><p><code>modules/perception/inference/inference_factory.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Inference *<span class="title">CreateInferenceByName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;proto_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;weight_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;outputs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;inputs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;model_root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="string">"CaffeNet"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CaffeNet(proto_file, weight_file, outputs, inputs);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"RTNet"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RTNet(proto_file, weight_file, outputs, inputs);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"RTNetInt8"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RTNet(proto_file, weight_file, outputs, inputs, model_root);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"PaddleNet"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PaddleNet(proto_file, weight_file, outputs, inputs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RTNet 表示使用TensorRT加速</p>]]></content>
      
      
      <categories>
          
          <category> Apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apollo </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中can卡配置</title>
      <link href="/2020/02/08/can-conf/"/>
      <url>/2020/02/08/can-conf/</url>
      
        <content type="html"><![CDATA[<p>apollo开源框架中can卡的配置 <a id="more"></a></p><p>[TOC]</p><h3 id="前置内容">1. 前置内容</h3><p>本文主要参考：https://zhuanlan.zhihu.com/p/61838008</p><p>Apollo 在车辆的信息交互和车辆配置上均使用了<code>Protobuf</code></p><blockquote><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener" title="protobuf 相关介绍">[1]</a></p></blockquote><p>通常车企采用DBC文件完成CAN信号的定义和解析,由于Apollo中采用了Protobuf进行模块间的通信和配置，因此车企需要使用Apollo提供的工具基于DBC生成Apollo可用的proto文件。</p><blockquote><p>DBC文件是用来描述CAN网络通信信号的一种格式文件。</p></blockquote><p>一般各车厂DBC文件的定义不同并严格保密，为了解决无人驾驶系统中与车辆交互的问题，Apollo搭建了《开放汽车认证平台》，由此，方便无人驾驶的车辆部署，<code>ApolloAuto/apollo/tree/master/modules/canbus/vehicle</code> 中有目前支持的参考车辆目录。新增车辆需要新建一个目录以及对应的文件，通过工具可基于DBC文件快速生成Apollo参考车辆适配层模板， <span id="jump">工具</span>位于<code>ApolloAuto/apollo/tree/master/modules/tools/gen_vehicle_protocol</code> 下，使用方法参考<code>readme</code>。<a href="http://apollo.auto/docs/procedure_cn.html" target="_blank" rel="noopener" title="针对车辆CAN DBC文件如何生成proto文件">[3]</a></p><blockquote><p>该平台作为软硬件中间层，提出了开放车辆接口标准，定义了系统与车辆的线控接口，负责完成系统与汽车的具体交互，同时该平台抽象出了与车型无关的信号作为上层算法模块的输入，使得上层平台可以与底层车辆解耦。</p><p>具体线控需求规范可参考：https://link.zhihu.com/?target=http%3A//apollo-homepage.bj.bcebos.com/Apollo_by_wire_requirement.xlsx</p></blockquote><h3 id="apollo-cancard参数配置文件">2. Apollo Cancard参数配置文件</h3><h4 id="apollo-中采用proto文件管理相关配置">2.1 apollo 中采用proto文件管理相关配置</h4><p>apollo 激活车辆的配置文件的相关路径为<code>modules/canbus/conf/canbusconf.pb.txt</code>, 可在该文件中定义<strong>车型</strong>及对应的CAN card参数.</p><ul><li>apollo 中相关算法默认车辆是Lincoln MKZ ,如何置换或添加新的车辆到Apollo中可参考文档：<code>apollo/docs/howto/hwo_to_add_a_new_vehicle.md</code> <span id="newvehicle">  </span></li></ul><blockquote><ul><li>Implement the new vehicle controller :<code>class NewVehicleController final : public VehicleController{...}</code></li><li>Implement the new message manager：<code>class NewVehicleMessageManager : public MessageManager {...}</code></li><li>Implement the new vehicle factory:<code>class NewVehicleFactory : public AbstractVehicleFactory {...}</code></li><li>Register the New Vehicle:<code>void VehicleFactory::RegisterVehicleFactory(){...}</code></li><li>Update the configuration file: <code>vehicle_parameter{...}</code> 这就是下面要描述的。</li></ul></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vehicle_parameter &#123;</span><br><span class="line">  brand: LINCOLN_MKZ <span class="comment">//车型 该参数决定了车辆的相关标定参数</span></span><br><span class="line">  max_enable_fail_attempt: <span class="number">5</span> </span><br><span class="line">  driving_mode: COMPLETE_AUTO_DRIVE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">can_card_parameter &#123;</span><br><span class="line">  brand: ESD_CAN <span class="comment">//CAN卡通信方式，还有比如socket类型</span></span><br><span class="line">  type: PCI_CARD <span class="comment">//Can卡类型，还有比如USB_CARD</span></span><br><span class="line">  channel_id: CHANNEL_ID_ZERO </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enable_debug_mode: <span class="literal">false</span></span><br><span class="line">enable_receiver_log: <span class="literal">false</span></span><br><span class="line">enable_sender_log: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上述参数配置文件的参数含义由下面的<code>proto</code> 文件决定：</p><ul><li><code>modules/canbus/proto/canbus_conf.proto</code></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.canbus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/drivers/canbus/proto/can_card_parameter.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/canbus/proto/vehicle_parameter.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CanbusConf</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> VehicleParameter vehicle_parameter = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> apollo.drivers.canbus.CANCardParameter can_card_parameter = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> enable_debug_mode = <span class="number">3</span> [default = <span class="literal">false</span>];</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> enable_receiver_log = <span class="number">4</span> [default = <span class="literal">false</span>];</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> enable_sender_log = <span class="number">5</span> [default = <span class="literal">false</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p><code>modules/canbus/proto/vehicle_parameter.proto</code></p><p>该文件中定义了车辆的相关参数</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.canbus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/canbus/proto/chassis.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/common/configs/proto/vehicle_config.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">VehicleParameter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> apollo.common.VehicleBrand brand = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> max_engine_pedal = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> max_enable_fail_attempt = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">optional</span> Chassis.DrivingMode driving_mode = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细各文件内容此处略去不表，<code>VehicleBrand</code> 表示apollo支持的车辆品牌,目前有<code>LINCOLN_MKZ、GEM、LEXUS、TRANSIT、GE3、WEY、ZHONGYUN、CH</code></p><hr><ul><li><p><code>modules/drivers/canbus/proto/can_card_parameter.proto</code></p><p>该文件中定义了cancard的三个相关参数定义</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.drivers.canbus;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CANCardParameter</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">CANCardBrand</span> </span>&#123;</span><br><span class="line">    FAKE_CAN = <span class="number">0</span>;</span><br><span class="line">    ESD_CAN = <span class="number">1</span>;</span><br><span class="line">    SOCKET_CAN_RAW = <span class="number">2</span>;</span><br><span class="line">    HERMES_CAN = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">CANCardType</span> </span>&#123;</span><br><span class="line">    PCI_CARD = <span class="number">0</span>;</span><br><span class="line">    USB_CARD = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">CANChannelId</span> </span>&#123;</span><br><span class="line">    CHANNEL_ID_ZERO = <span class="number">0</span>;</span><br><span class="line">    CHANNEL_ID_ONE = <span class="number">1</span>;</span><br><span class="line">    CHANNEL_ID_TWO = <span class="number">2</span>;</span><br><span class="line">    CHANNEL_ID_THREE = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> CANCardBrand brand = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> CANCardType type = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> CANChannelId channel_id = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="信号交互">2.2 信号交互</h4><p>通常车企采用DBC文件完成CAN信号的定义和解析，Apollo则大量使用了Protobuf来进行模块间的通信和配置，因此车企需要通过Apollo提供的<a href="#jump">工具</a>基于DBC来生成Apollo可用<code>Proto</code>文件：以<u>广汽传祺GE3 开发者版</u> 为例</p><p><code>modules/canbus/proto/ge3.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.canbus;</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Ge3</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> Pc_bcm_201 pc_bcm_201 = <span class="number">1</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcs_3_308 scu_bcs_3_308 = <span class="number">2</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_epb_203 pc_epb_203 = <span class="number">3</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_bcs_202 pc_bcs_202 = <span class="number">4</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_vcu_205 pc_vcu_205 = <span class="number">5</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_eps_204 pc_eps_204 = <span class="number">6</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_vcu_2_313 scu_vcu_2_313 = <span class="number">7</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_1_301 scu_1_301 = <span class="number">8</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_2_302 scu_2_302 = <span class="number">9</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_3_303 scu_3_303 = <span class="number">10</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcm_304 scu_bcm_304 = <span class="number">11</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcs_1_306 scu_bcs_1_306 = <span class="number">12</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcs_2_307 scu_bcs_2_307 = <span class="number">13</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_epb_310 scu_epb_310 = <span class="number">14</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_vcu_1_312 scu_vcu_1_312 = <span class="number">15</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_eps_311 scu_eps_311 = <span class="number">16</span>; <span class="comment">// report message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="车辆配置">2.3 车辆配置</h4><p>Protobuf 提供了名为<code>TextFormat</code> 的序列化格式（该格式可读性强，类似于Json），配合事先定义的Proto文件，开发者可以轻易实现从可读的配置文件到具体对象的实力的反射，配置文件经过反序列化后可以作为业务代码类的输入，这种方式使得配置更加便捷，具有很好的向后兼容性。</p><p>Apollo 中大量采用了这种方式管理配置，Apollo激活车辆的配置文件为<code>modules/canbus/conf/canbus_conf.pb.txt</code> ,开发者可以再次定义车型以及对应的CAN card的参数，例如只需修改<code>vehicle_parameter</code> 相对应的字段，即可使Apollo支持相应的车型。</p><hr><h3 id="代码实现">3 代码实现</h3><h4 id="canbus模块">3.1 Canbus模块</h4><p>软件实现上，Apollo通过<code>CANBus</code> 模块来实现对车辆的管理和通讯。</p><p><code>CANBus</code> 模块接收并执行来自Contorl模块的指令，同时收集汽车底盘的状态（由Apollo抽象出的一组与车型无关的信号）。<code>CANBus</code> 模块处理这些状态与各个汽车底盘信号的映射关系，随后将这些状态反馈回<code>Control</code>模块，以此兼容不容车型。</p><figure><img src="/2020/02/08/can-conf/Apollo_3_5_software_architecture.png" alt="img"><figcaption>img</figcaption></figure><p><code>modules/canbus/proto/chassis.proto</code> 对Apollo抽象出的信号进行了定义，大体包括以下信息：</p><blockquote><p>DrivingMode: COMPLETE_MANUAL、COMPLETE_AUTO_DRIVE 、...</p><p>ErrorCode(错误码): 控制指令周期不准、底盘转向错误、人工接管</p><p>GearPosition(档位): 前进、后退、驻停等</p><p>底盘信息：车速、转速、油门、里程计</p><p>Gps</p><p>轮速</p></blockquote><p><code>CANBus</code> 模块主要由以下两个部件组成：</p><blockquote><p>Vehicle: the vehicle itself,including its controller and message manager</p><p>CAN Client: CAN client has been moved to <code>/modules/drivers/canbus</code> since it is shared by different sensors utilizing the canbus protocol <a href="https://github.com/ApolloAuto/apollo/tree/master/modules/canbus" target="_blank" rel="noopener" title="canbus">[4]</a></p></blockquote><p>针对<code>Vehicle</code>部分进行着重介绍： - <code>Vehicle</code>的Controller（<code>modules/cnabus/vehicle/vehicle_controller.h</code>）类图如下（简化）:</p><figure><img src="/2020/02/08/can-conf/vehiclecontroller.png" alt="vehicleController"><figcaption>vehicleController</figcaption></figure><p><code>Vehicle Controller</code> 类负责完成与汽车底盘的具体交互，以下为部分接口说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief start the vehicle controller. 注：干函数会在内部起一个名为”SecurityDogThread-Func“ 的线程</span></span><br><span class="line"><span class="comment"> * 该线程会周期性检查与底盘的通讯状况，关键信号是否相应，是否有错误等</span></span><br><span class="line"><span class="comment"> * @return true if successfully started.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Start</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief stop the vehicle controller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief calculate and return the chassis.</span></span><br><span class="line"><span class="comment"> * 注：该函数完成了汽车底盘信号和Apollo内部定义的底盘状态信号的映射</span></span><br><span class="line"><span class="comment"> * @returns a copy of chassis. Use copy here to avoid multi-thread issues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Chassis <span class="title">chassis</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief update the vehicle controller.</span></span><br><span class="line"><span class="comment"> * 该函数用于执行来自Control模块的具体指令，根据指令要求和汽车目前所处的模式(完全自动、完全手动等)来为执行器的信号(档位、油门、转向)进行赋值</span></span><br><span class="line"><span class="comment"> * @param command the control command</span></span><br><span class="line"><span class="comment"> * @return error_code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> common::ErrorCode <span class="title">Update</span><span class="params">(<span class="keyword">const</span> control::ControlCommand &amp;command)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>Vehicle的<code>MessageManger</code>类负责完成具体对信号的接收、发送、解析等。</p><p>其类图<code>modules/drivers/canbus/can_common/message_manager.h</code>如下</p><figure><img src="/2020/02/08/can-conf/messagemanager.png" alt="MessageManager Class"><figcaption>MessageManager Class</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于指定系统接收的信号</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SensorType&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">bool</span> <span class="title">need_check</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MessageManager</span>&lt;SensorType&gt;:</span>:AddRecvProtocolData() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于指定系统向汽车底盘发送的控制信号</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SensorType&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">bool</span> <span class="title">need_check</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MessageManager</span>&lt;SensorType&gt;:</span>:AddSendProtocolData() &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p>以<code>ge3</code> 车型为例，<code>ge3</code> 文件夹下包含如下文件：</p><figure><img src="/2020/02/08/can-conf/ge3file.png" alt="ge3-file"><figcaption>ge3-file</figcaption></figure><p>根据Apollo的官方文件<code>how_to_add_a_new_vehicle</code> 想为Apollo添加<code>ge3</code> 车型需要完成以下<a href="#newvehicle">内容</a>：</p><blockquote><ul><li><p>实现新的车辆控制器--<code>ge3_controller.cc</code>,继承<code>VehicleController</code> 类</p></li><li><p>实现新的消息管理器-- ge3_message_manager.cc ,继承<code>MessageManager</code> 类</p></li><li><p>实现新的车辆工厂类 -- ge3_vehicle_factory.cc ,继承<code>AbstractVehicleFactory</code> 类</p></li><li><p>更新配置文件</p><ul><li><p>在<code>modules/canbus/vehicle/vehicle_factory.cc</code> 中进行注册</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Register(apollo::common::GE3, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Ge3VehicleFactory();</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>更新配置文件<code>modules/canbus/conf/canbus_conf.pb.txt</code></p></li></ul></li></ul></blockquote></li></ul></li></ul><h4 id="canbus工厂模式">3.2 CANBus工厂模式</h4><p>通过上述方法能够增加新车型的原因在于Apollo的配置基于<code>工厂模型</code> （参见另一篇文章）实现的。</p><blockquote><p>工厂方法模式（Factory method pattern）是一种实现了“工厂”概念的<code>面向对象设计模式</code> 。就像其他<code>创建型模式</code>一样，它也是处理在不指定<code>对象</code>具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个<code>类</code> ”。工厂方法让类的实例化推迟到子类中进行。<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#cite_note-1(https://zh.wikipedia.org/wiki/工厂方法#cite_note-1)" target="_blank" rel="noopener">[5]</a></p></blockquote><p>CANBus模块中Vehicle相关的内容使用工厂模式抽象出了<code>VehicleController</code>,<code>MessageManager</code>,<code>AbstractVehicleFactory</code> 三个接口。CANBus的<strong>业务</strong>代码(<code>canbus_component.cc</code>) 通过以上接口来操纵具体的对象，用户无需关心具体的对象是什么，从而实现了业务逻辑和目标对象的解耦。</p><p>在Canbus模块中，工厂类为&quot;VehicleFactory&quot;,继承于工厂模板&quot;Factory&quot;。&quot;VehicleFactory&quot;工厂维护了键值对为“VehicleParameter::VechileBrand”和&quot;AbstractVehicleFactory&quot;的Map。</p><p>如下所示，每新注册注册一种车型，该Map中就会插入一条汽车品牌(VehicleBrand)和该品牌汽车生产工厂(AbstractVehicleFactory)的键值对。(ProductCreator 采用Lambda 表达式)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VehicleFactory::RegisterVehicleFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Register(apollo::common::LINCOLN_MKZ, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LincolnVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::GEM, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GemVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::LEXUS, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LexusVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::TRANSIT, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TransitVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::GE3, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ge3VehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::WEY, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeyVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::ZHONGYUN, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZhongyunVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::CH,</span><br><span class="line">           []() -&gt; AbstractVehicleFactory * &#123; <span class="keyword">return</span> <span class="keyword">new</span> ChVehicleFactory(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当VehicleFactory类的<code>CreateVehicle</code>方法被调用时，&quot;VehicleFactory&quot;会根据输入的汽车品牌，在Map中查找并返回可以生产这种汽车的工厂。</p><p>例如输入汽车品牌为<code>GE3</code> ，&quot;VehicleFactory&quot;会返回<code>Ge3VehicleFactory</code> ,<code>Ge3VehicleFactory</code>继承于<code>AbstractVehicleFactory</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Creates an AbstractVehicleFactory object based on vehicle_parameter</span></span><br><span class="line"><span class="comment"> * @param vehicle_parameter is defined in vehicle_parameter.proto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AbstractVehicleFactory&gt; <span class="title">CreateVehicle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> VehicleParameter &amp;vehicle_parameter)</span></span>;</span><br></pre></td></tr></table></figure><p><code>AbstractVehicleFactory</code> 工厂会产出一组适用于该品牌车型的产品即<code>MessageManager</code>和<code>Vehiclecontroller</code></p><p><code>modules/canbus/vehicle/ge3/ge3_vehicle_factory.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VehicleController&gt;</span><br><span class="line">Ge3VehicleFactory::CreateVehicleController() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VehicleController&gt;(<span class="keyword">new</span> ge3::Ge3Controller());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageManager&lt;::apollo::canbus::ChassisDetail&gt;&gt;</span><br><span class="line">Ge3VehicleFactory::CreateMessageManager() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageManager&lt;::apollo::canbus::ChassisDetail&gt;&gt;(</span><br><span class="line">      <span class="keyword">new</span> ge3::Ge3MessageManager());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ge3VehicleFactory</code> 最终会生产处一组适用于该品牌车型的产品，即<code>VehicleController</code> 和 <code>MessageManager</code></p><h3 id="canbus组件">4.Canbus组件</h3><p>​ 最后介绍CANBus模块的CanbusComponent，该类继承于<code>apollo::cyber::TimerComponent</code> ，主要作用是处理来自控制模块的控制指令，并将信号消息发送至CAN card。</p><p>​ CanbusComponent 的初始化函数（Init）主要完成以下工作：</p><ol type="1"><li><p>读取Canbus配置文件</p><p><code>modules/canbus/conf/canbusconf.pb.txt</code></p><p><code>modules/canbus/proto/canbus_conf.proto</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!GetProtoConfig(&amp;canbus_conf_)) &#123;</span><br><span class="line">  AERROR &lt;&lt; <span class="string">"Unable to load canbus conf file: "</span> &lt;&lt; ConfigFilePath();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据配置文件初始化<code>Can-client</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can_client_ = can_factory-&gt;CreateCANClient(canbus_conf_.can_card_parameter());</span><br></pre></td></tr></table></figure></li><li><p>根据配置文件获取汽车工厂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VehicleFactory vehicle_factory;</span><br><span class="line">  vehicle_factory.RegisterVehicleFactory();</span><br><span class="line">  <span class="keyword">auto</span> vehicle_object =</span><br><span class="line">      vehicle_factory.CreateVehicle(canbus_conf_.vehicle_parameter());</span><br></pre></td></tr></table></figure></li><li><p>获取该汽车工厂生产的<code>message_manager</code> 和 <code>Vehicle_controller</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message_manager_ = vehicle_object-&gt;CreateMessageManager();</span><br><span class="line"><span class="keyword">if</span> (can_receiver_.Init(can_client_.<span class="built_in">get</span>(), message_manager_.<span class="built_in">get</span>(),</span><br><span class="line">                         canbus_conf_.enable_receiver_log()) != ErrorCode::OK) &#123;...&#125;</span><br><span class="line"><span class="keyword">if</span> (can_sender_.Init(can_client_.<span class="built_in">get</span>(), canbus_conf_.enable_sender_log()) !=</span><br><span class="line">      ErrorCode::OK) &#123;...&#125;</span><br><span class="line">vehicle_controller_ = vehicle_object-&gt;CreateVehicleController();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>使能Can收发和<code>Vehicle_controller</code></p><p>初始化完成后，<code>CanbusComponent</code> 会周期性的报告车身状态，并执行来自<code>Control</code> 模块和<code>Guardian</code>模块的指令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanbusComponent::Proc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PublishChassis();</span><br><span class="line">  <span class="keyword">if</span> (FLAGS_enable_chassis_detail_pub) &#123;</span><br><span class="line">    PublishChassisDetail();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="comment">//周期性执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//事件触发，Reader回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanbusComponent::OnControlCommand</span><span class="params">(<span class="keyword">const</span> ControlCommand &amp;control_command)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanbusComponent::OnGuardianCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> GuardianCommand &amp;guardian_command)</span> </span>&#123;</span><br><span class="line">  apollo::control::ControlCommand control_command;</span><br><span class="line">  control_command.CopyFrom(guardian_command.control_command());</span><br><span class="line">  OnControlCommand(control_command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="参考链接">参考链接</h3><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener" title="protobuf 相关介绍">1</a> https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html protobuf 相关介绍</p><p><a href="https://zhuanlan.zhihu.com/p/61838008" target="_blank" rel="noopener" title="本文主要参考文章">2</a> https://zhuanlan.zhihu.com/p/61838008 本文主要参考文章</p><p><a href="http://apollo.auto/docs/procedure_cn.html" target="_blank" rel="noopener" title="针对车辆CAN DBC文件如何生成proto文件">3</a> http://apollo.auto/docs/procedure_cn.html 针对车辆CAN DBC文件如何生成proto文件</p><p><a href="https://github.com/ApolloAuto/apollo/tree/master/modules/canbus" target="_blank" rel="noopener" title="canbus">4</a> https://github.com/ApolloAuto/apollo/tree/master/modules/canbus &quot;canbus&quot;</p><p><a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#cite_note-1(https://zh.wikipedia.org/wiki/工厂方法#cite_note-1)" target="_blank" rel="noopener">5</a> https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#cite_note-1(https://zh.wikipedia.org/wiki/工厂方法#cite_note-1)</p><p>[6] https://zhuanlan.zhihu.com/p/61838008</p></blockquote><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人驾驶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo工厂模式解析</title>
      <link href="/2020/02/07/factory-mode/"/>
      <url>/2020/02/07/factory-mode/</url>
      
        <content type="html"><![CDATA[<p>apollo 中工厂模式相关知识介绍 <a id="more"></a></p><p>[TOC]</p><p>本文主要参考：<a href="https://blog.csdn.net/davidhopper/article/details/79197075" target="_blank" rel="noopener" class="uri">https://blog.csdn.net/davidhopper/article/details/79197075</a></p><p>工厂模式的定义和实现相关资料可参考：</p><blockquote><ul><li><a href="https://zh.wikipedia.org/wiki/工厂方法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95</a></li><li>《设计模式：可复用面向对象软件的基础》</li></ul></blockquote><h3 id="apollo-对象的创建方式">1. Apollo 对象的创建方式</h3><p>基本由 栈创建对象、堆创建对象、单例模式创建对象、工厂模式创建对象</p><p>Apollo项目中对象的创建，大多使用直接法，例如：</p><ul><li><p>//在栈(stack)上直接创建对象</p><p>ADCTrajectory not_ready_pb;</p></li><li><p>//在堆(heap)上直接创建对象</p><p>ZeroCopyOutputStream *output = new FileOutputStream(file_descriptor);</p></li></ul><blockquote><p>堆和栈的主要区别在于 <code>生命周期</code> 和 <code>性能</code> 由于栈的特性，栈上的对象不需要手动管理内存，而堆由程序员自行负责何时用delete释放内存，动态内存的生命周期由我们决定更加灵活。</p></blockquote><ul><li>还有部分通过<code>单例模式</code>创建：<code>DECLARE_SINGLETON(CanClientFactory)</code> ,其定义如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SINGLETON(classname)                                      \</span></span><br><span class="line"> <span class="keyword">public</span>:                                                                  \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> classname *<span class="title">Instance</span><span class="params">(<span class="keyword">bool</span> create_if_needed = <span class="literal">true</span>)</span> </span>&#123;              \</span><br><span class="line">    <span class="keyword">static</span> classname *instance = <span class="literal">nullptr</span>;                                 \</span><br><span class="line">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">std</span>::once_flag flag;                                         \</span><br><span class="line">      <span class="built_in">std</span>::call_once(flag,                                                \</span><br><span class="line">                     [&amp;] &#123; instance = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) classname(); &#125;); \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">    <span class="keyword">return</span> instance;                                                      \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CleanUp</span><span class="params">()</span> </span>&#123;                                                 \</span><br><span class="line">    <span class="keyword">auto</span> instance = Instance(<span class="literal">false</span>);                                      \</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">nullptr</span>) &#123;                                            \</span><br><span class="line">      CallShutdown(instance);                                             \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line"> <span class="keyword">private</span>:                                                                 \</span><br><span class="line">  classname();                                                            \</span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(classname)</span><br></pre></td></tr></table></figure><p>​ 其中内嵌宏 <code>DISALLOW_COPY_AND_ASSIGN(classname)</code>的定义如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line">  classname(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;    \</span><br><span class="line">  classname &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure> ​ 因此：<code>DECLARE_SINGLETON(CanClientFactory)</code> 展开后的定义为： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SINGLETON(CanClientFactory)                                      \</span></span><br><span class="line"> <span class="keyword">public</span>:                                                                  \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> CanClientFactory *<span class="title">Instance</span><span class="params">(<span class="keyword">bool</span> create_if_needed = <span class="literal">true</span>)</span> </span>&#123;              \</span><br><span class="line">    <span class="keyword">static</span> CanClientFactory *instance = <span class="literal">nullptr</span>;                                 \</span><br><span class="line">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">std</span>::once_flag flag;                                         \</span><br><span class="line">      <span class="built_in">std</span>::call_once(flag,                                                \</span><br><span class="line">                     [&amp;] &#123; instance = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) CanClientFactory(); &#125;); \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">    <span class="keyword">return</span> instance;                                                      \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CleanUp</span><span class="params">()</span> </span>&#123;                                                 \</span><br><span class="line">    <span class="keyword">auto</span> instance = Instance(<span class="literal">false</span>);                                      \</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">nullptr</span>) &#123;                                            \</span><br><span class="line">      CallShutdown(instance);                                             \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line"> <span class="keyword">private</span>:                                                                 \</span><br><span class="line">  CanClientFactory();                                                            \</span><br><span class="line">  CanClientFactory(<span class="keyword">const</span> CanClientFactory &amp;) = <span class="keyword">delete</span>;    \</span><br><span class="line">  CanClientFactory &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CanClientFactory &amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></p><p>​ 上述代码的意义，首先定义一个静态公有函数Instance(),该函数在栈上创建一个<code>CanClientFactory</code> 类的静态对象，然后返回该对象指针。同时，将<code>CanClientFactory</code> 类的默认构造函数、复制（或称拷贝）构造函数、复制赋值运算符（或称操作符）定义为私有（private）函数，即禁止进行隐式类型转换和复制操作。<strong>单例模式保证一个类只有一个实例，并提供一个访问它的全局访问点，即通过静态指针来指向此唯一实例</strong></p><blockquote><p>c++中的static关键词可以用于修改局部变量，函数，类的数据成员以及对象。</p><p>​ 静态局部变量只初始化一次，然后每次函数调用时保持其值。</p><p>​ 静态成员函数可以直接用类来调用，不需要创建实例来调用。</p><p>静态对象：<code>static Test t1；</code></p><p>​ 静态对象只初始化一次，并且在整个程序的生命周期中都存在，静态对象保存在静态存储区，在程序结束时销毁。</p></blockquote><ul><li><p>还有部分对象通过工厂模式创建对象，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class VehicleFactory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief This class is a factory class that will generate different</span></span><br><span class="line"><span class="comment"> * vehicle factories based on the vehicle brand.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> common::util::Factory&lt;apollo::common::VehicleBrand,</span><br><span class="line">                                   AbstractVehicleFactory&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief register supported vehicle factories.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RegisterVehicleFactory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Creates an AbstractVehicleFactory object based on vehicle_parameter</span></span><br><span class="line"><span class="comment">   * @param vehicle_parameter is defined in vehicle_parameter.proto</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AbstractVehicleFactory&gt; <span class="title">CreateVehicle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> VehicleParameter &amp;vehicle_parameter)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于工厂模式的介绍，可以参考：下面简单介绍</p><p>[https://blog.csdn.net/linwh8/article/details/51232834][https://blog.csdn.net/linwh8/article/details/51232834]</p><p>[https://www.runoob.com/design-pattern/abstract-factory-pattern.html][https://www.runoob.com/design-pattern/abstract-factory-pattern.html]</p></li></ul><h3 id="浅谈工厂模式">2. 浅谈工厂模式</h3><p><img src="/2020/02/07/factory-mode/factorymode.png"></p><p>首先<code>ProductFactory</code>可以想象为生产某种产品（抽象类产品）的某类工厂（抽象类工厂），此抽象类工厂演变出许多实例化对象，即为实际的工厂（工厂实例化对象）：<code>ConcreteProductFactoryA,ConcreteProductFactoryB</code> ,而这两个<strong>实例化工厂</strong>生产的内容与抽象工厂定义的内容一致，即包含一个抽象类product。</p><p>然后<code>Product</code>某种产品（抽象类产品），它能演变出许多实例化对象:<code>ConcreteProductA,ConcreteProductB</code> ,也就是上面的实例化工厂都能生产A、B两种产品。</p><p>举个栗子：</p><p>现在由生产口罩的工厂（抽象类工厂）：工厂A(工厂实例化对象)，工厂B(工厂实例化对象)。这两个工厂都生产口罩（抽象类产品）：KN95口罩（产品实例化对象）、一次性医用口罩(产品实例化对象)。</p><h3 id="apollo项目工厂模式分析">3.Apollo项目工厂模式分析</h3><p>​ Apollo采用的是抽象工厂模式，因为该项目使用模板定义工厂类，因此工厂模式经典定义中的抽象工厂类不再需要，Apollo提供了一个工厂模板(<code>modules/common/util/factory.h</code>) ,该模板可支持任何类型的输入，类图如下：</p><p><img src="/2020/02/07/factory-mode/ApolloFactory.png"></p><blockquote><p>Factory类中包含了<code>Register()</code>、<code>Unregister()</code> 、<code>Empty()</code>、<code>CreateObjectOrNull()</code>、<code>CreateObject()</code> 等公有函数，其中<code>Register()</code> 、<code>Unregister()</code>函数用于注册和反注册产品类，其作用与经典模式中抽象工厂接口类的功能类似，<code>Empty()</code> 函数用于判断当前工厂类中是否包含产品创建函数，<code>CreateObjectOrNull()</code>、<code>CreateObject()</code> 函数用于创建可能包含空指针和不包含空指针的产品类对象。</p></blockquote><p>​ Factory工厂模板维护了一个Map用来管理<code>IdentifierType</code>和<code>ProductCreator</code>的键值对，根据输入的<code>IdentifierType</code>,模板可以返回<code>ProductCreator</code>生产的产品，从而实现了从<code>IdentifierType</code>到<code>Productde</code> &quot;映射&quot;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IdentifierType, <span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">ProductCreator</span> = <span class="title">AbstractProduct</span> *(*)(),</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">MapContainer</span> = <span class="title">std</span>:</span>:<span class="built_in">map</span>&lt;IdentifierType, ProductCreator&gt;&gt;</span><br></pre></td></tr></table></figure><p>Factory类模板中参数<code>ProductCreator=AbstractProduct*（*）()</code> 全部采用简洁的Lambda表达式实现</p><blockquote><p>lambda 表达式：</p><p>完整格式声明：<code>[capture list] (params list) mutable exception-&gt; return type { function body }</code></p><p>capture list:捕获外部变量列表 params list:形参列表 exception:异常设定（一般省略）</p></blockquote><p>Apollo项目中对Factory类实例化的情形包括但不限于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> common::util::Factory&lt;apollo::common::VehicleBrand,</span><br><span class="line">                                   AbstractVehicleFactory&gt;&#123;<span class="comment">/*.../*&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanClientFactory</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> apollo::common::util::Factory&lt;CANCardParameter::CANCardBrand,</span><br><span class="line">                                           CanClient&gt; &#123;<span class="comment">/*.../*&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apollo::common::util::Factory&lt;TaskConfig::TaskType, NaviTask&gt; task_factory_;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common::util::Factory&lt;PlannerType, Planner&gt; planner_factory_</span><br></pre></td></tr></table></figure><p>注册产品类代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NaviPlanner::RegisterTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  task_factory_.Register(TaskConfig::NAVI_PATH_DECIDER,</span><br><span class="line">                         []() -&gt; NaviTask* &#123; <span class="keyword">return</span> <span class="keyword">new</span> NaviPathDecider(); &#125;);</span><br><span class="line">  task_factory_.Register(TaskConfig::NAVI_SPEED_DECIDER,</span><br><span class="line">                         []() -&gt; NaviTask* &#123; <span class="keyword">return</span> <span class="keyword">new</span> NaviSpeedDecider(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的产品创建函数<code>ProductCreator=AbstractProduct*（*）()</code> 采用Lambda表达式实现。</p><p>创建具体的产品类对象的代码为:</p><p><code>modules/planning/planner/navi/navi_planner.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NaviPlanner::Init</span><span class="params">(<span class="keyword">const</span> PlanningConfig&amp; <span class="built_in">config</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// NaviPlanner is only used in navigation mode based on the real-time relative</span></span><br><span class="line">  <span class="comment">// map.</span></span><br><span class="line">  <span class="keyword">if</span> (!FLAGS_use_navigation_mode) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">"NaviPlanner is only used in navigation mode."</span>;</span><br><span class="line">    AERROR &lt;&lt; msg;</span><br><span class="line">    <span class="keyword">return</span> Status(ErrorCode::PLANNING_ERROR, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AINFO &lt;&lt; <span class="string">"In NaviPlanner::Init()"</span>;</span><br><span class="line">  RegisterTasks();</span><br><span class="line">  PlannerNaviConfig planner_conf =</span><br><span class="line">      <span class="built_in">config</span>.navigation_planning_config().planner_navi_config();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> task : planner_conf.task()) &#123;</span><br><span class="line">    tasks_.emplace_back(</span><br><span class="line">        task_factory_.CreateObject(<span class="keyword">static_cast</span>&lt;TaskConfig::TaskType&gt;(task)));</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Created task:"</span> &lt;&lt; tasks_.back()-&gt;Name();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; task : tasks_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!task-&gt;Init(<span class="built_in">config</span>)) &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">msg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          common::util::StrCat(<span class="string">"Init task["</span>, task-&gt;Name(), <span class="string">"] failed."</span>))</span></span>;</span><br><span class="line">      AERROR &lt;&lt; msg;</span><br><span class="line">      <span class="keyword">return</span> Status(ErrorCode::PLANNING_ERROR, msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件为：<code>modules/planning/conf/planning_config_navi.pb.txt</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">planner_type : NAVI</span><br><span class="line">planner_navi_config &#123;</span><br><span class="line">  task : NAVI_PATH_DECIDER</span><br><span class="line">  task : NAVI_SPEED_DECIDER</span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>上述配置文件表明，<code>NaviPlanner</code>类动态生成了<code>NAVI_PATH_DECIDER</code> 、<code>NAVI_SPEED_DECIDER</code> 任务对象。</p>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo InternalProc 感知处理流程</title>
      <link href="/2020/02/07/Apollo-IntenalProc/"/>
      <url>/2020/02/07/Apollo-IntenalProc/</url>
      
        <content type="html"><![CDATA[<p>Apollo 总体感知算法处理流程</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> 感知 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo回调函数概览</title>
      <link href="/2020/02/06/OnReceiveImages/"/>
      <url>/2020/02/06/OnReceiveImages/</url>
      
        <content type="html"><![CDATA[<h3 id="一onreceiveimages内部函数处理流程">一、OnReceiveImages()内部函数处理流程:</h3><a id="more"></a><ol type="1"><li>由FusionCameraDetectionComponent::Init()中的InitCameraListeners()创建回调函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FusionCameraDetectionComponent::OnReceiveImage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image&gt; &amp;message,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;camera_name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>函数参数说明：</p><blockquote><p>apollo::drivers::Image类包含：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> frame_id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> measurement_time = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> height = <span class="number">4</span>;  <span class="comment">// image height, that is, number of rows</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> width = <span class="number">5</span>;   <span class="comment">// image width, that is, number of columns</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> encoding = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> step = <span class="number">7</span>;  <span class="comment">// Full row length in bytes</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bytes</span> data = <span class="number">8</span>;   <span class="comment">// actual matrix data, size is (step * rows)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该消息类型文件定义：<code>modules/drivers/proto/sensor_image.proto</code></p></blockquote><blockquote><p><code>std::string &amp;camera_name</code> 包含两类：</p><ul><li>front_6mm</li><li>front_12mm</li></ul></blockquote><ol start="2" type="1"><li>进行TimeStamp的判断之后：</li></ol><ul><li><p>创建<code>apollo::perception::PerceptionObstacles</code> 对象<em><code>out_message</code></em></p><blockquote><p>类定义位于modules/perception/proto/perception_obstacle.proto</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PerceptionObstacles</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> PerceptionObstacle perception_obstacle = <span class="number">1</span>;  <span class="comment">// An array of obstacles</span></span><br><span class="line">  <span class="keyword">optional</span> common.Header header = <span class="number">2</span>;                    <span class="comment">// Header</span></span><br><span class="line">  <span class="keyword">optional</span> common.ErrorCode error_code = <span class="number">3</span> [default = OK];</span><br><span class="line">  <span class="keyword">optional</span> LaneMarkers lane_marker = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">optional</span> CIPVInfo cipv_info = <span class="number">5</span>;  <span class="comment">// Closest In Path Vehicle (CIPV)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>创建<code>SensorFrameMessage</code> 类对象<em><code>prefused_message</code></em></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorFrameMessage</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SensorFrameMessage() &#123; type_name_ = <span class="string">"SensorFrameMessage"</span>; &#125;</span><br><span class="line">  ~SensorFrameMessage() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetTypeName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> type_name_; &#125;</span><br><span class="line">  <span class="function">SensorFrameMessage* <span class="title">New</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SensorFrameMessage; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  apollo::common::ErrorCode error_code_ = apollo::common::ErrorCode::OK;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> sensor_id_;</span><br><span class="line">  <span class="keyword">double</span> timestamp_ = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> seq_num_ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> type_name_;</span><br><span class="line">  base::HdmapStructConstPtr hdmap_;</span><br><span class="line"></span><br><span class="line">  base::FramePtr frame_;</span><br><span class="line"></span><br><span class="line">  ProcessStage process_stage_ = ProcessStage::UNKNOWN_STAGE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote></li></ul><ol start="3" type="1"><li>调用函数<code>IntenalProc(message,camera_name,&amp;error_code,prefused_message.get(),out_message.get())</code></li></ol><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FusionCameraDetectionComponent::InternalProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image <span class="keyword">const</span>&gt; &amp;in_message,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;camera_name, apollo::common::ErrorCode *error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">SensorFrameMessage *prefused_message,</span></span></span><br><span class="line"><span class="function"><span class="params">apollo::perception::PerceptionObstacles *out_message)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实现对接收到图像信息的处理，程序前部分实现对<code>prefused_message</code> 和 <code>camera_frame</code>相关数据与参数的赋值，获取相机到世界坐标系的仿射矩阵</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera2world_trans_wrapper_map_[camera_name]-&gt;GetSensor2worldTrans(...);</span><br></pre></td></tr></table></figure><p>填充图像数据,其中数据来自OnreceiveMessage接收到的消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">camera_frame.data_provider-&gt;FillImageData(</span><br><span class="line">    image_height_, image_width_,</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span> *&gt;(in_message-&gt;data().data()),</span><br><span class="line">    in_message-&gt;encoding())</span><br></pre></td></tr></table></figure><p>有了数据之后，科技进行算法处理了，运行<code>camera_obstacle_pipelin_-&gt;Perception(&amp;camera_frame)</code> ,实现主要图像算法处理。</p><ul><li><code>Perception</code>中主要的处理函数如下</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObstacleCameraPerception::Perception</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> CameraPerceptionOptions &amp;options, CameraFrame *frame)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//lane detector and postprocessor</span></span><br><span class="line">        lane_detector_-&gt;Detect(lane_detetor_options, frame)</span><br><span class="line">        ...</span><br><span class="line">        lane_postprocessor_-&gt;Process2D(lane_postprocessor_options, frame)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//Calibration service</span></span><br><span class="line">        frame-&gt;calibration_service-&gt;Update(frame);</span><br><span class="line">    ...</span><br><span class="line">        lane_postprocessor_-&gt;Process3D(lane_postprocessor_options, frame)</span><br><span class="line">        ...</span><br><span class="line">        WriteLanelines(write_out_lane_file_, lane_file_path, frame-&gt;lane_objects)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Obstacle prediction</span></span><br><span class="line">    tracker_-&gt;Predict(tracker_options, frame)      </span><br><span class="line">    <span class="comment">// detect :detector 根据provider名称建立</span></span><br><span class="line">    detector-&gt;Detect(detector_options, frame)</span><br><span class="line">    WriteDetections(...)<span class="comment">//write all detections results as kitti format</span></span><br><span class="line">    <span class="comment">//extarctor</span></span><br><span class="line">    extractor_-&gt;Extract(extractor_options, frame)</span><br><span class="line">    <span class="comment">//tracker Associate2D</span></span><br><span class="line">    tracker_-&gt;Associate2D(tracker_options, frame)</span><br><span class="line">    <span class="comment">//Transform</span></span><br><span class="line">    transformer_-&gt;Transform(transformer_options, frame)</span><br><span class="line">    <span class="comment">//Obstacle postprocessor</span></span><br><span class="line">    obstacle_postprocessor_-&gt;<span class="built_in">Process</span>(obstacle_postprocessor_options,</span><br><span class="line">                                        frame)</span><br><span class="line">    <span class="comment">//tracker Associate3D</span></span><br><span class="line">    tracker_-&gt;Associate3D(tracker_options, frame)</span><br><span class="line">    <span class="comment">//track</span></span><br><span class="line">    tracker_-&gt;Track(tracker_options, frame)</span><br><span class="line">    <span class="comment">//save tracked detections results as kitti format</span></span><br><span class="line">    WriteDetections(tracked_detection_out_dir,frame-&gt;tracked_objectes);</span><br><span class="line">    <span class="comment">//填充多边形并设置锚点</span></span><br><span class="line">    FillObjectPloygonFromBBox3D(tracked_object)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><ol start="4" type="1"><li><p>make protobuf message</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MakeProtobufMsg(msg_timestamp, seq_num_, camera_frame.tracked_objects,</span><br><span class="line">                      camera_frame.lane_objects, *error_code,</span><br><span class="line">                      out_message)</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FusionCameraDetectionComponent::MakeProtobufMsg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> msg_timestamp, <span class="keyword">int</span> seq_num,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt; &amp;objects,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::LaneLine&gt; &amp;lane_objects,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> apollo::common::ErrorCode error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">    apollo::perception::PerceptionObstacles *obstacles)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Determine CIPV</p></li></ol><h3 id="二detector-and-tracker">二、detector and tracker</h3><p>​ 目前发表的相关检测跟踪的算法(ResNet,YOLO等)主要面向广泛的计算机视觉的应用，与自动驾驶领域中的检测和跟踪还是存在一定的区别的，由于汽车行驶在结构化、规则化的道路上，面向的场景更为具体，有很多的几何约束可以用于检测；其次，自动驾驶中的检测模型需要输出的信息更多，包括了障碍物的尺寸、朝向、速度等信息，然而如果以上任务都分别由专用的模块进行处理，则对系统负担较大，处理流程太长，因此还需要做<strong>多任务学习</strong>和网络结构的适配。</p><p>​ 一个完整的系统除了深度学习模型，还需要做一些后处理，后处理模块针对下游模块，对后续的影响比较直接。在视觉感知中，后处理主要分为三个部分：</p><p>​ 第一是2D-3D的几何计算，2D到3D的转换需要考虑的因素包括:</p><blockquote><ul><li>相机pose 的影响</li><li>接地点</li><li>稳定性</li></ul></blockquote><p>​ 第二是时序信息计算，主要针对跟踪处理，需要注意以下几点：</p><blockquote><ul><li>对相机帧率和延时有要求，要求跟踪必须是一个轻量级的模块，因为检测已经占据了大部分时间</li><li>充分利用检测模型的输出信息（特征、类别等）进行跟踪</li><li>可以考虑轻量级Metric Learning</li></ul></blockquote><p>​ 第三是多相机的环视融合</p><blockquote><ul><li>相机布局决定融合策略，要做好视野重叠</li></ul></blockquote><p>​ 检测——&gt;2D to 3D转换 ——&gt;跟踪——&gt;位置、速度</p><p>​ HM目标跟踪器的主要功能是跟踪分割步骤检测到的障碍物。通常，它通过将当前检测结果与现有跟踪列表相关联的方式，形成和更新跟踪列表。如果原来的目标都不在出现则删除旧跟踪列表，在确认新的检测结果之后会生成新的跟踪列表。</p><p>​ 关联之后，将会估计更新后的跟踪列表的运动状态。HM目标跟踪器使用Hungarian算法（匈牙利算法）对检测和跟踪(detection-to-track)进行关联，使用Robust Kalman Filter（鲁棒卡尔曼滤波）进行运动估计。</p><ul><li><p>检测到跟踪关联</p><p>将检测与现有的跟踪列表进行关联时，Apollo构建了一个二分图并使用Hungarian算法对检测和跟踪(detection-to-track)进行关联，使用<code>Robust Kalman Filter</code> (鲁棒卡尔曼滤波器)进行运动估计。</p></li><li><p>计算关联距离矩阵</p><p>首先建立一个关联距离矩阵。一个给定的检测和跟踪之间的距离可以通过一系列关联属性进行计算，这些关联属性包括运动一致性和外观一致性。<code>HM</code> 跟踪器中距离计算中使用的一些属性如下所示：</p><p>​</p><table><thead><tr class="header"><th>关联属性名称</th><th>评估一致性的说明</th></tr></thead><tbody><tr class="odd"><td>location_distance</td><td>运动</td></tr><tr class="even"><td>direction_distance</td><td>运动</td></tr><tr class="odd"><td>bbox_size_distance</td><td>外观</td></tr><tr class="even"><td>point_num_distance</td><td>外观</td></tr><tr class="odd"><td>histogram_distance</td><td>外观</td></tr></tbody></table></li></ul><p><strong>(1)tracker-&gt;Predict()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OMTObstacleTracker::Predict</span><span class="params">(<span class="keyword">const</span> ObstacleTrackerOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 CameraFrame *frame)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;target : targets_) &#123;</span><br><span class="line">    target.Predict(frame);</span><br><span class="line">    <span class="keyword">auto</span> obj = target.latest_object;</span><br><span class="line">    frame-&gt;proposed_objects.push_back(obj-&gt;object);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对跟踪列表中的每一个target通过kalman相关模型进行预测，获得新图像中的候选障碍物目标添加到<code>frame-&gt;proposed_objects</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Target::Predict</span><span class="params">(CameraFrame *frame)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">delta_t</span> =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(frame-&gt;timestamp - latest_object-&gt;timestamp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">delta_t</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  image_center.Predict(<span class="keyword">delta_t</span>);</span><br><span class="line">  <span class="keyword">float</span> acc_variance = target_param_.world_center().process_variance();</span><br><span class="line">  <span class="keyword">float</span> delta_t_2 = <span class="keyword">delta_t</span> * <span class="keyword">delta_t</span>;</span><br><span class="line">  <span class="keyword">float</span> pos_variance = <span class="number">0.25f</span> * acc_variance * delta_t_2 * delta_t_2;</span><br><span class="line">  <span class="keyword">float</span> vel_variance = acc_variance * delta_t_2;</span><br><span class="line">  world_center.process_noise_(<span class="number">0</span>, <span class="number">0</span>) = pos_variance;</span><br><span class="line">  world_center.process_noise_(<span class="number">1</span>, <span class="number">1</span>) = pos_variance;</span><br><span class="line">  world_center.process_noise_(<span class="number">2</span>, <span class="number">2</span>) = vel_variance;</span><br><span class="line">  world_center.process_noise_(<span class="number">3</span>, <span class="number">3</span>) = vel_variance;</span><br><span class="line">  world_center.Predict(<span class="keyword">delta_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const position kalman predict</span></span><br><span class="line">  world_center_const.process_noise_.setIdentity();</span><br><span class="line">  world_center_const.process_noise_(<span class="number">0</span>, <span class="number">0</span>) = vel_variance * delta_t_2;</span><br><span class="line">  world_center_const.process_noise_(<span class="number">1</span>, <span class="number">1</span>) =</span><br><span class="line">      world_center_const.process_noise_(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  world_center_const.Predict(<span class="keyword">delta_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) detector-&gt;Detect</strong> 根据图像信息(frame)检测障碍物,接口定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: detect obstacle from image.</span></span><br><span class="line"><span class="comment">// @param [in]: options</span></span><br><span class="line"><span class="comment">// @param [in/out]: frame</span></span><br><span class="line"><span class="comment">// obstacle type and 2D bbox should be filled, required,</span></span><br><span class="line"><span class="comment">// 3D information of obstacle can be filled, optional.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Detect</span><span class="params">(<span class="keyword">const</span> ObstacleDetectorOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">                    CameraFrame *frame)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>其中主要进行前向推理过程(inference),apollo支持的推理框架由<code>Inference</code>这个协议类确定，并通过&quot;inference_factory&quot;进行对象创建，目前支持：<code>CaffeNet</code>、<code>RTNet</code>、<code>RTNetInt8</code>、<code>PaddleNet</code>这几种类型的模型结构。</p><blockquote><p>RTNet是TensorRT框架生成的模型，TensorRT是高性能的深度学习<strong>推理</strong>优化器，将跨平台的&quot;Tensorflow,caffe,MxNet,Pytorch&quot;等深度学习框架训练好的模型解析后进行统一的部署。</p></blockquote><p>主要检测部分的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_objects_gpu(yolo_blobs_, stream_, types_, nms_, yolo_param_.model_param(),</span><br><span class="line">                  light_vis_conf_threshold_, light_swt_conf_threshold_,</span><br><span class="line">                  overlapped_.<span class="built_in">get</span>(), idx_sm_.<span class="built_in">get</span>(), &amp;(frame-&gt;detected_objects));</span><br></pre></td></tr></table></figure><p>其实现位于<code>region_output.cu</code>中,最终检测检测结果添加到<code>frame-&gt;detected_objects</code>,各输入参数含义如下。</p><p><code>yolo_blobs_</code>:为yolo前向推断模型结构，blob为一个封装了<code>SyncedMemory</code>的包装器，作为图像，特征图的基本计算单元 <code>stream_</code>:由cudaStream_t定义cuda中的流，可以实现一个设备上同时运行多个核函数。 <code>types_</code>:为检测的目标类型; <code>nms_</code>: 为nms的相关参数 ; <code>yolo_param_.model_param()</code>:模型的相关参数(一些阈值) <code>light_vis_conf_threshold_</code>和<code>light_swt_conf_threshold_</code>: vis指visible,swt指swtich 值得是车灯检测的相关阈值</p><blockquote><p>cuda-c (后缀名<code>.cu</code>)方便我们利用GPU并行处理来加速程序的运行速度</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> 感知 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slam初探</title>
      <link href="/2020/02/04/slam1/"/>
      <url>/2020/02/04/slam1/</url>
      
        <content type="html"><![CDATA[<img src="/2020/02/04/slam1/slam.png"><center>图1. slam 流程图</center>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客破壳日</title>
      <link href="/2020/02/04/hello-world/"/>
      <url>/2020/02/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>博客配置完工啦！今天是博客的破壳日o(￣ヘ￣o#) 2020 fighting!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最优估计 -- kalman and lsm</title>
      <link href="/2020/02/04/kalman_filter_and_lsm/"/>
      <url>/2020/02/04/kalman_filter_and_lsm/</url>
      
        <content type="html"><![CDATA[<p>kalman Filter 和 least square 目的均为最优化某一指标，指标是优化的关键：</p><a id="more"></a><p>[TOC]</p><p>常用的估计准则有：</p><ul><li><p>无偏估计：估计值的期望等于被估计参数的真实值。</p></li><li><p>线性最小方差估计：将估计量限制为观测值的线性函数，已知观测量Z和和被估计量X一二阶矩（EX,Var{X},EZ,Var{Z},Cov{X,Z}）,使估计误差的方差最小，即最小化<span class="math inline">\(tr\{E[\tilde{X}-E\tilde{X}][\tilde{X}-E\tilde{X}]^{T}\}\)</span> ,<span class="math inline">\(\tilde{X}\)</span>为估计误差（等价于最小化均方误差阵，若为无偏估计）可得其无偏估计值为<span class="math inline">\(\tilde{X}_{LMV}(Z)=EX+cov(X,Z)(var(Z))^{-1}[Z-EZ]\)</span>对于观测模型Z=HX+V，上述条件若已知</p><p><span class="math inline">\(\{EX=\mu_x,Var(X)=P_x,EV=0,Var(V)=R,E(XV^T)=0\}\)</span> 即可得到。</p></li><li><p>最小二乘估计：对数据（X、Z）的统计特性一无所知，但仍需对X进行估计，目标是最小化残差<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>平方和。</p><p>满足最小方差必满足残差平方和最小，反之则不成立。</p></li></ul><h4 id="经典最小二乘">1.经典最小二乘</h4><p>针对隐状态X，若其无法直接观测，但间接获取其观测值<span class="math inline">\(Z=[z_1,z_2,\dots,z_n]^T\)</span> ,若其观测值为状态值的线性函数： <span class="math display">\[Z_i=H_iX+V_i,i=1,\dots,n\]</span> <span class="math inline">\(z_i\)</span>为第i次测量的观测值，<span class="math inline">\(H_i\)</span>为第i次测量的观测模型(设计矩阵，实验的观测值)，<span class="math inline">\(V_i\)</span>为第i次测量的噪声（误差）。</p><p>则第i次测量的估计误差： <span class="math display">\[\hat{e_i}=z_i-H_i\hat{X}\]</span> 则n次测量的误差（残差）平方和为优化指标： <span class="math display">\[J(\hat{X})=\sum_{i=1}^{n}{(z_i-H_i\hat{X})^2}=(Z-H\hat{X})^T(Z-H\hat{X}) \\=tr[(Z-H\hat{X})(Z-H\hat{X})^T]\]</span> 令<span class="math inline">\(\frac{\partial{J}}{\partial{\hat{X}}}=0\)</span> ,可得最小二乘估计值： <span class="math display">\[\hat{X}_{LS}=(H^TH)^{-1}H^TZ\]</span> 将<span class="math inline">\(Z=HX+V\)</span>此时状态的估计误差： <span class="math display">\[\tilde{X}_{LS}=X-\hat{X}_{LS}=-(H^TH)^{-1}H^TV\]</span> 若测量噪声均值为0，则<span class="math inline">\(E(\tilde{X}_{LS})=0\)</span>,此时最小二乘估计为<strong><u>无偏估计</u></strong>，<strong>状态估计误差的（协）方差[^ 2] <span class="math inline">\(Var(\tilde{X}_{LS})=E[(\tilde{X}-E\tilde{X})(\tilde{X}-E\tilde{X})^T]\)</span>与估计量的均方误差矩阵<span class="math inline">\(E[X-\hat{X}][X-\hat{X}]^T\)</span>相等</strong>。可见标准最小二乘不需要噪声V的任何统计信息。</p><p>由(5)式可得： <span class="math display">\[\begin{align}Var(\tilde{X}_{LS})=E[X-\hat{X}][X-\hat{X}]^T &amp; = (H^TH)^{-1}H^TE(VV^T)H(H^TH)^{-1}\\&amp;=(H^TH)^{-1}H^TRH(H^TH)^{-1}\end{align}\]</span> 其中<span class="math inline">\(R=E(VV^T)\)</span>为测量误差（噪声）的（协）方差阵。</p><h4 id="加权最小二乘weighted-least-square">加权最小二乘（weighted least square）</h4><p>在经典最小二乘中，假定每一次测量的权重相同，但是一般来说近期数据比远期数据影响更大，因此引入加权最小二乘，其指标形式： <span class="math display">\[J_W(\hat{X})=\sum_{i=1}^{n}{(z_i-H_i\hat{X})^2}=(Z-H\hat{X})^TW(Z-H\hat{X})\]</span> 同样使其偏导数为0,可得 <span class="math display">\[\hat{X}_{LSW}=(H^TWH)^{-1}H^TWZ\]</span></p><hr><p>由附录<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>,若噪声不满足同方差，则普通最小二乘(4)并不是BLUE，此时噪声的协方差阵</p><p><span class="math inline">\(E[VV^T]=\sigma^2R,R\neq{I}\)</span> ,<span class="math inline">\(R=\begin{bmatrix}r_1\\&amp;\ddots\\&amp;&amp; r_n\end{bmatrix}\)</span>,即原模型存在异方差性。</p><p>设<span class="math inline">\(R=DD^T,D=\begin{bmatrix}\sqrt{r_1}\\&amp;\ddots\\&amp;&amp; \sqrt{r_n}\end{bmatrix}\)</span> ,用<span class="math inline">\(D^{-1}\)</span>同时左乘<span class="math inline">\(Z=HX+V\)</span>两端得到新的模型： <span class="math display">\[\begin{align}D^{-1}Z&amp;=D^{-1}HX+D^{-1}V \\Z^{\star}&amp;=H^{\star}X+V^{\star}\end{align}\]</span> 此时,原模型的加权最小二乘估计量为无偏的。 <span class="math display">\[\begin{align}E[V^{\star}V^{\star T}]&amp;=E[D^{-1}VV^TD^{-1\ T}]\\&amp;=D^{-1}E[VV^T]D^{-1\ T}\\&amp;=\sigma^2D^{-1}RD^{-1\ T}\\&amp;=\sigma^2I\end{align}\]</span> 此时得到的参数估计为： <span class="math display">\[\begin{align}\hat{X}_{LSW}&amp;=(H^{\star T}H^{\star})^{-1}H^{\star T}Z^{\star}\\&amp;=(H^TR^{-1}H)^{-1}H^TR^{-1}Z\end{align}\]</span> 可以证明（见附录），当<span class="math inline">\(W=R^{-1}\)</span>时，最小二乘估计时缺少初值条件下的<strong><u>线性无偏最小方差估计</u></strong>（BLUE,Best Linear Unbiased Estimation）——即能够使估计误差的方差阵最小，又称马尔可夫估计,其中 <span class="math display">\[R=E[VV^T]\]</span> 为随机噪声的（协）方差阵（对称正定阵）。</p><h4 id="递推最小二乘recursive-least-squarerls">2.递推最小二乘（Recursive Least Square,RLS）</h4><p>上述方法进行一次估计需要所有历史数据，不利于在线估计，考虑前n次测量： <span class="math display">\[Z_n=H_nX+V_n\]</span> 则加权的最小二乘估计为： <span class="math display">\[\hat{X}_{LSW}(n)=(H_{n}^TR_{n}^{-1}H_n)^{-1}H_{n}^TR_{n}^{-1}Z_n\]</span> 估计误差的（协）方差矩阵为： <span class="math display">\[\begin{align}P_n&amp;=E[\tilde{X}_{LSW}(n)\tilde{X}_{LSW}^T(n)]\\&amp;=E[-(H^TR^{-1}H)^{-1}]H^TR^{-1}VV^TR^{-1}H(H^TR^{-1}H)^{-1}\\&amp;=(H^TR^{-1}H)^{-1}H^TR^{-1}H(H^TR^{-1}H)^{-1}\\&amp;=(H^TR^{-1}H)^{-1}\end{align}\]</span> 结合上述两式，可得： <span class="math display">\[\hat{X}_{LSW}(n)=P_nH_{n}^TR_{n}^{-1}Z_n\]</span> 现得到一个新的测量值： <span class="math display">\[z_{n+1}=H_{n+1}X+v_{n+1}\]</span> 添加到矩阵中： <span class="math display">\[\hat{X}_{LSW}(n+1)=(H_{n+1}^TR_{n+1}^{-1}H_{n+1})^{-1}H_{n+1}^TR_{n+1}^{-1}Z_{n+1}\]</span> 将<u>新的测量噪声</u>加入到原本的测量噪声矩阵中：R阵应为对角阵： <span class="math display">\[R_{k+1}^{-1}=\begin{bmatrix}R_n^{-1} &amp; 0 \\0&amp;r^{-1}_{n+1}\end{bmatrix}\]</span> 将式子展开： <span class="math display">\[P_{n+1}^{-1}=H_{n+1}^TR_{n+1}^{-1}H_{n+1}=[H_n^T,h_{n+1}^T]\begin{bmatrix}R_n^{-1} &amp; 0 \\0&amp;r^{-1}_{n+1}\end{bmatrix}\begin{bmatrix}H_n\\h_{n+1}\end{bmatrix}=H_n^TR_n^{-1}H_n+h_{n+1}^Tr_{n+1}^{-1}h_{n+1}\]</span> 即： <span class="math display">\[P_{n+1}^{-1}=P_n^{-1}+h_{n+1}^Tr_{n+1}^{-1}h_{n+1}\]</span> 综上，可以推得： <span class="math display">\[\begin{align}P_{n+1}&amp;=P_n-P_nh_{n+1}^T[h_{n+1}P_nh_{n+1}^T+r_{n+1}]^{-1}h_{n+1}P_n\\K_{n+1} &amp;= P_{n+1}h_{n+1}^Tr_{n+1}^{-1}\\\hat{X}_{LSW}(n+1)&amp;=\hat{X}_{LSW}(n)+K_{n+1}[z_{n+1}-h_{n+1}\hat{X}_{LSW}(n)]\end{align}\]</span> 其中<span class="math inline">\(K_{n+1}\)</span>可将(31)代入展开为： <span class="math display">\[K_{n+1} = P_nh_{n+1}^T[h_{n+1}P_nh_{n+1}^T+r_{n+1}]^{-1}\]</span> 因此<span class="math inline">\(P_{n+1}\)</span>亦可表示为： <span class="math display">\[P_{n+1}=P_n-K_{n+1}h_{n+1}P_n\]</span></p><h4 id="卡尔曼滤波">3.卡尔曼滤波</h4><p>若被估计量X不随时间变化，或随时间缓慢变化则为“静态估计”，而被估计量随时间变化为“动态估计”。</p><h4 id="参考">4.参考</h4><blockquote><p>https://blog.csdn.net/qinruiyan/article/details/50793114</p><p>《最优估计理论》刘胜，张红梅，科学出版社</p><h6 id="最佳线性无偏估计gm假设">最佳线性无偏估计（GM假设）</h6><p>假设多元线性回归模型：<span class="math inline">\(Z=HX+V\)</span> <span class="math display">\[\begin{align}Z&amp;=(z_1,\dots,z_n)^T\\H&amp;=\begin{bmatrix}h_{ij}\end{bmatrix}_{n\times{p}}\\X&amp;=(x_o,\dots,x_p)\\V&amp;=(v_0,\dots,v_n)\end{align}\]</span> 则GM假设： <span class="math display">\[\begin{align}E(V|H)&amp;=0,\forall H\ (零均值)\\Var(V|H)&amp;=E(VV^T|H)=\sigma^2I_n\ (同方差且不相关)\end{align}\]</span> 则此时对参数X的最佳线性无偏估计为： <span class="math display">\[\hat{X}=(H^TH)^{-1}H^TZ\]</span></p><h6 id="最小二乘估计与最小方差估计等价条件证明">最小二乘估计与最小方差估计等价条件证明：</h6><figure><img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin%20Jac\AppData\Roaming\Typora\typora-user-images\image-20191216221314847.png" alt="image-20191216221314847"><figcaption>image-20191216221314847</figcaption></figure><h6 id="各种估计方法的比较">各种估计方法的比较：</h6><figure><img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin%20Jac\AppData\Roaming\Typora\typora-user-images\image-20191216221240802.png" alt="image-20191216221240802"><figcaption>image-20191216221240802</figcaption></figure></blockquote><section class="footnotes"><hr><ol><li id="fn1"><p>残差在数理统计中是指实际观察值和估计值之间的差。若设线性回归模型为<span class="math inline">\(Z=HX+V\)</span> ,其中Z为n维输出向量，H是<span class="math inline">\(n\times(p+1)\)</span> 阶设计矩阵，X是p+1维向量，V为n维随机变量(扰动)。则回归系数的估计值<span class="math inline">\(\hat{X}=(H^TH)^{-1}H^TZ\)</span> ，拟合值<span class="math inline">\(\hat{Z} = H\hat{X}=H(H^TH)^{-1}H^TZ\)</span>,残差为<span class="math inline">\(\hat{\epsilon}=z_i-\hat{z_i}=z_i-H_i\hat{X}\)</span> ，其由观测真值和H阵给出，不考虑噪声V。 [^ 2]: https://zh.wikipedia.org/wiki/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5<img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin Jac\AppData\Roaming\Typora\typora-user-images\image-20191215194027795.png" alt="image-20191215194027795" style="zoom:50%;"><a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>在线性回归模型中，如果随机噪声（误差）满足<strong>零均值、同方差且互不相关</strong>，则回归系数的最优线性无偏估计（BLUE，Best Linear unbiased estimator）就是普通最小二乘估计。<a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 最优估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo感知代码阅读笔记</title>
      <link href="/2020/02/04/perception/"/>
      <url>/2020/02/04/perception/</url>
      
        <content type="html"><![CDATA[<p>apollo 感知部分代码阅读 <a id="more"></a></p><p>[TOC]</p><h2 id="主入口">主入口</h2><p><code>cyber/mainboard/mainboard.cc/int main(int argc,char** argv){...}</code></p><blockquote><p>解析配置参数；初始化cyber环境；由Moudule Controller类创建对象<code>controller</code>,调用<code>controller.Init()</code> 启动各功能模块；进入Cyber RT消息循环，等待<code>apollo::cyber::WaitForShutdown();</code> 返回Main函数，清理资源退出。</p></blockquote><p><code>controller.Init()</code> 调用 <code>ModuleController::LoadAll()</code></p><p><code>cyber/mainboard/module_controller.cc/bool ModuleController::LoadAll(){...}</code></p><blockquote><p>循环读取DAG配置文件列表，得到配置文件中所有<code>dag_conf</code> ,调用</p><p><code>bool ModuleController::LoadModule(const std::string&amp; path)</code> 加载模块功能</p></blockquote><p><code>cyber/mainboard/module_controller.cc/ModuleController::LoadModule(&amp;path)</code></p><blockquote><p>根据路径得到dag文件配置，调用<code>bool ModuleController::LoadModule(const DagConfig&amp; dag_config)</code> 实现加载模型。</p></blockquote><ul><li>component文件结构：<ul><li>头文件</li><li>实现文件</li><li>构建文件：BUILD</li><li>DAG配置文件</li><li>Launch启动文件</li></ul></li><li>实现Component（Compnent组件构建过程）<ul><li>基于模板类<code>cyber::Component</code> 派生各组件类</li><li>在派生类(<code>FusionComponent</code> )中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></li><li>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类</li></ul></li><li>消息接收发送的方式</li></ul><hr><h2 id="感知模块对象创建过程">感知模块对象创建过程</h2><p>apollo中对象的创建大多采用直接法，也有部分对象使用单例模式创建<code>DECLARE_SINGLETON(AdapterManager)</code>,还有部分对象采用工厂模式创建。</p><p>感知（perception）模块位于命名空间<code>apollo::perception</code> 中，创建过程</p><p>可能用到了<strong>工厂模式</strong> 动态创建<code>apollo::perception::FusionCameraDetectionComponent</code>类对象，首先生成一个与之对应的工厂类，并将其加入到工厂集合类 <code>std::map</code> 中 (参考planning模块，是否如此 存疑)</p><p>具体参考文件：</p><p><code>cyber/class_loader/utility/...</code></p><p>创建过程位于<code>bool ModuleController::LoadModule(const DagConfig&amp; dag_config)</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ModuleController::LoadModule</span><span class="params">(<span class="keyword">const</span> DagConfig&amp; dag_config)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> load_path;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    class_loader_manager_.LoadLibrary(load_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; component : module_config.components()) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; class_name = component.class_name();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ComponentBase&gt; base =</span><br><span class="line">          class_loader_manager_.CreateClassObj&lt;ComponentBase&gt;(class_name);</span><br><span class="line">      <span class="keyword">if</span> (base == <span class="literal">nullptr</span> || !base-&gt;Initialize(component.<span class="built_in">config</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      component_list_.emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(base));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类对象指针找到后使用<code>classobj = factory-&gt;CreateObj();</code>即可将PerceptionComponent 类对象创建。</p><hr><h2 id="功能模块构建">功能模块构建</h2><blockquote><p>基于模板类<code>Component</code> 派生各组件类</p><p>在派生类<code>FusionComponent</code> 中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></p><p>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类</p></blockquote><ul><li>基于模板类<code>Component</code> 派生各组件类</li></ul><p>模板类Component最多可接受4各模板参数，每个模板参数表示一种输入信息类型。</p><p><code>cyber/component/component.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M0 = NullType, <span class="keyword">typename</span> M1 = NullType,</span><br><span class="line">          <span class="keyword">typename</span> M2 = NullType, <span class="keyword">typename</span> M3 = NullType&gt;</span><br><span class="line">class Component : <span class="keyword">public</span> ComponentBase &#123;...&#125;</span><br></pre></td></tr></table></figure><p>感知模块各组件类（继承于基类cyber::Component):</p><p><code>FusionCameraDetectionComponent</code> ,<code>FusionComponent</code>, <code>LaneDetectionComponent</code>,<code>LidarOutputComponent</code>,<code>radar_detection_component</code>,<code>RecognitionComponent</code>,<code>SegmentationComponent</code>,<code>TrafficLightPerceptionComponent</code>.</p><p>以<code>FusionComponent</code>为例,继承自<code>cyber::Component&lt;SensorFrameMessage&gt;</code>，消息参数为<code>SensorFrameMessage</code>，这些消息将会在<code>Proc</code>函数中周期性接收并处理。</p><p><code>perception/onborad/component/fusion_component.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FusionComponent</span> :</span> <span class="keyword">public</span> cyber::Component&lt;SensorFrameMessage&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  ~FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Proc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt;&amp; message)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InitAlgorithmPlugin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InternalProc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage <span class="keyword">const</span>&gt;&amp; in_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PerceptionObstacles&gt; out_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; viz_message)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::mutex s_mutex_;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint32_t</span> s_seq_num_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_method_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_main_sensor_;</span><br><span class="line">  <span class="keyword">bool</span> object_in_roi_check_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">double</span> radius_for_roi_object_check_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;fusion::ObstacleMultiSensorFusion&gt; fusion_;</span><br><span class="line">  <span class="built_in">map</span>::HDMapInput* hdmap_input_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;PerceptionObstacles&gt;&gt; writer_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;SensorFrameMessage&gt;&gt; inner_writer_;</span><br><span class="line">&#125;;</span><br><span class="line">CYBER_REGISTER_COMPONENT(FusionComponent);</span><br></pre></td></tr></table></figure><ul><li><p>在派生类<code>FusionComponent</code> 中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></p><p><code>Init()</code> 创建实际对象，创建消息处理回调函数，创建输出器writer</p><p><code>Proc()</code> 周期性接收消息，执行相关处理，并向其他模块输出消息。</p></li><li><p>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类，使<code>Cyber RT</code> 能够正确创建和加载该类对象。</p></li><li><p>BUILD构建文件</p><p><code>perception/onboard/component/BUILD</code></p><p>基于<code>perception_component_inner_camera</code> 生成 <code>libperception_component_camera.so</code></p><p>基于<code>perception_component_inner_lidar</code> 生成 <code>libperception_component_lidar.so</code></p><p>生成的共享库文件由<code>Cyber RT</code> 调度程序mainboard动态加载运行。</p></li><li><p>DAG配置文件(有向无环图)：<code>perception/production/dag</code></p><p>DAG配置文件是Cyber RT 调度程序<code>mainboard</code> 动态加载<code>perception</code> 模块的最终配置文件。</p><p>加载命令：<code>/apollo/cyber/mainboard -d /apollo/modules/perception/production/dag/dag_streamimg_perception.dag</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module_config &#123;</span><br><span class="line">  #共享库文件路径</span><br><span class="line">  module_library : <span class="string">"/apollo/bazel-bin/modules/perception/onboard/component/libperception_component_lidar.so"</span></span><br><span class="line"></span><br><span class="line"> components &#123;</span><br><span class="line">    #组件名称，mainboard动态加载</span><br><span class="line">    class_name : <span class="string">"SegmentationComponent"</span></span><br><span class="line">    <span class="built_in">config</span> &#123;</span><br><span class="line">      #模块名</span><br><span class="line">      name: <span class="string">"Velodyne128Segmentation"</span></span><br><span class="line">      #绝对路径，配置文件路径</span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/lidar/velodyne128_segmentation_conf.pb.txt"</span></span><br><span class="line"></span><br><span class="line">      flag_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/perception_common.flag"</span></span><br><span class="line">      #组件proc()函数中使用的消息接收器</span><br><span class="line">      readers &#123;</span><br><span class="line">          channel: <span class="string">"/apollo/sensor/lidar128/compensator/PointCloud2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Launch 启动文件:<code>modules/perception/prodution/launch/perception_all.launch</code></p><p>Launch配置文件使用<code>Cyber RT</code> 提供的python工具程序<code>cyber_launch</code> 加载<code>Perception</code> 模块所需的配置文件，启动命令如下</p><p><code>cyber_launch start /apollo/launch/perception_all.launch</code></p><p>典型片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;cyber&gt;  </span><br><span class="line">&lt;<span class="keyword">module</span>&gt;</span><br><span class="line">        &lt;name&gt;perception&lt;/name&gt;</span><br><span class="line">        &lt;dag_conf&gt;/apollo/modules/perception/production/dag</span><br><span class="line">      /dag_streaming_perception.dag&lt;/dag_conf&gt;</span><br><span class="line">        &lt;!-- <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">set</span>, use <span class="keyword">default</span> <span class="built_in">process</span> --&gt;</span><br><span class="line">        &lt;process_name&gt;perception&lt;/process_name&gt;</span><br><span class="line">        &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/module&gt;</span><br><span class="line">&lt;cyber&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收消息：</p><p>基于<code>Cyber RT</code>接收消息分为两种：</p><ul><li><p>虚函数：Proc()中处理指定的消息类型，周期性触发（接收），但最多只能接收4种消息类型（由cyber::Component的模板参数最多只有4个决定），一般用于模块主要输入信息的接收。</p></li><li><p>直接创建消息接收器，一般用于接收非周期性消息或模块的次要输入消息，例如：</p><p><code>modules/perception/onboard/component/fusion_camera_detection_component.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> camera_reader = node_-&gt;CreateReader(channel_name, camera_callback);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>发布消息：</p><p>基于<code>Cyber RT</code> 发布消息</p><p><code>fusion_camera_detection_component.cc/FusionCameraDetectionComponent::Init()</code>定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sensorframe_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(prefused_channel_name_);</span><br></pre></td></tr></table></figure><p><code>FusionCameraDetectionComponent::OnReceiveImage</code>中发布消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> send_sensorframe_ret = sensorframe_writer_-&gt;Write(prefused_message);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="具体算法分析">具体算法分析：</h2><h2 id="消息发送接收类型">消息发送接收类型：</h2><p><code>FusionCameraDetectionComponent::Init(){}</code> 中以模板类的方式开头定义了四个writer:</p><p>其内容是<code>InitConfig()</code> 时导入的proto消息配置文件<code>&quot;fusion_camera_detection_component.proto&quot;</code> 信息 :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> output_obstacles_channel_name = <span class="number">10</span> [<span class="keyword">default</span> = <span class="string">"/perception/obstacles"</span>];</span><br><span class="line"><span class="built_in">string</span> prefused_channel_name = <span class="number">12</span> [<span class="keyword">default</span> = <span class="string">"/perception/inner/PrefusedObjects"</span>];</span><br><span class="line"><span class="built_in">string</span> camera_perception_viz_message_channel_name = <span class="number">11</span> [<span class="keyword">default</span> = <span class="string">"/perception/inner/camera_viz_msg"</span>]; <span class="comment">//3d?</span></span><br><span class="line"><span class="built_in">string</span> camera_debug_channel_name = <span class="number">20</span> [<span class="keyword">default</span> = <span class="string">"/perception/camera_debug"</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;PerceptionObstacles&gt;(output_obstacles_channel_name_); </span><br><span class="line">sensorframe_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(prefused_channel_name_);</span><br><span class="line">camera_viz_writer_ = node_-&gt;CreateWriter&lt;CameraPerceptionVizMessage&gt;(</span><br><span class="line">    camera_perception_viz_message_channel_name_);</span><br><span class="line">camera_debug_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;apollo::perception::camera::CameraDebug&gt;(</span><br><span class="line">        camera_debug_channel_name_);</span><br></pre></td></tr></table></figure><h3 id="文件参数初始化的调用关系">文件参数初始化的调用关系：</h3><p><code>*.proto</code> 中包含的相关固定（默认）参数通过编译为对应<code>package</code> 命名空间下的类，然后<code>*.pt</code> 的文件通过<code>GetAbsolutePath()</code> 函数读取，最后通过<code>cyber::common::GetProtoFromFile()</code> 函数将<code>*.pt</code> 中的参数部分修改<code>*.proto</code> 中的默认参数，即得最终的配置参数，然后这些参数复制给对应的类成员属性。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app::PerceptionParam perception_param_; <span class="comment">//对应proto文件生成的类</span></span><br><span class="line">config_file = GetAbsolutePath(work_root, config_file); <span class="comment">//通过路径获取pt文件的路径(obstacle.pt)</span></span><br><span class="line">cyber::common::GetProtoFromFile(config_file, &amp;perception_param_);<span class="comment">//部分修改perception_param中的参数</span></span><br><span class="line">detector_init_options.gpu_id = perception_param_.gpu_id();<span class="comment">//将proto文件参数赋给具体类实例中的成员属性</span></span><br></pre></td></tr></table></figure><p>模型参数以及相关配置文件的修改位于：</p><p><code>modules/perception/production/data/perception/..</code>中，包含了各个传感器及其对应的功能模块的配置文件</p><hr><h2 id="文件调用结构">文件调用结构</h2><p><img src="/2020/02/04/perception/fusion_init.png"></p><hr><h2 id="目前待解决的问题">目前待解决的问题：</h2><p><code>Cyber RT</code> 的调度与通信机制，例如Component::Proc()是如何被周期性調用的</p><p>camera app中如何被fusion中调用的，消息的传送方向。</p><h3 id="proto文件解析与c开发">1. Proto文件解析与C++开发</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.perception.camera.yolo; <span class="comment">//对应命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">YoloParam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> ModelParam model_param = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> NetworkParam net_param = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">optional</span> NMSParam nms_param = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “yolo.pb.h” <span class="comment">//此文件编译后产生</span></span></span><br><span class="line">yolo::YoloParam yolo_param_;<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><blockquote><p>https://www.jianshu.com/p/d2bed3614259</p></blockquote><p>.proto 文件以 package 声明开头，这有助于防止不同项目之间的命名冲突。在 C++ 中，生成的类将放在与包名匹配的 namespace （命名空间）中。</p><h3 id="tensorrt-模型量化方法">2. TensorRT 模型量化方法</h3><h3 id="caffe-blobternsorrtcaffe-特征提取的c接口">caffe blob、TernsorRT、caffe 特征提取的C++接口:</h3><h3 id="网络推断模型-inference_factory.cc的建立和区别与上面问题存在关联">3. 网络推断模型 （inference_factory.cc）的建立和区别(与上面问题存在关联)</h3><blockquote><p>CaffeNet</p><p>RTNet</p><p>RTNetInt8</p><p>PaddleNet</p></blockquote><h3 id="视频目标跟踪和目标检测的统一框架">4. 视频目标跟踪和目标检测的统一框架：</h3><blockquote><p>Detect to Track and Track to Detect</p></blockquote><h4 id="roi-pooling-track">Roi pooling track ?</h4><h3 id="目标跟踪-匈牙利算法hungarian-algorithm与km算法kuhn-munkres-algorithm">5. 目标跟踪 匈牙利算法（Hungarian Algorithm）与KM算法（Kuhn-Munkres Algorithm）</h3><blockquote><p>https://blog.csdn.net/NIeson2012/article/details/94472313</p><p>https://blog.csdn.net/zziahgf/article/details/85344859</p><p>https://blog.csdn.net/xiao__run/article/details/84374959</p><p>Deep sort论文需要看一下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
