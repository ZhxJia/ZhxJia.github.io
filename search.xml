<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>slam初探</title>
      <link href="/2020/02/04/slam1/"/>
      <url>/2020/02/04/slam1/</url>
      
        <content type="html"><![CDATA[<figure><img src="/2020/02/04/slam1/slam.png" alt="slam流程图"><figcaption>slam流程图</figcaption></figure><center>图1. slam 流程图</center>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客破壳日</title>
      <link href="/2020/02/04/hello-world/"/>
      <url>/2020/02/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>博客配置完工啦！今天是博客的破壳日o(￣ヘ￣o#) 2020 fighting!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最优估计 -- kalman and lsm</title>
      <link href="/2020/02/04/kalman_filter_and_lsm/"/>
      <url>/2020/02/04/kalman_filter_and_lsm/</url>
      
        <content type="html"><![CDATA[<p>kalman Filter 和 least square 目的均为最优化某一指标，指标是优化的关键：</p><a id="more"></a><p>常用的估计准则有：</p><ul><li><p>无偏估计：估计值的期望等于被估计参数的真实值。</p></li><li><p>线性最小方差估计：将估计量限制为观测值的线性函数，已知观测量Z和和被估计量X一二阶矩（EX,Var{X},EZ,Var{Z},Cov{X,Z}）,使估计误差的方差最小，即最小化<span class="math inline">\(tr\{E[\tilde{X}-E\tilde{X}][\tilde{X}-E\tilde{X}]^{T}\}\)</span> ,<span class="math inline">\(\tilde{X}\)</span>为估计误差（等价于最小化均方误差阵，若为无偏估计）可得其无偏估计值为<span class="math inline">\(\tilde{X}_{LMV}(Z)=EX+cov(X,Z)(var(Z))^{-1}[Z-EZ]\)</span>对于观测模型Z=HX+V，上述条件若已知</p><p><span class="math inline">\(\{EX=\mu_x,Var(X)=P_x,EV=0,Var(V)=R,E(XV^T)=0\}\)</span> 即可得到。</p></li><li><p>最小二乘估计：对数据（X、Z）的统计特性一无所知，但仍需对X进行估计，目标是最小化残差<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>平方和。</p><p>满足最小方差必满足残差平方和最小，反之则不成立。</p></li></ul><h4 id="经典最小二乘">经典最小二乘</h4><p>针对隐状态X，若其无法直接观测，但间接获取其观测值<span class="math inline">\(Z=[z_1,z_2,\dots,z_n]^T\)</span> ,若其观测值为状态值的线性函数： <span class="math display">\[Z_i=H_iX+V_i,i=1,\dots,n\]</span> <span class="math inline">\(z_i\)</span>为第i次测量的观测值，<span class="math inline">\(H_i\)</span>为第i次测量的观测模型(设计矩阵，实验的观测值)，<span class="math inline">\(V_i\)</span>为第i次测量的噪声（误差）。</p><p>则第i次测量的估计误差： <span class="math display">\[\hat{e_i}=z_i-H_i\hat{X}\]</span> 则n次测量的误差（残差）平方和为优化指标： <span class="math display">\[J(\hat{X})=\sum_{i=1}^{n}{(z_i-H_i\hat{X})^2}=(Z-H\hat{X})^T(Z-H\hat{X}) \\=tr[(Z-H\hat{X})(Z-H\hat{X})^T]\]</span> 令<span class="math inline">\(\frac{\partial{J}}{\partial{\hat{X}}}=0\)</span> ,可得最小二乘估计值： <span class="math display">\[\hat{X}_{LS}=(H^TH)^{-1}H^TZ\]</span> 将<span class="math inline">\(Z=HX+V\)</span>此时状态的估计误差： <span class="math display">\[\tilde{X}_{LS}=X-\hat{X}_{LS}=-(H^TH)^{-1}H^TV\]</span> 若测量噪声均值为0，则<span class="math inline">\(E(\tilde{X}_{LS})=0\)</span>,此时最小二乘估计为<strong><u>无偏估计</u></strong>，<strong>状态估计误差的（协）方差[^ 2] <span class="math inline">\(Var(\tilde{X}_{LS})=E[(\tilde{X}-E\tilde{X})(\tilde{X}-E\tilde{X})^T]\)</span>与估计量的均方误差矩阵<span class="math inline">\(E[X-\hat{X}][X-\hat{X}]^T\)</span>相等</strong>。可见标准最小二乘不需要噪声V的任何统计信息。</p><p>由(5)式可得： <span class="math display">\[\begin{align}Var(\tilde{X}_{LS})=E[X-\hat{X}][X-\hat{X}]^T &amp; = (H^TH)^{-1}H^TE(VV^T)H(H^TH)^{-1}\\&amp;=(H^TH)^{-1}H^TRH(H^TH)^{-1}\end{align}\]</span> 其中<span class="math inline">\(R=E(VV^T)\)</span>为测量误差（噪声）的（协）方差阵。</p><h4 id="加权最小二乘weighted-least-square">加权最小二乘（weighted least square）</h4><p>在经典最小二乘中，假定每一次测量的权重相同，但是一般来说近期数据比远期数据影响更大，因此引入加权最小二乘，其指标形式： <span class="math display">\[J_W(\hat{X})=\sum_{i=1}^{n}{(z_i-H_i\hat{X})^2}=(Z-H\hat{X})^TW(Z-H\hat{X})\]</span> 同样使其偏导数为0,可得 <span class="math display">\[\hat{X}_{LSW}=(H^TWH)^{-1}H^TWZ\]</span></p><hr><p>由附录<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>,若噪声不满足同方差，则普通最小二乘(4)并不是BLUE，此时噪声的协方差阵</p><p><span class="math inline">\(E[VV^T]=\sigma^2R,R\neq{I}\)</span> ,<span class="math inline">\(R=\begin{bmatrix}r_1\\&amp;\ddots\\&amp;&amp; r_n\end{bmatrix}\)</span>,即原模型存在异方差性。</p><p>设<span class="math inline">\(R=DD^T,D=\begin{bmatrix}\sqrt{r_1}\\&amp;\ddots\\&amp;&amp; \sqrt{r_n}\end{bmatrix}\)</span> ,用<span class="math inline">\(D^{-1}\)</span>同时左乘<span class="math inline">\(Z=HX+V\)</span>两端得到新的模型： <span class="math display">\[\begin{align}D^{-1}Z&amp;=D^{-1}HX+D^{-1}V \\Z^{\star}&amp;=H^{\star}X+V^{\star}\end{align}\]</span> 此时,原模型的加权最小二乘估计量为无偏的。 <span class="math display">\[\begin{align}E[V^{\star}V^{\star T}]&amp;=E[D^{-1}VV^TD^{-1\ T}]\\&amp;=D^{-1}E[VV^T]D^{-1\ T}\\&amp;=\sigma^2D^{-1}RD^{-1\ T}\\&amp;=\sigma^2I\end{align}\]</span> 此时得到的参数估计为： <span class="math display">\[\begin{align}\hat{X}_{LSW}&amp;=(H^{\star T}H^{\star})^{-1}H^{\star T}Z^{\star}\\&amp;=(H^TR^{-1}H)^{-1}H^TR^{-1}Z\end{align}\]</span> 可以证明（见附录），当<span class="math inline">\(W=R^{-1}\)</span>时，最小二乘估计时缺少初值条件下的<strong><u>线性无偏最小方差估计</u></strong>（BLUE,Best Linear Unbiased Estimation）——即能够使估计误差的方差阵最小，又称马尔可夫估计,其中 <span class="math display">\[R=E[VV^T]\]</span> 为随机噪声的（协）方差阵（对称正定阵）。</p><h4 id="递推最小二乘recursive-least-squarerls">递推最小二乘（Recursive Least Square,RLS）</h4><p>上述方法进行一次估计需要所有历史数据，不利于在线估计，考虑前n次测量： <span class="math display">\[Z_n=H_nX+V_n\]</span> 则加权的最小二乘估计为： <span class="math display">\[\hat{X}_{LSW}(n)=(H_{n}^TR_{n}^{-1}H_n)^{-1}H_{n}^TR_{n}^{-1}Z_n\]</span> 估计误差的（协）方差矩阵为： <span class="math display">\[\begin{align}P_n&amp;=E[\tilde{X}_{LSW}(n)\tilde{X}_{LSW}^T(n)]\\&amp;=E[-(H^TR^{-1}H)^{-1}]H^TR^{-1}VV^TR^{-1}H(H^TR^{-1}H)^{-1}\\&amp;=(H^TR^{-1}H)^{-1}H^TR^{-1}H(H^TR^{-1}H)^{-1}\\&amp;=(H^TR^{-1}H)^{-1}\end{align}\]</span> 结合上述两式，可得： <span class="math display">\[\hat{X}_{LSW}(n)=P_nH_{n}^TR_{n}^{-1}Z_n\]</span> 现得到一个新的测量值： <span class="math display">\[z_{n+1}=H_{n+1}X+v_{n+1}\]</span> 添加到矩阵中： <span class="math display">\[\hat{X}_{LSW}(n+1)=(H_{n+1}^TR_{n+1}^{-1}H_{n+1})^{-1}H_{n+1}^TR_{n+1}^{-1}Z_{n+1}\]</span> 将<u>新的测量噪声</u>加入到原本的测量噪声矩阵中：R阵应为对角阵： <span class="math display">\[R_{k+1}^{-1}=\begin{bmatrix}R_n^{-1} &amp; 0 \\0&amp;r^{-1}_{n+1}\end{bmatrix}\]</span> 将式子展开： <span class="math display">\[P_{n+1}^{-1}=H_{n+1}^TR_{n+1}^{-1}H_{n+1}=[H_n^T,h_{n+1}^T]\begin{bmatrix}R_n^{-1} &amp; 0 \\0&amp;r^{-1}_{n+1}\end{bmatrix}\begin{bmatrix}H_n\\h_{n+1}\end{bmatrix}=H_n^TR_n^{-1}H_n+h_{n+1}^Tr_{n+1}^{-1}h_{n+1}\]</span> 即： <span class="math display">\[P_{n+1}^{-1}=P_n^{-1}+h_{n+1}^Tr_{n+1}^{-1}h_{n+1}\]</span> 综上，可以推得： <span class="math display">\[\begin{align}P_{n+1}&amp;=P_n-P_nh_{n+1}^T[h_{n+1}P_nh_{n+1}^T+r_{n+1}]^{-1}h_{n+1}P_n\\K_{n+1} &amp;= P_{n+1}h_{n+1}^Tr_{n+1}^{-1}\\\hat{X}_{LSW}(n+1)&amp;=\hat{X}_{LSW}(n)+K_{n+1}[z_{n+1}-h_{n+1}\hat{X}_{LSW}(n)]\end{align}\]</span> 其中<span class="math inline">\(K_{n+1}\)</span>可将(31)代入展开为： <span class="math display">\[K_{n+1} = P_nh_{n+1}^T[h_{n+1}P_nh_{n+1}^T+r_{n+1}]^{-1}\]</span> 因此<span class="math inline">\(P_{n+1}\)</span>亦可表示为： <span class="math display">\[P_{n+1}=P_n-K_{n+1}h_{n+1}P_n\]</span></p><h4 id="卡尔曼滤波">卡尔曼滤波</h4><p>若被估计量X不随时间变化，或随时间缓慢变化则为“静态估计”，而被估计量随时间变化为“动态估计”。</p><p>参考：</p><blockquote><p>https://blog.csdn.net/qinruiyan/article/details/50793114</p><p>《最优估计理论》刘胜，张红梅，科学出版社</p><h6 id="最佳线性无偏估计gm假设">最佳线性无偏估计（GM假设）</h6><p>假设多元线性回归模型：<span class="math inline">\(Z=HX+V\)</span> <span class="math display">\[\begin{align}Z&amp;=(z_1,\dots,z_n)^T\\H&amp;=\begin{bmatrix}h_{ij}\end{bmatrix}_{n\times{p}}\\X&amp;=(x_o,\dots,x_p)\\V&amp;=(v_0,\dots,v_n)\end{align}\]</span> 则GM假设： <span class="math display">\[\begin{align}E(V|H)&amp;=0,\forall H\ (零均值)\\Var(V|H)&amp;=E(VV^T|H)=\sigma^2I_n\ (同方差且不相关)\end{align}\]</span> 则此时对参数X的最佳线性无偏估计为： <span class="math display">\[\hat{X}=(H^TH)^{-1}H^TZ\]</span></p><h6 id="最小二乘估计与最小方差估计等价条件证明">最小二乘估计与最小方差估计等价条件证明：</h6><figure><img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin%20Jac\AppData\Roaming\Typora\typora-user-images\image-20191216221314847.png" alt="image-20191216221314847"><figcaption>image-20191216221314847</figcaption></figure><h6 id="各种估计方法的比较">各种估计方法的比较：</h6><figure><img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin%20Jac\AppData\Roaming\Typora\typora-user-images\image-20191216221240802.png" alt="image-20191216221240802"><figcaption>image-20191216221240802</figcaption></figure></blockquote><section class="footnotes"><hr><ol><li id="fn1"><p>残差在数理统计中是指实际观察值和估计值之间的差。若设线性回归模型为<span class="math inline">\(Z=HX+V\)</span> ,其中Z为n维输出向量，H是<span class="math inline">\(n\times(p+1)\)</span> 阶设计矩阵，X是p+1维向量，V为n维随机变量(扰动)。则回归系数的估计值<span class="math inline">\(\hat{X}=(H^TH)^{-1}H^TZ\)</span> ，拟合值<span class="math inline">\(\hat{Z} = H\hat{X}=H(H^TH)^{-1}H^TZ\)</span>,残差为<span class="math inline">\(\hat{\epsilon}=z_i-\hat{z_i}=z_i-H_i\hat{X}\)</span> ，其由观测真值和H阵给出，不考虑噪声V。 [^ 2]: https://zh.wikipedia.org/wiki/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5<img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin Jac\AppData\Roaming\Typora\typora-user-images\image-20191215194027795.png" alt="image-20191215194027795" style="zoom:50%;"><a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>在线性回归模型中，如果随机噪声（误差）满足<strong>零均值、同方差且互不相关</strong>，则回归系数的最优线性无偏估计（BLUE，Best Linear unbiased estimator）就是普通最小二乘估计。<a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 最优估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo感知代码阅读笔记</title>
      <link href="/2020/02/04/perception/"/>
      <url>/2020/02/04/perception/</url>
      
        <content type="html"><![CDATA[<p>apollo 感知部分代码阅读 <a id="more"></a> ## 主入口</p><p><code>cyber/mainboard/mainboard.cc/int main(int argc,char** argv){...}</code></p><blockquote><p>解析配置参数；初始化cyber环境；由Moudule Controller类创建对象<code>controller</code>,调用<code>controller.Init()</code> 启动各功能模块；进入Cyber RT消息循环，等待<code>apollo::cyber::WaitForShutdown();</code> 返回Main函数，清理资源退出。</p></blockquote><p><code>controller.Init()</code> 调用 <code>ModuleController::LoadAll()</code></p><p><code>cyber/mainboard/module_controller.cc/bool ModuleController::LoadAll(){...}</code></p><blockquote><p>循环读取DAG配置文件列表，得到配置文件中所有<code>dag_conf</code> ,调用</p><p><code>bool ModuleController::LoadModule(const std::string&amp; path)</code> 加载模块功能</p></blockquote><p><code>cyber/mainboard/module_controller.cc/ModuleController::LoadModule(&amp;path)</code></p><blockquote><p>根据路径得到dag文件配置，调用<code>bool ModuleController::LoadModule(const DagConfig&amp; dag_config)</code> 实现加载模型。</p></blockquote><ul><li>component文件结构：<ul><li>头文件</li><li>实现文件</li><li>构建文件：BUILD</li><li>DAG配置文件</li><li>Launch启动文件</li></ul></li><li>实现Component（Compnent组件构建过程）<ul><li>基于模板类<code>cyber::Component</code> 派生各组件类</li><li>在派生类(<code>FusionComponent</code> )中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></li><li>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类</li></ul></li><li>消息接收发送的方式</li></ul><hr><h2 id="感知模块对象创建过程">感知模块对象创建过程</h2><p>apollo中对象的创建大多采用直接法，也有部分对象使用单例模式创建<code>DECLARE_SINGLETON(AdapterManager)</code>,还有部分对象采用工厂模式创建。</p><p>感知（perception）模块位于命名空间<code>apollo::perception</code> 中，创建过程</p><p>可能用到了<strong>工厂模式</strong> 动态创建<code>apollo::perception::FusionCameraDetectionComponent</code>类对象，首先生成一个与之对应的工厂类，并将其加入到工厂集合类 <code>std::map</code> 中 (参考planning模块，是否如此 存疑)</p><p>具体参考文件：</p><p><code>cyber/class_loader/utility/...</code></p><p>创建过程位于<code>bool ModuleController::LoadModule(const DagConfig&amp; dag_config)</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ModuleController::LoadModule</span><span class="params">(<span class="keyword">const</span> DagConfig&amp; dag_config)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> load_path;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    class_loader_manager_.LoadLibrary(load_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; component : module_config.components()) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; class_name = component.class_name();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ComponentBase&gt; base =</span><br><span class="line">          class_loader_manager_.CreateClassObj&lt;ComponentBase&gt;(class_name);</span><br><span class="line">      <span class="keyword">if</span> (base == <span class="literal">nullptr</span> || !base-&gt;Initialize(component.<span class="built_in">config</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      component_list_.emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(base));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类对象指针找到后使用<code>classobj = factory-&gt;CreateObj();</code>即可将PerceptionComponent 类对象创建。</p><hr><h2 id="功能模块构建">功能模块构建</h2><blockquote><p>基于模板类<code>Component</code> 派生各组件类</p><p>在派生类<code>FusionComponent</code> 中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></p><p>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类</p></blockquote><ul><li>基于模板类<code>Component</code> 派生各组件类</li></ul><p>模板类Component最多可接受4各模板参数，每个模板参数表示一种输入信息类型。</p><p><code>cyber/component/component.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M0 = NullType, <span class="keyword">typename</span> M1 = NullType,</span><br><span class="line">          <span class="keyword">typename</span> M2 = NullType, <span class="keyword">typename</span> M3 = NullType&gt;</span><br><span class="line">class Component : <span class="keyword">public</span> ComponentBase &#123;...&#125;</span><br></pre></td></tr></table></figure><p>感知模块各组件类（继承于基类cyber::Component):</p><p><code>FusionCameraDetectionComponent</code> ,<code>FusionComponent</code>, <code>LaneDetectionComponent</code>,<code>LidarOutputComponent</code>,<code>radar_detection_component</code>,<code>RecognitionComponent</code>,<code>SegmentationComponent</code>,<code>TrafficLightPerceptionComponent</code>.</p><p>以<code>FusionComponent</code>为例,继承自<code>cyber::Component&lt;SensorFrameMessage&gt;</code>，消息参数为<code>SensorFrameMessage</code>，这些消息将会在<code>Proc</code>函数中周期性接收并处理。</p><p><code>perception/onborad/component/fusion_component.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FusionComponent</span> :</span> <span class="keyword">public</span> cyber::Component&lt;SensorFrameMessage&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  ~FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Proc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt;&amp; message)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InitAlgorithmPlugin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InternalProc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage <span class="keyword">const</span>&gt;&amp; in_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PerceptionObstacles&gt; out_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; viz_message)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::mutex s_mutex_;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint32_t</span> s_seq_num_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_method_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_main_sensor_;</span><br><span class="line">  <span class="keyword">bool</span> object_in_roi_check_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">double</span> radius_for_roi_object_check_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;fusion::ObstacleMultiSensorFusion&gt; fusion_;</span><br><span class="line">  <span class="built_in">map</span>::HDMapInput* hdmap_input_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;PerceptionObstacles&gt;&gt; writer_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;SensorFrameMessage&gt;&gt; inner_writer_;</span><br><span class="line">&#125;;</span><br><span class="line">CYBER_REGISTER_COMPONENT(FusionComponent);</span><br></pre></td></tr></table></figure><ul><li><p>在派生类<code>FusionComponent</code> 中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></p><p><code>Init()</code> 创建实际对象，创建消息处理回调函数，创建输出器writer</p><p><code>Proc()</code> 周期性接收消息，执行相关处理，并向其他模块输出消息。</p></li><li><p>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类，使<code>Cyber RT</code> 能够正确创建和加载该类对象。</p></li><li><p>BUILD构建文件</p><p><code>perception/onboard/component/BUILD</code></p><p>基于<code>perception_component_inner_camera</code> 生成 <code>libperception_component_camera.so</code></p><p>基于<code>perception_component_inner_lidar</code> 生成 <code>libperception_component_lidar.so</code></p><p>生成的共享库文件由<code>Cyber RT</code> 调度程序mainboard动态加载运行。</p></li><li><p>DAG配置文件：<code>perception/production/dag</code></p><p>DAG配置文件是Cyber RT 调度程序<code>mainboard</code> 动态加载<code>perception</code> 模块的最终配置文件。</p><p>加载命令：<code>/apollo/cyber/mainboard -d /apollo/modules/perception/production/dag/dag_streamimg_perception.dag</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module_config &#123;</span><br><span class="line">  #共享库文件路径</span><br><span class="line">  module_library : <span class="string">"/apollo/bazel-bin/modules/perception/onboard/component/libperception_component_lidar.so"</span></span><br><span class="line"></span><br><span class="line"> components &#123;</span><br><span class="line">    #组件名称，mainboard动态加载</span><br><span class="line">    class_name : <span class="string">"SegmentationComponent"</span></span><br><span class="line">    <span class="built_in">config</span> &#123;</span><br><span class="line">      #模块名</span><br><span class="line">      name: <span class="string">"Velodyne128Segmentation"</span></span><br><span class="line">      #绝对路径，配置文件路径</span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/lidar/velodyne128_segmentation_conf.pb.txt"</span></span><br><span class="line"></span><br><span class="line">      flag_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/perception_common.flag"</span></span><br><span class="line">      #组件proc()函数中使用的消息接收器</span><br><span class="line">      readers &#123;</span><br><span class="line">          channel: <span class="string">"/apollo/sensor/lidar128/compensator/PointCloud2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Launch 启动文件:<code>modules/perception/prodution/launch/perception_all.launch</code></p><p>Launch配置文件使用<code>Cyber RT</code> 提供的python工具程序<code>cyber_launch</code> 加载<code>Perception</code> 模块所需的配置文件，启动命令如下</p><p><code>cyber_launch start /apollo/launch/perception_all.launch</code></p><p>典型片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;cyber&gt;  </span><br><span class="line">&lt;<span class="keyword">module</span>&gt;</span><br><span class="line">        &lt;name&gt;perception&lt;/name&gt;</span><br><span class="line">        &lt;dag_conf&gt;/apollo/modules/perception/production/dag</span><br><span class="line">      /dag_streaming_perception.dag&lt;/dag_conf&gt;</span><br><span class="line">        &lt;!-- <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">set</span>, use <span class="keyword">default</span> <span class="built_in">process</span> --&gt;</span><br><span class="line">        &lt;process_name&gt;perception&lt;/process_name&gt;</span><br><span class="line">        &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/module&gt;</span><br><span class="line">&lt;cyber&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收消息：</p><p>基于<code>Cyber RT</code>接收消息分为两种：</p><ul><li><p>虚函数：Proc()中处理指定的消息类型，周期性触发（接收），但最多只能接收4种消息类型（由cyber::Component的模板参数最多只有4个决定），一般用于模块主要输入信息的接收。</p></li><li><p>直接创建消息接收器，一般用于接收非周期性消息或模块的次要输入消息，例如：</p><p><code>modules/perception/onboard/component/fusion_camera_detection_component.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> camera_reader = node_-&gt;CreateReader(channel_name, camera_callback);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>发布消息：</p><p>基于<code>Cyber RT</code> 发布消息</p><p><code>fusion_camera_detection_component.cc/FusionCameraDetectionComponent::Init()</code>定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sensorframe_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(prefused_channel_name_);</span><br></pre></td></tr></table></figure><p><code>FusionCameraDetectionComponent::OnReceiveImage</code>中发布消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> send_sensorframe_ret = sensorframe_writer_-&gt;Write(prefused_message);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="具体算法分析">具体算法分析：</h2><h2 id="消息发送接收类型">消息发送接收类型：</h2><p><code>FusionCameraDetectionComponent::Init(){}</code> 中以模板类的方式开头定义了四个writer:</p><p>其内容是<code>InitConfig()</code> 时导入的proto消息配置文件<code>&quot;fusion_camera_detection_component.proto&quot;</code> 信息 :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> output_obstacles_channel_name = <span class="number">10</span> [<span class="keyword">default</span> = <span class="string">"/perception/obstacles"</span>];</span><br><span class="line"><span class="built_in">string</span> prefused_channel_name = <span class="number">12</span> [<span class="keyword">default</span> = <span class="string">"/perception/inner/PrefusedObjects"</span>];</span><br><span class="line"><span class="built_in">string</span> camera_perception_viz_message_channel_name = <span class="number">11</span> [<span class="keyword">default</span> = <span class="string">"/perception/inner/camera_viz_msg"</span>]; <span class="comment">//3d?</span></span><br><span class="line"><span class="built_in">string</span> camera_debug_channel_name = <span class="number">20</span> [<span class="keyword">default</span> = <span class="string">"/perception/camera_debug"</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;PerceptionObstacles&gt;(output_obstacles_channel_name_); </span><br><span class="line">sensorframe_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(prefused_channel_name_);</span><br><span class="line">camera_viz_writer_ = node_-&gt;CreateWriter&lt;CameraPerceptionVizMessage&gt;(</span><br><span class="line">    camera_perception_viz_message_channel_name_);</span><br><span class="line">camera_debug_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;apollo::perception::camera::CameraDebug&gt;(</span><br><span class="line">        camera_debug_channel_name_);</span><br></pre></td></tr></table></figure><h3 id="文件参数初始化的调用关系">文件参数初始化的调用关系：</h3><p><code>*.proto</code> 中包含的相关固定（默认）参数通过编译为对应<code>package</code> 命名空间下的类，然后<code>*.pt</code> 的文件通过<code>GetAbsolutePath()</code> 函数读取，最后通过<code>cyber::common::GetProtoFromFile()</code> 函数将<code>*.pt</code> 中的参数部分修改<code>*.proto</code> 中的默认参数，即得最终的配置参数，然后这些参数复制给对应的类成员属性。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app::PerceptionParam perception_param_; <span class="comment">//对应proto文件生成的类</span></span><br><span class="line">config_file = GetAbsolutePath(work_root, config_file); <span class="comment">//通过路径获取pt文件的路径(obstacle.pt)</span></span><br><span class="line">cyber::common::GetProtoFromFile(config_file, &amp;perception_param_);<span class="comment">//部分修改perception_param中的参数</span></span><br><span class="line">detector_init_options.gpu_id = perception_param_.gpu_id();<span class="comment">//将proto文件参数赋给具体类实例中的成员属性</span></span><br></pre></td></tr></table></figure><p>模型参数以及相关配置文件的修改位于：</p><p><code>modules/perception/production/data/perception/..</code>中，包含了各个传感器及其对应的功能模块的配置文件</p><h2 id="目前待解决的问题">目前待解决的问题：</h2><p><code>Cyber RT</code> 的调度与通信机制，例如Component::Proc()是如何被周期性調用的</p><p>camera app中如何被fusion中调用的，消息的传送方向。</p><h3 id="proto文件解析与c开发">1. Proto文件解析与C++开发</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.perception.camera.yolo; <span class="comment">//对应命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">YoloParam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> ModelParam model_param = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> NetworkParam net_param = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">optional</span> NMSParam nms_param = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “yolo.pb.h” <span class="comment">//此文件编译后产生</span></span></span><br><span class="line">yolo::YoloParam yolo_param_;<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><blockquote><p>https://www.jianshu.com/p/d2bed3614259</p></blockquote><p>.proto 文件以 package 声明开头，这有助于防止不同项目之间的命名冲突。在 C++ 中，生成的类将放在与包名匹配的 namespace （命名空间）中。</p><h4 id="tensorrt-模型量化方法">2. TensorRT 模型量化方法</h4><h4 id="caffe-blobternsorrtcaffe-特征提取的c接口">caffe blob、TernsorRT、caffe 特征提取的C++接口:</h4><h4 id="网络推断模型-inference_factory.cc的建立和区别与上面问题存在关联">3. 网络推断模型 （inference_factory.cc）的建立和区别(与上面问题存在关联)</h4><blockquote><p>CaffeNet</p><p>RTNet</p><p>RTNetInt8</p><p>PaddleNet</p></blockquote><h3 id="视频目标跟踪和目标检测的统一框架">4. 视频目标跟踪和目标检测的统一框架：</h3><blockquote><p>Detect to Track and Track to Detect</p></blockquote><h4 id="roi-pooling-track">Roi pooling track ?</h4><h4 id="目标跟踪-匈牙利算法hungarian-algorithm与km算法kuhn-munkres-algorithm">5. 目标跟踪 匈牙利算法（Hungarian Algorithm）与KM算法（Kuhn-Munkres Algorithm）</h4><blockquote><p>https://blog.csdn.net/NIeson2012/article/details/94472313</p><p>https://blog.csdn.net/zziahgf/article/details/85344859</p><p>https://blog.csdn.net/xiao__run/article/details/84374959</p><p>Deep sort论文需要看一下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机标定</title>
      <link href="/2020/02/04/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"/>
      <url>/2020/02/04/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="单应性矩阵">单应性矩阵</h3>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> 标定 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
            <tag> 标定 </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
