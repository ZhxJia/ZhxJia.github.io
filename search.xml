<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>序列容器</title>
      <link href="/2020/02/13/sequence-containers/"/>
      <url>/2020/02/13/sequence-containers/</url>
      
        <content type="html"><![CDATA[<p>c++ 模板库中序列容器的使用</p><a id="more"></a><p>序列(顺序)容器以线性序列的方式存储元素。它没有对元素进行排序，元素的顺序和存储它们的顺序相同,主要有以下五种标准的序列容器：</p><blockquote><ul><li>array&lt;T,N&gt;(数组容器):长度固定的序列，存放N个T类型的对象，不能增加或删除元素。</li><li>vector<T>(向量容器):长度可变的序列，存放T类型的对象，只能在序列的末尾增删元素。</T></li><li>deque<T>(双向队列容器):长度可变的序列，两端均可增删元素。</T></li><li>list<T>(链表容器):长度可变的序列，存放T类型对象，在序列任何地方都可以增加或删除元素。(双向链表)</T></li><li>forward_list<T>(正向链表容器)，长度可变，由T类型对象组成的序列。(单向链表)</T></li></ul></blockquote><p>下面具体介绍容器中常见的函数成员用法(限于篇幅，主要介绍典型的vector容器和list容器)</p><p>为了方便介绍STL的相关内容，首先介绍STL库的相关前置知识和思想，主要包括：</p><blockquote><ul><li>模板</li><li>容器</li><li>迭代器</li><li>智能指针</li><li>算法</li></ul></blockquote><h3 id="一前置知识">一、前置知识</h3><ul><li><p><strong>模板</strong></p><p>模板是一组函数或类的参数实现，模板并不是可执行代码，而是用于生成代码的配方，没有使用的模板会被编译器忽略。</p><p><strong>模板函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp; <span class="title">larger</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;<span class="comment">//&amp;表示引用</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">first</span><span class="params">(<span class="string">"To be or not to be "</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">second</span><span class="params">(<span class="string">"This is a question"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; larger(first, second) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b =<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; larger(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; To be <span class="keyword">or</span> <span class="keyword">not</span> to be </span><br><span class="line">&gt;&gt;&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>模板函数可以隐式推断传入类型，当然也可以显式指定类型</p><p><strong>模板类</strong></p><p>引入以下实现一个数组类的实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; //memory 要置于shared_ptr之前　真神奇</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/shared_ptr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A *elements;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Array</span><span class="params">(<span class="keyword">size_t</span> arraySize)</span></span>;   <span class="comment">//显式构造函数</span></span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;other);          <span class="comment">//拷贝构造函数 </span></span><br><span class="line">    Array(Array &amp;&amp;other);               <span class="comment">//转移构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Array() &#123;&#125;;                   <span class="comment">//析构函数</span></span><br><span class="line">    A &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> index);        <span class="comment">//Subscript operator</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> index) <span class="keyword">const</span>;  <span class="comment">// Subscript operator</span></span><br><span class="line">    Array &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;rhs);   <span class="comment">// Assignment operator</span></span><br><span class="line">    Array &amp;<span class="keyword">operator</span>=(Array &amp;&amp;rhs);   <span class="comment">//Move assignment operator　&amp;&amp;:右值引用</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;     <span class="comment">//Accessor for count</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拷贝构造函数利用现有对象初始化创建新对象(Array<int> A2 =A1)，为防止shallow copy ,需要重载此函数。</int></p><p>如果想要将A3的属性赋值给A4(A4 = A3),则需要重载operator。</p><p>类成员模板函数定义(std::nothrow 用于申请内存不足时返回nullptr)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line">Array&lt;A&gt;::Array(<span class="keyword">size_t</span> arraySize) : elements(<span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) A[arraySize]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elements == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Memory allocation faliure in Array constructor."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//没有足够的内存会返回nullptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">inline</span> Array&lt;A&gt;::Array(<span class="keyword">const</span> Array &amp;other):elements(<span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) A[other.count]), count(other.count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elements == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Memory allocation faliure in Array constructor."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; count; i++)&#123;</span><br><span class="line">            elements[i] = other.elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>容器</strong></p><p>容器是STL各种功能的基础，是以特定形式存储和组织其他对象的对象，容器中数据的访问采用iterators,STL提供以下几种类型的容器：</p><ul><li><strong>序列容器(sequence containers)：</strong>以线性组织的方式存储对象，和数组类似，但是不需要连续的存储空间。</li><li><strong>关联容器(Associative Containers)：</strong>存储和键关联的对象。可以通过相关联的建从关联容器中获取对应的值，也可通过迭代器从关联容器中得到对象。</li><li><strong>容器适配器(Container Adapters):</strong> 是提供了替换机制的适配类模板，可以用来访问基础的序列容器和关联容器。</li></ul><p>STL容器存储的是对象的副本。STL要求移动构造函数和复制运算符必须被指定为noexcept，即不会抛出异常。容器在堆上存放对象，并自动管理它们所占用的内存，一个T类型的对象如果要存放在容器中，需要满足一些特定要求，这些要求取决与你对元素执行的操作，通常有复制、移动、交换等操作,下面给出一个满足在容器中存放的T类型对象的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T();<span class="comment">//default constructor</span></span><br><span class="line">    T(<span class="keyword">const</span> T &amp;t);<span class="comment">//copy constructor</span></span><br><span class="line">    ~T();<span class="comment">//Destructor</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> T &amp;t);<span class="comment">//重载＝运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在关联容器中使用对象的话，对象需要定义operator&lt;(),提供小于运算符，来使用sort()和merge()这类算法。</p></li><li><p><strong>迭代器</strong></p><p>​ 当使用容器时，不可避免地会使用到iterators去访问数据，迭代器是一个行为类似于指针的模板类对象，只要迭代器iter指向一个有效对象，就可以通过使用*iter解引用的方式来获取一个对象的引用。如果iter指向一个可以访问成员的类对象，类成员就可以通过iter-&gt;member来使用。</p><p>​ 迭代器将算法和不同类型容器的元素联系了起来，获取迭代器的方式有：</p><ul><li>调用容器对象<code>begin()</code>和<code>end()</code>，返回的这两个迭代器分别指向第一个和最后一个元素下一个位置。<code>end()</code>返回的迭代器并没有指向一个有效的元素，所以既不能解引用，也不能递增它。亦可以通过调用<code>std::beign(container)</code>和<code>std::end(contrainer)</code> 获取的迭代器是等价的。</li></ul><p>　不同的算法要求具有不同功能的迭代器，下面由简至繁依次列出不同类别的迭代器：</p><blockquote><ul><li><strong>输入迭代器(input iterators)</strong>提供对对象的只读访问，必须支持表达式<code>*iter</code>以引用它所指向的值，且输入迭代器无减量运算(iter--是错误的)。常用操作(iter++ 、iter1 == iter2、iter1 != iter2)</li><li><strong>输出迭代器(output iterators)</strong> 提供对对象的只写访问，必须支持表达式<code>*iter=new_value</code>,同样其无减量操作</li><li><strong>正向迭代器(forward iterators)</strong>结合了输入和输出迭代器的功能，可以使用多次。</li><li><strong>双向迭代器(bidirectional iterators)</strong>具有和正向迭代器同样的功能，但允许进行前向和后向遍历，一次可以使用减量操作和增量操作</li><li><strong>随机访问迭代器(random access iterators)</strong>提供了和双向迭代器同样的功能，但是能支持对元素的随机访问。同时支持<code>iter+n</code>,<code>iter-n</code>或者直接通过索引访问<code>iter[n]</code>,等同于<code>*(iter+n)</code>,还可通过<code>iter1-iter2</code>获得两个迭代器之间元素的个数。</li></ul></blockquote><ul><li><p>迭代器适配器</p><p>适配器类模板定义了三种不同的迭代器:反向迭代器(reverse iterators)、插入迭代器(insert iterators)和移动迭代器(move iterators)。</p><p>插入迭代器:</p><blockquote><p>后向插入迭代器(back_insert_itreator)通过调用成员函数<code>push_back()</code>将一个新元素添加到容器的尾部。<code>vecotr</code>、<code>list</code>、<code>deque</code>容器具有一个<code>push_back()</code>函数。</p><p>前向插入迭代器(front_insert_iterator)通过调用成员函数<code>push_front()</code>将一个新元素添加到容器的头部。<code>list</code> 、<code>forward_list</code> 、<code>deque</code>容器均有一个<code>push_front()</code>函数</p></blockquote></li></ul></li><li><p>智能指针</p><p>智能指针是一个可以模仿原生指针(指向静态变量或堆上生成的变量)的模板类，主要区别在于：</p><ul><li>智能指针只能用来保存<code>堆</code>上分配的内存的地址。</li><li>不能像对原生指针一样对智能指针进行一些自增或是自减这样的算数运算。</li></ul><p>对于在自由存储区创建的对象，通常使用智能指针而不是原生指针。智能指针的优势是不用担心内存的释放，可以在容器中使用智能指针，如果使用一个类的基类作为智能指针的类型参数，可以用它指向一个派生类对象，这保存了一个对象的指针而不是对象，因而能够保持这个对象的多态性,std明明空间中定义了三种不同类型的智能指针模板：</p><ul><li><p><code>unique_ptr&lt;T&gt;</code>对象就像一个指向类型T的指针，具有排它的特性，不存在多个<code>unique_ptr&lt;T&gt;</code> 指向同一个地址，即一个<code>unique_ptr&lt;T&gt;</code>完全拥有它所指向的内容。可以使用std::move()移出其存储的地址，移出后该<code>unique_ptr&lt;T&gt;</code>变为无效。</p></li><li><p><code>shared_ptr&lt;T&gt;</code>对象和<code>unique_ptr&lt;T&gt;</code>不同的是多个<code>shared_ptr&lt;T&gt;</code>可以指向同一个地址，共享对象的所有权，引用计数保存了指向给定地址的<code>shared_ptr&lt;T&gt;</code>的数量，当引用计数为0时，分配的内存自动释放。</p></li><li><p><code>weak_ptr&lt;T&gt;</code>可以从一个<code>shared_ptr&lt;T&gt;</code>创建，它们指向同一个地址，创建<code>weak_ptr&lt;T&gt;</code>不会增加<code>shared_ptr&lt;T&gt;</code>对象的引用次数，所以其会组织所指向对象的销毁。使用<code>weak_ptr&lt;T&gt;</code>主要原因是为了避免<strong>循环引用</strong>。</p><p><strong>unique_ptr<T></T></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">pname</span><span class="params">(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span> (<span class="string">"Algernon"</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>或者使用<code>memory</code>头文件中函数<code>make_unique&lt;T&gt;()</code>函数来生成<code>unique_ptr&lt;T&gt;</code>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pname = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"Algernon"</span>)</span><br></pre></td></tr></table></figure><p>​ 注意不能以传值的方式将一个<code>unique_ptr&lt;T&gt;</code>对象传入函数中，因为它们不支持拷贝，<strong>必须使用引用的方式</strong>,同时只能通过移动或生成它们的方式，在容器中存放<code>unique_ptr&lt;T&gt;</code>对象。<code>unique_ptr&lt;T&gt;</code>对象析构会释放它所指向对象的内存。在解引用一个指针时，需要先判断其是否为空,<code>if(!pname)</code> 可以将<code>pname</code>隐式转换为布尔型。</p><p>​ 类的<code>get()</code>成员函数可以返回一个<code>unique_ptr&lt;T&gt;</code>所包含的原生指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> pstr &#123;unique_p.<span class="built_in">get</span>()&#125;</span><br></pre></td></tr></table></figure><p><strong>shared_ptr<T></T></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">pdata</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">999.0</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>或者使用<code>memory</code>头文件中函数<code>make_shared&lt;T&gt;()</code>来生成<code>shared_ptr&lt;T&gt;</code>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">double</span>&gt;(<span class="number">999.0</span>);</span><br></pre></td></tr></table></figure><p>使用<code>shared_prt&lt;T&gt;</code>的成员函数<code>get()</code> 可以获得一个原生指针:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pvalue = pdata.<span class="built_in">get</span>() <span class="comment">//return double*</span></span><br></pre></td></tr></table></figure><p>使用<code>reset()</code>函数重置指针,<code>unique()</code>可以查看对象的实例数，<code>use_count()</code>返回当前被调用对象的实例个数</p><p><strong>weak_ptr<T></T></strong></p><p><code>weak_ptr&lt;T&gt;</code>只能由<code>shared_ptr&lt;T&gt;</code>对象或已有的<code>weak_ptr&lt;T&gt;</code>创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata = <span class="built_in">std</span>::make_shared&lt;X&gt;();</span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;X&gt; <span class="title">pwdata</span> <span class="params">(pdata)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;X&gt; <span class="title">pwdata2</span> <span class="params">(pwdata)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>算法</strong></p><p>算法提供了计算和分析的函数，算法通过迭代器访问数据元素。</p><p>将函数作为实参传入另一个函数主要由以下三种方式：</p><ol type="1"><li>使用函数指针。</li><li>传入一个<code>函数对象</code>作为实参</li><li>使用<code>lambda</code>表达式作为形参</li></ol><ul><li><p>函数对象</p><p>函数对象也称仿函数，是重载了函数调用运算符<code>operator()()</code>的类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volume</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x ,<span class="keyword">double</span> y ,<span class="keyword">double</span> z)</span></span>&#123;<span class="keyword">return</span> x*y*z;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Volume volume;<span class="comment">//create a functor</span></span><br><span class="line"><span class="keyword">double</span> room &#123;volume(<span class="number">16</span>,<span class="number">12</span>,<span class="number">8.5</span>)&#125;;</span><br></pre></td></tr></table></figure></li><li><p>lambda表达式</p><p>一个lambda表达式定义了一个匿名函数，lambda可以捕获它们作用域内的变量,然后利用它们.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="keyword">double</span> value) &#123;<span class="keyword">return</span> value*value*value;&#125;</span><br></pre></td></tr></table></figure><p><code>[ ]</code>称为<code>lambda</code>引入符，表示了<code>lambda</code>表达式的开始，内部为捕获列表，引入符后面圆括号<code>()</code>表示了参数列表，与一般函数类似，<code>{}</code>中即为函数主体,值得注意的是示例中并没有具体指定返回类型，返回类型默认由返回值的类型，无返回值则为<code>void</code>，若要指定返回值<code>[](double value)-&gt;double {return value*value*value;}</code></p><p>可以使用变量来保存<code>lambda</code>的地址,然后变量可以当做函数指针使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cube = [](<span class="keyword">double</span> value)&#123;<span class="keyword">return</span> value*value*value;&#125;</span><br><span class="line"><span class="keyword">double</span> x &#123;<span class="number">2.5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">"cubed is: "</span> &lt;&lt; cube(x) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>将lambda表达式传给函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIter,<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(ForwardIter first,ForwoardIter last,F fun)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = first;iter!= last;++iter)</span><br><span class="line">*iter = fun(*iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形参fun接受任意合适的lambda表达式，也接受函数对象或普通的函数指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">change(<span class="built_in">std</span>::<span class="built_in">begin</span>(data),<span class="built_in">std</span>::<span class="built_in">end</span>(data),[] (<span class="keyword">int</span> value)&#123;<span class="keyword">return</span> value*value;&#125;);</span><br></pre></td></tr></table></figure><p>标准库的<code>functional</code>头文件定义了一个模板类型<code>std::function&lt;&gt;</code> ,对任意类型函数指针的封装，又给定的返回类型和形参类型。前面表示lambda表达式的变量可以按如下方式定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span> (<span class="keyword">double</span>)&gt; op = [] (<span class="keyword">double</span> value)&#123;<span class="keyword">return</span> value*value*value;&#125;;</span><br></pre></td></tr></table></figure><p>op现在可以作为实参，传给任意接受函数实参且签名相同的函数。</p><p><strong>捕获列表</strong></p><p><img src="/2020/02/13/sequence-containers/lambda.png"></p><p>默认捕获子句捕获和lambda表达式定义同样范围的所有变量。若<code>[]</code>中有<code>=</code>则为按值传递;若为<code>&amp;</code>则为按引用传递。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 模板类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中的神经网络框架</title>
      <link href="/2020/02/13/apollo-nn/"/>
      <url>/2020/02/13/apollo-nn/</url>
      
        <content type="html"><![CDATA[<h3 id="模型类型">模型类型</h3><p>model_type</p><p><code>modules/perception/inference/inference_factory.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Inference *<span class="title">CreateInferenceByName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;proto_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;weight_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;outputs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;inputs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;model_root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="string">"CaffeNet"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CaffeNet(proto_file, weight_file, outputs, inputs);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"RTNet"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RTNet(proto_file, weight_file, outputs, inputs);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"RTNetInt8"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RTNet(proto_file, weight_file, outputs, inputs, model_root);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"PaddleNet"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PaddleNet(proto_file, weight_file, outputs, inputs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RTNet 表示使用TensorRT加速</p>]]></content>
      
      
      <categories>
          
          <category> Apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apollo </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中can卡配置</title>
      <link href="/2020/02/08/can-conf/"/>
      <url>/2020/02/08/can-conf/</url>
      
        <content type="html"><![CDATA[<p>apollo开源框架中can卡的配置 <a id="more"></a></p><p>[TOC]</p><h3 id="前置内容">1. 前置内容</h3><p>本文主要参考：https://zhuanlan.zhihu.com/p/61838008</p><p>Apollo 在车辆的信息交互和车辆配置上均使用了<code>Protobuf</code></p><blockquote><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener" title="protobuf 相关介绍">[1]</a></p></blockquote><p>通常车企采用DBC文件完成CAN信号的定义和解析,由于Apollo中采用了Protobuf进行模块间的通信和配置，因此车企需要使用Apollo提供的工具基于DBC生成Apollo可用的proto文件。</p><blockquote><p>DBC文件是用来描述CAN网络通信信号的一种格式文件。</p></blockquote><p>一般各车厂DBC文件的定义不同并严格保密，为了解决无人驾驶系统中与车辆交互的问题，Apollo搭建了《开放汽车认证平台》，由此，方便无人驾驶的车辆部署，<code>ApolloAuto/apollo/tree/master/modules/canbus/vehicle</code> 中有目前支持的参考车辆目录。新增车辆需要新建一个目录以及对应的文件，通过工具可基于DBC文件快速生成Apollo参考车辆适配层模板， <span id="jump">工具</span>位于<code>ApolloAuto/apollo/tree/master/modules/tools/gen_vehicle_protocol</code> 下，使用方法参考<code>readme</code>。<a href="http://apollo.auto/docs/procedure_cn.html" target="_blank" rel="noopener" title="针对车辆CAN DBC文件如何生成proto文件">[3]</a></p><blockquote><p>该平台作为软硬件中间层，提出了开放车辆接口标准，定义了系统与车辆的线控接口，负责完成系统与汽车的具体交互，同时该平台抽象出了与车型无关的信号作为上层算法模块的输入，使得上层平台可以与底层车辆解耦。</p><p>具体线控需求规范可参考：https://link.zhihu.com/?target=http%3A//apollo-homepage.bj.bcebos.com/Apollo_by_wire_requirement.xlsx</p></blockquote><h3 id="apollo-cancard参数配置文件">2. Apollo Cancard参数配置文件</h3><h4 id="apollo-中采用proto文件管理相关配置">2.1 apollo 中采用proto文件管理相关配置</h4><p>apollo 激活车辆的配置文件的相关路径为<code>modules/canbus/conf/canbusconf.pb.txt</code>, 可在该文件中定义<strong>车型</strong>及对应的CAN card参数.</p><ul><li>apollo 中相关算法默认车辆是Lincoln MKZ ,如何置换或添加新的车辆到Apollo中可参考文档：<code>apollo/docs/howto/hwo_to_add_a_new_vehicle.md</code> <span id="newvehicle">  </span></li></ul><blockquote><ul><li>Implement the new vehicle controller :<code>class NewVehicleController final : public VehicleController{...}</code></li><li>Implement the new message manager：<code>class NewVehicleMessageManager : public MessageManager {...}</code></li><li>Implement the new vehicle factory:<code>class NewVehicleFactory : public AbstractVehicleFactory {...}</code></li><li>Register the New Vehicle:<code>void VehicleFactory::RegisterVehicleFactory(){...}</code></li><li>Update the configuration file: <code>vehicle_parameter{...}</code> 这就是下面要描述的。</li></ul></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vehicle_parameter &#123;</span><br><span class="line">  brand: LINCOLN_MKZ <span class="comment">//车型 该参数决定了车辆的相关标定参数</span></span><br><span class="line">  max_enable_fail_attempt: <span class="number">5</span> </span><br><span class="line">  driving_mode: COMPLETE_AUTO_DRIVE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">can_card_parameter &#123;</span><br><span class="line">  brand: ESD_CAN <span class="comment">//CAN卡通信方式，还有比如socket类型</span></span><br><span class="line">  type: PCI_CARD <span class="comment">//Can卡类型，还有比如USB_CARD</span></span><br><span class="line">  channel_id: CHANNEL_ID_ZERO </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enable_debug_mode: <span class="literal">false</span></span><br><span class="line">enable_receiver_log: <span class="literal">false</span></span><br><span class="line">enable_sender_log: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上述参数配置文件的参数含义由下面的<code>proto</code> 文件决定：</p><ul><li><code>modules/canbus/proto/canbus_conf.proto</code></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.canbus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/drivers/canbus/proto/can_card_parameter.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/canbus/proto/vehicle_parameter.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CanbusConf</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> VehicleParameter vehicle_parameter = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> apollo.drivers.canbus.CANCardParameter can_card_parameter = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> enable_debug_mode = <span class="number">3</span> [default = <span class="literal">false</span>];</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> enable_receiver_log = <span class="number">4</span> [default = <span class="literal">false</span>];</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> enable_sender_log = <span class="number">5</span> [default = <span class="literal">false</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p><code>modules/canbus/proto/vehicle_parameter.proto</code></p><p>该文件中定义了车辆的相关参数</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.canbus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/canbus/proto/chassis.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/common/configs/proto/vehicle_config.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">VehicleParameter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> apollo.common.VehicleBrand brand = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> max_engine_pedal = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> max_enable_fail_attempt = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">optional</span> Chassis.DrivingMode driving_mode = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细各文件内容此处略去不表，<code>VehicleBrand</code> 表示apollo支持的车辆品牌,目前有<code>LINCOLN_MKZ、GEM、LEXUS、TRANSIT、GE3、WEY、ZHONGYUN、CH</code></p><hr><ul><li><p><code>modules/drivers/canbus/proto/can_card_parameter.proto</code></p><p>该文件中定义了cancard的三个相关参数定义</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.drivers.canbus;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CANCardParameter</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">CANCardBrand</span> </span>&#123;</span><br><span class="line">    FAKE_CAN = <span class="number">0</span>;</span><br><span class="line">    ESD_CAN = <span class="number">1</span>;</span><br><span class="line">    SOCKET_CAN_RAW = <span class="number">2</span>;</span><br><span class="line">    HERMES_CAN = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">CANCardType</span> </span>&#123;</span><br><span class="line">    PCI_CARD = <span class="number">0</span>;</span><br><span class="line">    USB_CARD = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">CANChannelId</span> </span>&#123;</span><br><span class="line">    CHANNEL_ID_ZERO = <span class="number">0</span>;</span><br><span class="line">    CHANNEL_ID_ONE = <span class="number">1</span>;</span><br><span class="line">    CHANNEL_ID_TWO = <span class="number">2</span>;</span><br><span class="line">    CHANNEL_ID_THREE = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> CANCardBrand brand = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> CANCardType type = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> CANChannelId channel_id = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="信号交互">2.2 信号交互</h4><p>通常车企采用DBC文件完成CAN信号的定义和解析，Apollo则大量使用了Protobuf来进行模块间的通信和配置，因此车企需要通过Apollo提供的<a href="#jump">工具</a>基于DBC来生成Apollo可用<code>Proto</code>文件：以<u>广汽传祺GE3 开发者版</u> 为例</p><p><code>modules/canbus/proto/ge3.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.canbus;</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Ge3</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> Pc_bcm_201 pc_bcm_201 = <span class="number">1</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcs_3_308 scu_bcs_3_308 = <span class="number">2</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_epb_203 pc_epb_203 = <span class="number">3</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_bcs_202 pc_bcs_202 = <span class="number">4</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_vcu_205 pc_vcu_205 = <span class="number">5</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_eps_204 pc_eps_204 = <span class="number">6</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_vcu_2_313 scu_vcu_2_313 = <span class="number">7</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_1_301 scu_1_301 = <span class="number">8</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_2_302 scu_2_302 = <span class="number">9</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_3_303 scu_3_303 = <span class="number">10</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcm_304 scu_bcm_304 = <span class="number">11</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcs_1_306 scu_bcs_1_306 = <span class="number">12</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcs_2_307 scu_bcs_2_307 = <span class="number">13</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_epb_310 scu_epb_310 = <span class="number">14</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_vcu_1_312 scu_vcu_1_312 = <span class="number">15</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_eps_311 scu_eps_311 = <span class="number">16</span>; <span class="comment">// report message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="车辆配置">2.3 车辆配置</h4><p>Protobuf 提供了名为<code>TextFormat</code> 的序列化格式（该格式可读性强，类似于Json），配合事先定义的Proto文件，开发者可以轻易实现从可读的配置文件到具体对象的实力的反射，配置文件经过反序列化后可以作为业务代码类的输入，这种方式使得配置更加便捷，具有很好的向后兼容性。</p><p>Apollo 中大量采用了这种方式管理配置，Apollo激活车辆的配置文件为<code>modules/canbus/conf/canbus_conf.pb.txt</code> ,开发者可以再次定义车型以及对应的CAN card的参数，例如只需修改<code>vehicle_parameter</code> 相对应的字段，即可使Apollo支持相应的车型。</p><hr><h3 id="代码实现">3 代码实现</h3><h4 id="canbus模块">3.1 Canbus模块</h4><p>软件实现上，Apollo通过<code>CANBus</code> 模块来实现对车辆的管理和通讯。</p><p><code>CANBus</code> 模块接收并执行来自Contorl模块的指令，同时收集汽车底盘的状态（由Apollo抽象出的一组与车型无关的信号）。<code>CANBus</code> 模块处理这些状态与各个汽车底盘信号的映射关系，随后将这些状态反馈回<code>Control</code>模块，以此兼容不容车型。</p><figure><img src="/2020/02/08/can-conf/Apollo_3_5_software_architecture.png" alt="img"><figcaption>img</figcaption></figure><p><code>modules/canbus/proto/chassis.proto</code> 对Apollo抽象出的信号进行了定义，大体包括以下信息：</p><blockquote><p>DrivingMode: COMPLETE_MANUAL、COMPLETE_AUTO_DRIVE 、...</p><p>ErrorCode(错误码): 控制指令周期不准、底盘转向错误、人工接管</p><p>GearPosition(档位): 前进、后退、驻停等</p><p>底盘信息：车速、转速、油门、里程计</p><p>Gps</p><p>轮速</p></blockquote><p><code>CANBus</code> 模块主要由以下两个部件组成：</p><blockquote><p>Vehicle: the vehicle itself,including its controller and message manager</p><p>CAN Client: CAN client has been moved to <code>/modules/drivers/canbus</code> since it is shared by different sensors utilizing the canbus protocol <a href="https://github.com/ApolloAuto/apollo/tree/master/modules/canbus" target="_blank" rel="noopener" title="canbus">[4]</a></p></blockquote><p>针对<code>Vehicle</code>部分进行着重介绍： - <code>Vehicle</code>的Controller（<code>modules/cnabus/vehicle/vehicle_controller.h</code>）类图如下（简化）:</p><figure><img src="/2020/02/08/can-conf/vehiclecontroller.png" alt="vehicleController"><figcaption>vehicleController</figcaption></figure><p><code>Vehicle Controller</code> 类负责完成与汽车底盘的具体交互，以下为部分接口说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief start the vehicle controller. 注：干函数会在内部起一个名为”SecurityDogThread-Func“ 的线程</span></span><br><span class="line"><span class="comment"> * 该线程会周期性检查与底盘的通讯状况，关键信号是否相应，是否有错误等</span></span><br><span class="line"><span class="comment"> * @return true if successfully started.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Start</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief stop the vehicle controller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief calculate and return the chassis.</span></span><br><span class="line"><span class="comment"> * 注：该函数完成了汽车底盘信号和Apollo内部定义的底盘状态信号的映射</span></span><br><span class="line"><span class="comment"> * @returns a copy of chassis. Use copy here to avoid multi-thread issues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Chassis <span class="title">chassis</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief update the vehicle controller.</span></span><br><span class="line"><span class="comment"> * 该函数用于执行来自Control模块的具体指令，根据指令要求和汽车目前所处的模式(完全自动、完全手动等)来为执行器的信号(档位、油门、转向)进行赋值</span></span><br><span class="line"><span class="comment"> * @param command the control command</span></span><br><span class="line"><span class="comment"> * @return error_code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> common::ErrorCode <span class="title">Update</span><span class="params">(<span class="keyword">const</span> control::ControlCommand &amp;command)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>Vehicle的<code>MessageManger</code>类负责完成具体对信号的接收、发送、解析等。</p><p>其类图<code>modules/drivers/canbus/can_common/message_manager.h</code>如下</p><figure><img src="/2020/02/08/can-conf/messagemanager.png" alt="MessageManager Class"><figcaption>MessageManager Class</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于指定系统接收的信号</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SensorType&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">bool</span> <span class="title">need_check</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MessageManager</span>&lt;SensorType&gt;:</span>:AddRecvProtocolData() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于指定系统向汽车底盘发送的控制信号</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SensorType&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">bool</span> <span class="title">need_check</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MessageManager</span>&lt;SensorType&gt;:</span>:AddSendProtocolData() &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p>以<code>ge3</code> 车型为例，<code>ge3</code> 文件夹下包含如下文件：</p><figure><img src="/2020/02/08/can-conf/ge3file.png" alt="ge3-file"><figcaption>ge3-file</figcaption></figure><p>根据Apollo的官方文件<code>how_to_add_a_new_vehicle</code> 想为Apollo添加<code>ge3</code> 车型需要完成以下<a href="#newvehicle">内容</a>：</p><blockquote><ul><li><p>实现新的车辆控制器--<code>ge3_controller.cc</code>,继承<code>VehicleController</code> 类</p></li><li><p>实现新的消息管理器-- ge3_message_manager.cc ,继承<code>MessageManager</code> 类</p></li><li><p>实现新的车辆工厂类 -- ge3_vehicle_factory.cc ,继承<code>AbstractVehicleFactory</code> 类</p></li><li><p>更新配置文件</p><ul><li><p>在<code>modules/canbus/vehicle/vehicle_factory.cc</code> 中进行注册</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Register(apollo::common::GE3, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Ge3VehicleFactory();</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>更新配置文件<code>modules/canbus/conf/canbus_conf.pb.txt</code></p></li></ul></li></ul></blockquote></li></ul></li></ul><h4 id="canbus工厂模式">3.2 CANBus工厂模式</h4><p>通过上述方法能够增加新车型的原因在于Apollo的配置基于<code>工厂模型</code> （参见另一篇文章）实现的。</p><blockquote><p>工厂方法模式（Factory method pattern）是一种实现了“工厂”概念的<code>面向对象设计模式</code> 。就像其他<code>创建型模式</code>一样，它也是处理在不指定<code>对象</code>具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个<code>类</code> ”。工厂方法让类的实例化推迟到子类中进行。<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#cite_note-1(https://zh.wikipedia.org/wiki/工厂方法#cite_note-1)" target="_blank" rel="noopener">[5]</a></p></blockquote><p>CANBus模块中Vehicle相关的内容使用工厂模式抽象出了<code>VehicleController</code>,<code>MessageManager</code>,<code>AbstractVehicleFactory</code> 三个接口。CANBus的<strong>业务</strong>代码(<code>canbus_component.cc</code>) 通过以上接口来操纵具体的对象，用户无需关心具体的对象是什么，从而实现了业务逻辑和目标对象的解耦。</p><p>在Canbus模块中，工厂类为&quot;VehicleFactory&quot;,继承于工厂模板&quot;Factory&quot;。&quot;VehicleFactory&quot;工厂维护了键值对为“VehicleParameter::VechileBrand”和&quot;AbstractVehicleFactory&quot;的Map。</p><p>如下所示，每新注册注册一种车型，该Map中就会插入一条汽车品牌(VehicleBrand)和该品牌汽车生产工厂(AbstractVehicleFactory)的键值对。(ProductCreator 采用Lambda 表达式)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VehicleFactory::RegisterVehicleFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Register(apollo::common::LINCOLN_MKZ, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LincolnVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::GEM, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GemVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::LEXUS, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LexusVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::TRANSIT, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TransitVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::GE3, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ge3VehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::WEY, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeyVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::ZHONGYUN, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZhongyunVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::CH,</span><br><span class="line">           []() -&gt; AbstractVehicleFactory * &#123; <span class="keyword">return</span> <span class="keyword">new</span> ChVehicleFactory(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当VehicleFactory类的<code>CreateVehicle</code>方法被调用时，&quot;VehicleFactory&quot;会根据输入的汽车品牌，在Map中查找并返回可以生产这种汽车的工厂。</p><p>例如输入汽车品牌为<code>GE3</code> ，&quot;VehicleFactory&quot;会返回<code>Ge3VehicleFactory</code> ,<code>Ge3VehicleFactory</code>继承于<code>AbstractVehicleFactory</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Creates an AbstractVehicleFactory object based on vehicle_parameter</span></span><br><span class="line"><span class="comment"> * @param vehicle_parameter is defined in vehicle_parameter.proto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AbstractVehicleFactory&gt; <span class="title">CreateVehicle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> VehicleParameter &amp;vehicle_parameter)</span></span>;</span><br></pre></td></tr></table></figure><p><code>AbstractVehicleFactory</code> 工厂会产出一组适用于该品牌车型的产品即<code>MessageManager</code>和<code>Vehiclecontroller</code></p><p><code>modules/canbus/vehicle/ge3/ge3_vehicle_factory.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VehicleController&gt;</span><br><span class="line">Ge3VehicleFactory::CreateVehicleController() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VehicleController&gt;(<span class="keyword">new</span> ge3::Ge3Controller());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageManager&lt;::apollo::canbus::ChassisDetail&gt;&gt;</span><br><span class="line">Ge3VehicleFactory::CreateMessageManager() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageManager&lt;::apollo::canbus::ChassisDetail&gt;&gt;(</span><br><span class="line">      <span class="keyword">new</span> ge3::Ge3MessageManager());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ge3VehicleFactory</code> 最终会生产处一组适用于该品牌车型的产品，即<code>VehicleController</code> 和 <code>MessageManager</code></p><h3 id="canbus组件">4.Canbus组件</h3><p>​ 最后介绍CANBus模块的CanbusComponent，该类继承于<code>apollo::cyber::TimerComponent</code> ，主要作用是处理来自控制模块的控制指令，并将信号消息发送至CAN card。</p><p>​ CanbusComponent 的初始化函数（Init）主要完成以下工作：</p><ol type="1"><li><p>读取Canbus配置文件</p><p><code>modules/canbus/conf/canbusconf.pb.txt</code></p><p><code>modules/canbus/proto/canbus_conf.proto</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!GetProtoConfig(&amp;canbus_conf_)) &#123;</span><br><span class="line">  AERROR &lt;&lt; <span class="string">"Unable to load canbus conf file: "</span> &lt;&lt; ConfigFilePath();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据配置文件初始化<code>Can-client</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can_client_ = can_factory-&gt;CreateCANClient(canbus_conf_.can_card_parameter());</span><br></pre></td></tr></table></figure></li><li><p>根据配置文件获取汽车工厂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VehicleFactory vehicle_factory;</span><br><span class="line">  vehicle_factory.RegisterVehicleFactory();</span><br><span class="line">  <span class="keyword">auto</span> vehicle_object =</span><br><span class="line">      vehicle_factory.CreateVehicle(canbus_conf_.vehicle_parameter());</span><br></pre></td></tr></table></figure></li><li><p>获取该汽车工厂生产的<code>message_manager</code> 和 <code>Vehicle_controller</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message_manager_ = vehicle_object-&gt;CreateMessageManager();</span><br><span class="line"><span class="keyword">if</span> (can_receiver_.Init(can_client_.<span class="built_in">get</span>(), message_manager_.<span class="built_in">get</span>(),</span><br><span class="line">                         canbus_conf_.enable_receiver_log()) != ErrorCode::OK) &#123;...&#125;</span><br><span class="line"><span class="keyword">if</span> (can_sender_.Init(can_client_.<span class="built_in">get</span>(), canbus_conf_.enable_sender_log()) !=</span><br><span class="line">      ErrorCode::OK) &#123;...&#125;</span><br><span class="line">vehicle_controller_ = vehicle_object-&gt;CreateVehicleController();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>使能Can收发和<code>Vehicle_controller</code></p><p>初始化完成后，<code>CanbusComponent</code> 会周期性的报告车身状态，并执行来自<code>Control</code> 模块和<code>Guardian</code>模块的指令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanbusComponent::Proc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PublishChassis();</span><br><span class="line">  <span class="keyword">if</span> (FLAGS_enable_chassis_detail_pub) &#123;</span><br><span class="line">    PublishChassisDetail();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="comment">//周期性执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//事件触发，Reader回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanbusComponent::OnControlCommand</span><span class="params">(<span class="keyword">const</span> ControlCommand &amp;control_command)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanbusComponent::OnGuardianCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> GuardianCommand &amp;guardian_command)</span> </span>&#123;</span><br><span class="line">  apollo::control::ControlCommand control_command;</span><br><span class="line">  control_command.CopyFrom(guardian_command.control_command());</span><br><span class="line">  OnControlCommand(control_command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="参考链接">参考链接</h3><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener" title="protobuf 相关介绍">1</a> https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html protobuf 相关介绍</p><p><a href="https://zhuanlan.zhihu.com/p/61838008" target="_blank" rel="noopener" title="本文主要参考文章">2</a> https://zhuanlan.zhihu.com/p/61838008 本文主要参考文章</p><p><a href="http://apollo.auto/docs/procedure_cn.html" target="_blank" rel="noopener" title="针对车辆CAN DBC文件如何生成proto文件">3</a> http://apollo.auto/docs/procedure_cn.html 针对车辆CAN DBC文件如何生成proto文件</p><p><a href="https://github.com/ApolloAuto/apollo/tree/master/modules/canbus" target="_blank" rel="noopener" title="canbus">4</a> https://github.com/ApolloAuto/apollo/tree/master/modules/canbus &quot;canbus&quot;</p><p><a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#cite_note-1(https://zh.wikipedia.org/wiki/工厂方法#cite_note-1)" target="_blank" rel="noopener">5</a> https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#cite_note-1(https://zh.wikipedia.org/wiki/工厂方法#cite_note-1)</p><p>[6] https://zhuanlan.zhihu.com/p/61838008</p></blockquote><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人驾驶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo工厂模式解析</title>
      <link href="/2020/02/07/factory-mode/"/>
      <url>/2020/02/07/factory-mode/</url>
      
        <content type="html"><![CDATA[<p>apollo 中工厂模式相关知识介绍 <a id="more"></a></p><p>[TOC]</p><p>本文主要参考：<a href="https://blog.csdn.net/davidhopper/article/details/79197075" target="_blank" rel="noopener" class="uri">https://blog.csdn.net/davidhopper/article/details/79197075</a></p><p>工厂模式的定义和实现相关资料可参考：</p><blockquote><ul><li><a href="https://zh.wikipedia.org/wiki/工厂方法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95</a></li><li>《设计模式：可复用面向对象软件的基础》</li></ul></blockquote><h3 id="apollo-对象的创建方式">1. Apollo 对象的创建方式</h3><p>基本由 栈创建对象、堆创建对象、单例模式创建对象、工厂模式创建对象</p><p>Apollo项目中对象的创建，大多使用直接法，例如：</p><ul><li><p>//在栈(stack)上直接创建对象</p><p>ADCTrajectory not_ready_pb;</p></li><li><p>//在堆(heap)上直接创建对象</p><p>ZeroCopyOutputStream *output = new FileOutputStream(file_descriptor);</p></li></ul><blockquote><p>堆和栈的主要区别在于 <code>生命周期</code> 和 <code>性能</code> 由于栈的特性，栈上的对象不需要手动管理内存，而堆由程序员自行负责何时用delete释放内存，动态内存的生命周期由我们决定更加灵活。</p></blockquote><ul><li>还有部分通过<code>单例模式</code>创建：<code>DECLARE_SINGLETON(CanClientFactory)</code> ,其定义如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SINGLETON(classname)                                      \</span></span><br><span class="line"> <span class="keyword">public</span>:                                                                  \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> classname *<span class="title">Instance</span><span class="params">(<span class="keyword">bool</span> create_if_needed = <span class="literal">true</span>)</span> </span>&#123;              \</span><br><span class="line">    <span class="keyword">static</span> classname *instance = <span class="literal">nullptr</span>;                                 \</span><br><span class="line">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">std</span>::once_flag flag;                                         \</span><br><span class="line">      <span class="built_in">std</span>::call_once(flag,                                                \</span><br><span class="line">                     [&amp;] &#123; instance = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) classname(); &#125;); \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">    <span class="keyword">return</span> instance;                                                      \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CleanUp</span><span class="params">()</span> </span>&#123;                                                 \</span><br><span class="line">    <span class="keyword">auto</span> instance = Instance(<span class="literal">false</span>);                                      \</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">nullptr</span>) &#123;                                            \</span><br><span class="line">      CallShutdown(instance);                                             \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line"> <span class="keyword">private</span>:                                                                 \</span><br><span class="line">  classname();                                                            \</span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(classname)</span><br></pre></td></tr></table></figure><p>​ 其中内嵌宏 <code>DISALLOW_COPY_AND_ASSIGN(classname)</code>的定义如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line">  classname(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;    \</span><br><span class="line">  classname &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure> ​ 因此：<code>DECLARE_SINGLETON(CanClientFactory)</code> 展开后的定义为： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SINGLETON(CanClientFactory)                                      \</span></span><br><span class="line"> <span class="keyword">public</span>:                                                                  \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> CanClientFactory *<span class="title">Instance</span><span class="params">(<span class="keyword">bool</span> create_if_needed = <span class="literal">true</span>)</span> </span>&#123;              \</span><br><span class="line">    <span class="keyword">static</span> CanClientFactory *instance = <span class="literal">nullptr</span>;                                 \</span><br><span class="line">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">std</span>::once_flag flag;                                         \</span><br><span class="line">      <span class="built_in">std</span>::call_once(flag,                                                \</span><br><span class="line">                     [&amp;] &#123; instance = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) CanClientFactory(); &#125;); \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">    <span class="keyword">return</span> instance;                                                      \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CleanUp</span><span class="params">()</span> </span>&#123;                                                 \</span><br><span class="line">    <span class="keyword">auto</span> instance = Instance(<span class="literal">false</span>);                                      \</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">nullptr</span>) &#123;                                            \</span><br><span class="line">      CallShutdown(instance);                                             \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line"> <span class="keyword">private</span>:                                                                 \</span><br><span class="line">  CanClientFactory();                                                            \</span><br><span class="line">  CanClientFactory(<span class="keyword">const</span> CanClientFactory &amp;) = <span class="keyword">delete</span>;    \</span><br><span class="line">  CanClientFactory &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CanClientFactory &amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></p><p>​ 上述代码的意义，首先定义一个静态公有函数Instance(),该函数在栈上创建一个<code>CanClientFactory</code> 类的静态对象，然后返回该对象指针。同时，将<code>CanClientFactory</code> 类的默认构造函数、复制（或称拷贝）构造函数、复制赋值运算符（或称操作符）定义为私有（private）函数，即禁止进行隐式类型转换和复制操作。<strong>单例模式保证一个类只有一个实例，并提供一个访问它的全局访问点，即通过静态指针来指向此唯一实例</strong></p><blockquote><p>c++中的static关键词可以用于修改局部变量，函数，类的数据成员以及对象。</p><p>​ 静态局部变量只初始化一次，然后每次函数调用时保持其值。</p><p>​ 静态成员函数可以直接用类来调用，不需要创建实例来调用。</p><p>静态对象：<code>static Test t1；</code></p><p>​ 静态对象只初始化一次，并且在整个程序的生命周期中都存在，静态对象保存在静态存储区，在程序结束时销毁。</p></blockquote><ul><li><p>还有部分对象通过工厂模式创建对象，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class VehicleFactory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief This class is a factory class that will generate different</span></span><br><span class="line"><span class="comment"> * vehicle factories based on the vehicle brand.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> common::util::Factory&lt;apollo::common::VehicleBrand,</span><br><span class="line">                                   AbstractVehicleFactory&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief register supported vehicle factories.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RegisterVehicleFactory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Creates an AbstractVehicleFactory object based on vehicle_parameter</span></span><br><span class="line"><span class="comment">   * @param vehicle_parameter is defined in vehicle_parameter.proto</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AbstractVehicleFactory&gt; <span class="title">CreateVehicle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> VehicleParameter &amp;vehicle_parameter)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于工厂模式的介绍，可以参考：下面简单介绍</p><p>[https://blog.csdn.net/linwh8/article/details/51232834][https://blog.csdn.net/linwh8/article/details/51232834]</p><p>[https://www.runoob.com/design-pattern/abstract-factory-pattern.html][https://www.runoob.com/design-pattern/abstract-factory-pattern.html]</p></li></ul><h3 id="浅谈工厂模式">2. 浅谈工厂模式</h3><p><img src="/2020/02/07/factory-mode/factorymode.png"></p><p>首先<code>ProductFactory</code>可以想象为生产某种产品（抽象类产品）的某类工厂（抽象类工厂），此抽象类工厂演变出许多实例化对象，即为实际的工厂（工厂实例化对象）：<code>ConcreteProductFactoryA,ConcreteProductFactoryB</code> ,而这两个<strong>实例化工厂</strong>生产的内容与抽象工厂定义的内容一致，即包含一个抽象类product。</p><p>然后<code>Product</code>某种产品（抽象类产品），它能演变出许多实例化对象:<code>ConcreteProductA,ConcreteProductB</code> ,也就是上面的实例化工厂都能生产A、B两种产品。</p><p>举个栗子：</p><p>现在由生产口罩的工厂（抽象类工厂）：工厂A(工厂实例化对象)，工厂B(工厂实例化对象)。这两个工厂都生产口罩（抽象类产品）：KN95口罩（产品实例化对象）、一次性医用口罩(产品实例化对象)。</p><h3 id="apollo项目工厂模式分析">3.Apollo项目工厂模式分析</h3><p>​ Apollo采用的是抽象工厂模式，因为该项目使用模板定义工厂类，因此工厂模式经典定义中的抽象工厂类不再需要，Apollo提供了一个工厂模板(<code>modules/common/util/factory.h</code>) ,该模板可支持任何类型的输入，类图如下：</p><p><img src="/2020/02/07/factory-mode/ApolloFactory.png"></p><blockquote><p>Factory类中包含了<code>Register()</code>、<code>Unregister()</code> 、<code>Empty()</code>、<code>CreateObjectOrNull()</code>、<code>CreateObject()</code> 等公有函数，其中<code>Register()</code> 、<code>Unregister()</code>函数用于注册和反注册产品类，其作用与经典模式中抽象工厂接口类的功能类似，<code>Empty()</code> 函数用于判断当前工厂类中是否包含产品创建函数，<code>CreateObjectOrNull()</code>、<code>CreateObject()</code> 函数用于创建可能包含空指针和不包含空指针的产品类对象。</p></blockquote><p>​ Factory工厂模板维护了一个Map用来管理<code>IdentifierType</code>和<code>ProductCreator</code>的键值对，根据输入的<code>IdentifierType</code>,模板可以返回<code>ProductCreator</code>生产的产品，从而实现了从<code>IdentifierType</code>到<code>Productde</code> &quot;映射&quot;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IdentifierType, <span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">ProductCreator</span> = <span class="title">AbstractProduct</span> *(*)(),</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">MapContainer</span> = <span class="title">std</span>:</span>:<span class="built_in">map</span>&lt;IdentifierType, ProductCreator&gt;&gt;</span><br></pre></td></tr></table></figure><p>Factory类模板中参数<code>ProductCreator=AbstractProduct*（*）()</code> 全部采用简洁的Lambda表达式实现</p><blockquote><p>lambda 表达式：</p><p>完整格式声明：<code>[capture list] (params list) mutable exception-&gt; return type { function body }</code></p><p>capture list:捕获外部变量列表 params list:形参列表 exception:异常设定（一般省略）</p></blockquote><p>Apollo项目中对Factory类实例化的情形包括但不限于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> common::util::Factory&lt;apollo::common::VehicleBrand,</span><br><span class="line">                                   AbstractVehicleFactory&gt;&#123;<span class="comment">/*.../*&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanClientFactory</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> apollo::common::util::Factory&lt;CANCardParameter::CANCardBrand,</span><br><span class="line">                                           CanClient&gt; &#123;<span class="comment">/*.../*&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apollo::common::util::Factory&lt;TaskConfig::TaskType, NaviTask&gt; task_factory_;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common::util::Factory&lt;PlannerType, Planner&gt; planner_factory_</span><br></pre></td></tr></table></figure><p>注册产品类代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NaviPlanner::RegisterTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  task_factory_.Register(TaskConfig::NAVI_PATH_DECIDER,</span><br><span class="line">                         []() -&gt; NaviTask* &#123; <span class="keyword">return</span> <span class="keyword">new</span> NaviPathDecider(); &#125;);</span><br><span class="line">  task_factory_.Register(TaskConfig::NAVI_SPEED_DECIDER,</span><br><span class="line">                         []() -&gt; NaviTask* &#123; <span class="keyword">return</span> <span class="keyword">new</span> NaviSpeedDecider(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的产品创建函数<code>ProductCreator=AbstractProduct*（*）()</code> 采用Lambda表达式实现。</p><p>创建具体的产品类对象的代码为:</p><p><code>modules/planning/planner/navi/navi_planner.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NaviPlanner::Init</span><span class="params">(<span class="keyword">const</span> PlanningConfig&amp; <span class="built_in">config</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// NaviPlanner is only used in navigation mode based on the real-time relative</span></span><br><span class="line">  <span class="comment">// map.</span></span><br><span class="line">  <span class="keyword">if</span> (!FLAGS_use_navigation_mode) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">"NaviPlanner is only used in navigation mode."</span>;</span><br><span class="line">    AERROR &lt;&lt; msg;</span><br><span class="line">    <span class="keyword">return</span> Status(ErrorCode::PLANNING_ERROR, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AINFO &lt;&lt; <span class="string">"In NaviPlanner::Init()"</span>;</span><br><span class="line">  RegisterTasks();</span><br><span class="line">  PlannerNaviConfig planner_conf =</span><br><span class="line">      <span class="built_in">config</span>.navigation_planning_config().planner_navi_config();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> task : planner_conf.task()) &#123;</span><br><span class="line">    tasks_.emplace_back(</span><br><span class="line">        task_factory_.CreateObject(<span class="keyword">static_cast</span>&lt;TaskConfig::TaskType&gt;(task)));</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Created task:"</span> &lt;&lt; tasks_.back()-&gt;Name();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; task : tasks_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!task-&gt;Init(<span class="built_in">config</span>)) &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">msg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          common::util::StrCat(<span class="string">"Init task["</span>, task-&gt;Name(), <span class="string">"] failed."</span>))</span></span>;</span><br><span class="line">      AERROR &lt;&lt; msg;</span><br><span class="line">      <span class="keyword">return</span> Status(ErrorCode::PLANNING_ERROR, msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件为：<code>modules/planning/conf/planning_config_navi.pb.txt</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">planner_type : NAVI</span><br><span class="line">planner_navi_config &#123;</span><br><span class="line">  task : NAVI_PATH_DECIDER</span><br><span class="line">  task : NAVI_SPEED_DECIDER</span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>上述配置文件表明，<code>NaviPlanner</code>类动态生成了<code>NAVI_PATH_DECIDER</code> 、<code>NAVI_SPEED_DECIDER</code> 任务对象。</p>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo InternalProc 感知处理流程</title>
      <link href="/2020/02/07/Apollo-IntenalProc/"/>
      <url>/2020/02/07/Apollo-IntenalProc/</url>
      
        <content type="html"><![CDATA[<p>Apollo 总体感知算法处理流程</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> 感知 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo回调函数概览</title>
      <link href="/2020/02/06/OnReceiveImages/"/>
      <url>/2020/02/06/OnReceiveImages/</url>
      
        <content type="html"><![CDATA[<h3 id="一onreceiveimages内部函数处理流程">一、OnReceiveImages()内部函数处理流程:</h3><a id="more"></a><ol type="1"><li>由FusionCameraDetectionComponent::Init()中的InitCameraListeners()创建回调函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FusionCameraDetectionComponent::OnReceiveImage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image&gt; &amp;message,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;camera_name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>函数参数说明：</p><blockquote><p>apollo::drivers::Image类包含：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> frame_id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> measurement_time = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> height = <span class="number">4</span>;  <span class="comment">// image height, that is, number of rows</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> width = <span class="number">5</span>;   <span class="comment">// image width, that is, number of columns</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> encoding = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> step = <span class="number">7</span>;  <span class="comment">// Full row length in bytes</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bytes</span> data = <span class="number">8</span>;   <span class="comment">// actual matrix data, size is (step * rows)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该消息类型文件定义：<code>modules/drivers/proto/sensor_image.proto</code></p></blockquote><blockquote><p><code>std::string &amp;camera_name</code> 包含两类：</p><ul><li>front_6mm</li><li>front_12mm</li></ul></blockquote><ol start="2" type="1"><li>进行TimeStamp的判断之后：</li></ol><ul><li><p>创建<code>apollo::perception::PerceptionObstacles</code> 对象<em><code>out_message</code></em></p><blockquote><p>类定义位于modules/perception/proto/perception_obstacle.proto</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PerceptionObstacles</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> PerceptionObstacle perception_obstacle = <span class="number">1</span>;  <span class="comment">// An array of obstacles</span></span><br><span class="line">  <span class="keyword">optional</span> common.Header header = <span class="number">2</span>;                    <span class="comment">// Header</span></span><br><span class="line">  <span class="keyword">optional</span> common.ErrorCode error_code = <span class="number">3</span> [default = OK];</span><br><span class="line">  <span class="keyword">optional</span> LaneMarkers lane_marker = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">optional</span> CIPVInfo cipv_info = <span class="number">5</span>;  <span class="comment">// Closest In Path Vehicle (CIPV)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>创建<code>SensorFrameMessage</code> 类对象<em><code>prefused_message</code></em></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorFrameMessage</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SensorFrameMessage() &#123; type_name_ = <span class="string">"SensorFrameMessage"</span>; &#125;</span><br><span class="line">  ~SensorFrameMessage() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetTypeName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> type_name_; &#125;</span><br><span class="line">  <span class="function">SensorFrameMessage* <span class="title">New</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SensorFrameMessage; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  apollo::common::ErrorCode error_code_ = apollo::common::ErrorCode::OK;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> sensor_id_;</span><br><span class="line">  <span class="keyword">double</span> timestamp_ = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> seq_num_ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> type_name_;</span><br><span class="line">  base::HdmapStructConstPtr hdmap_;</span><br><span class="line"></span><br><span class="line">  base::FramePtr frame_;</span><br><span class="line"></span><br><span class="line">  ProcessStage process_stage_ = ProcessStage::UNKNOWN_STAGE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote></li></ul><ol start="3" type="1"><li>调用函数<code>IntenalProc(message,camera_name,&amp;error_code,prefused_message.get(),out_message.get())</code></li></ol><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FusionCameraDetectionComponent::InternalProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image <span class="keyword">const</span>&gt; &amp;in_message,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;camera_name, apollo::common::ErrorCode *error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">SensorFrameMessage *prefused_message,</span></span></span><br><span class="line"><span class="function"><span class="params">apollo::perception::PerceptionObstacles *out_message)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实现对接收到图像信息的处理，程序前部分实现对<code>prefused_message</code> 和 <code>camera_frame</code>相关数据与参数的赋值，获取相机到世界坐标系的仿射矩阵</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera2world_trans_wrapper_map_[camera_name]-&gt;GetSensor2worldTrans(...);</span><br></pre></td></tr></table></figure><p>填充图像数据,其中数据来自OnreceiveMessage接收到的消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">camera_frame.data_provider-&gt;FillImageData(</span><br><span class="line">    image_height_, image_width_,</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span> *&gt;(in_message-&gt;data().data()),</span><br><span class="line">    in_message-&gt;encoding())</span><br></pre></td></tr></table></figure><p>有了数据之后，科技进行算法处理了，运行<code>camera_obstacle_pipelin_-&gt;Perception(&amp;camera_frame)</code> ,实现主要图像算法处理。</p><ul><li><code>Perception</code>中主要的处理函数如下</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObstacleCameraPerception::Perception</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> CameraPerceptionOptions &amp;options, CameraFrame *frame)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//lane detector and postprocessor</span></span><br><span class="line">        lane_detector_-&gt;Detect(lane_detetor_options, frame)</span><br><span class="line">        ...</span><br><span class="line">        lane_postprocessor_-&gt;Process2D(lane_postprocessor_options, frame)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//Calibration service</span></span><br><span class="line">        frame-&gt;calibration_service-&gt;Update(frame);</span><br><span class="line">    ...</span><br><span class="line">        lane_postprocessor_-&gt;Process3D(lane_postprocessor_options, frame)</span><br><span class="line">        ...</span><br><span class="line">        WriteLanelines(write_out_lane_file_, lane_file_path, frame-&gt;lane_objects)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Obstacle prediction</span></span><br><span class="line">    tracker_-&gt;Predict(tracker_options, frame)      </span><br><span class="line">    <span class="comment">// detect :detector 根据provider名称建立</span></span><br><span class="line">    detector-&gt;Detect(detector_options, frame)</span><br><span class="line">    WriteDetections(...)<span class="comment">//write all detections results as kitti format</span></span><br><span class="line">    <span class="comment">//extarctor</span></span><br><span class="line">    extractor_-&gt;Extract(extractor_options, frame)</span><br><span class="line">    <span class="comment">//tracker Associate2D</span></span><br><span class="line">    tracker_-&gt;Associate2D(tracker_options, frame)</span><br><span class="line">    <span class="comment">//Transform</span></span><br><span class="line">    transformer_-&gt;Transform(transformer_options, frame)</span><br><span class="line">    <span class="comment">//Obstacle postprocessor</span></span><br><span class="line">    obstacle_postprocessor_-&gt;<span class="built_in">Process</span>(obstacle_postprocessor_options,</span><br><span class="line">                                        frame)</span><br><span class="line">    <span class="comment">//tracker Associate3D</span></span><br><span class="line">    tracker_-&gt;Associate3D(tracker_options, frame)</span><br><span class="line">    <span class="comment">//track</span></span><br><span class="line">    tracker_-&gt;Track(tracker_options, frame)</span><br><span class="line">    <span class="comment">//save tracked detections results as kitti format</span></span><br><span class="line">    WriteDetections(tracked_detection_out_dir,frame-&gt;tracked_objectes);</span><br><span class="line">    <span class="comment">//填充多边形并设置锚点</span></span><br><span class="line">    FillObjectPloygonFromBBox3D(tracked_object)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><ol start="4" type="1"><li><p>make protobuf message</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MakeProtobufMsg(msg_timestamp, seq_num_, camera_frame.tracked_objects,</span><br><span class="line">                      camera_frame.lane_objects, *error_code,</span><br><span class="line">                      out_message)</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FusionCameraDetectionComponent::MakeProtobufMsg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> msg_timestamp, <span class="keyword">int</span> seq_num,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt; &amp;objects,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::LaneLine&gt; &amp;lane_objects,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> apollo::common::ErrorCode error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">    apollo::perception::PerceptionObstacles *obstacles)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Determine CIPV</p></li></ol><h3 id="二detector-and-tracker">二、detector and tracker</h3><p>​ 目前发表的相关检测跟踪的算法(ResNet,YOLO等)主要面向广泛的计算机视觉的应用，与自动驾驶领域中的检测和跟踪还是存在一定的区别的，由于汽车行驶在结构化、规则化的道路上，面向的场景更为具体，有很多的几何约束可以用于检测；其次，自动驾驶中的检测模型需要输出的信息更多，包括了障碍物的尺寸、朝向、速度等信息，然而如果以上任务都分别由专用的模块进行处理，则对系统负担较大，处理流程太长，因此还需要做<strong>多任务学习</strong>和网络结构的适配。</p><p>​ 一个完整的系统除了深度学习模型，还需要做一些后处理，后处理模块针对下游模块，对后续的影响比较直接。在视觉感知中，后处理主要分为三个部分：</p><p>​ 第一是2D-3D的几何计算，2D到3D的转换需要考虑的因素包括:</p><blockquote><ul><li>相机pose 的影响</li><li>接地点</li><li>稳定性</li></ul></blockquote><p>​ 第二是时序信息计算，主要针对跟踪处理，需要注意以下几点：</p><blockquote><ul><li>对相机帧率和延时有要求，要求跟踪必须是一个轻量级的模块，因为检测已经占据了大部分时间</li><li>充分利用检测模型的输出信息（特征、类别等）进行跟踪</li><li>可以考虑轻量级Metric Learning</li></ul></blockquote><p>​ 第三是多相机的环视融合</p><blockquote><ul><li>相机布局决定融合策略，要做好视野重叠</li></ul></blockquote><p>​ 检测——&gt;2D to 3D转换 ——&gt;跟踪——&gt;位置、速度</p><p>​ HM目标跟踪器的主要功能是跟踪分割步骤检测到的障碍物。通常，它通过将当前检测结果与现有跟踪列表相关联的方式，形成和更新跟踪列表。如果原来的目标都不在出现则删除旧跟踪列表，在确认新的检测结果之后会生成新的跟踪列表。</p><p>​ 关联之后，将会估计更新后的跟踪列表的运动状态。HM目标跟踪器使用Hungarian算法（匈牙利算法）对检测和跟踪(detection-to-track)进行关联，使用Robust Kalman Filter（鲁棒卡尔曼滤波）进行运动估计。</p><ul><li><p>检测到跟踪关联</p><p>将检测与现有的跟踪列表进行关联时，Apollo构建了一个二分图并使用Hungarian算法对检测和跟踪(detection-to-track)进行关联，使用<code>Robust Kalman Filter</code> (鲁棒卡尔曼滤波器)进行运动估计。</p></li><li><p>计算关联距离矩阵</p><p>首先建立一个关联距离矩阵。一个给定的检测和跟踪之间的距离可以通过一系列关联属性进行计算，这些关联属性包括运动一致性和外观一致性。<code>HM</code> 跟踪器中距离计算中使用的一些属性如下所示：</p><p>​</p><table><thead><tr class="header"><th>关联属性名称</th><th>评估一致性的说明</th></tr></thead><tbody><tr class="odd"><td>location_distance</td><td>运动</td></tr><tr class="even"><td>direction_distance</td><td>运动</td></tr><tr class="odd"><td>bbox_size_distance</td><td>外观</td></tr><tr class="even"><td>point_num_distance</td><td>外观</td></tr><tr class="odd"><td>histogram_distance</td><td>外观</td></tr></tbody></table></li></ul><p>obstacle perdiction</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracker_-&gt;Predict()</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OMTObstacleTracker::Predict</span><span class="params">(<span class="keyword">const</span> ObstacleTrackerOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 CameraFrame *frame)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;target : targets_) &#123;</span><br><span class="line">    target.Predict(frame);</span><br><span class="line">    <span class="keyword">auto</span> obj = target.latest_object;</span><br><span class="line">    frame-&gt;proposed_objects.push_back(obj-&gt;object);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中target的结构定义为：</p>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> 感知 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slam初探</title>
      <link href="/2020/02/04/slam1/"/>
      <url>/2020/02/04/slam1/</url>
      
        <content type="html"><![CDATA[<img src="/2020/02/04/slam1/slam.png"><center>图1. slam 流程图</center>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客破壳日</title>
      <link href="/2020/02/04/hello-world/"/>
      <url>/2020/02/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>博客配置完工啦！今天是博客的破壳日o(￣ヘ￣o#) 2020 fighting!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最优估计 -- kalman and lsm</title>
      <link href="/2020/02/04/kalman_filter_and_lsm/"/>
      <url>/2020/02/04/kalman_filter_and_lsm/</url>
      
        <content type="html"><![CDATA[<p>kalman Filter 和 least square 目的均为最优化某一指标，指标是优化的关键：</p><a id="more"></a><p>[TOC]</p><p>常用的估计准则有：</p><ul><li><p>无偏估计：估计值的期望等于被估计参数的真实值。</p></li><li><p>线性最小方差估计：将估计量限制为观测值的线性函数，已知观测量Z和和被估计量X一二阶矩（EX,Var{X},EZ,Var{Z},Cov{X,Z}）,使估计误差的方差最小，即最小化<span class="math inline">\(tr\{E[\tilde{X}-E\tilde{X}][\tilde{X}-E\tilde{X}]^{T}\}\)</span> ,<span class="math inline">\(\tilde{X}\)</span>为估计误差（等价于最小化均方误差阵，若为无偏估计）可得其无偏估计值为<span class="math inline">\(\tilde{X}_{LMV}(Z)=EX+cov(X,Z)(var(Z))^{-1}[Z-EZ]\)</span>对于观测模型Z=HX+V，上述条件若已知</p><p><span class="math inline">\(\{EX=\mu_x,Var(X)=P_x,EV=0,Var(V)=R,E(XV^T)=0\}\)</span> 即可得到。</p></li><li><p>最小二乘估计：对数据（X、Z）的统计特性一无所知，但仍需对X进行估计，目标是最小化残差<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>平方和。</p><p>满足最小方差必满足残差平方和最小，反之则不成立。</p></li></ul><h4 id="经典最小二乘">1.经典最小二乘</h4><p>针对隐状态X，若其无法直接观测，但间接获取其观测值<span class="math inline">\(Z=[z_1,z_2,\dots,z_n]^T\)</span> ,若其观测值为状态值的线性函数： <span class="math display">\[Z_i=H_iX+V_i,i=1,\dots,n\]</span> <span class="math inline">\(z_i\)</span>为第i次测量的观测值，<span class="math inline">\(H_i\)</span>为第i次测量的观测模型(设计矩阵，实验的观测值)，<span class="math inline">\(V_i\)</span>为第i次测量的噪声（误差）。</p><p>则第i次测量的估计误差： <span class="math display">\[\hat{e_i}=z_i-H_i\hat{X}\]</span> 则n次测量的误差（残差）平方和为优化指标： <span class="math display">\[J(\hat{X})=\sum_{i=1}^{n}{(z_i-H_i\hat{X})^2}=(Z-H\hat{X})^T(Z-H\hat{X}) \\=tr[(Z-H\hat{X})(Z-H\hat{X})^T]\]</span> 令<span class="math inline">\(\frac{\partial{J}}{\partial{\hat{X}}}=0\)</span> ,可得最小二乘估计值： <span class="math display">\[\hat{X}_{LS}=(H^TH)^{-1}H^TZ\]</span> 将<span class="math inline">\(Z=HX+V\)</span>此时状态的估计误差： <span class="math display">\[\tilde{X}_{LS}=X-\hat{X}_{LS}=-(H^TH)^{-1}H^TV\]</span> 若测量噪声均值为0，则<span class="math inline">\(E(\tilde{X}_{LS})=0\)</span>,此时最小二乘估计为<strong><u>无偏估计</u></strong>，<strong>状态估计误差的（协）方差[^ 2] <span class="math inline">\(Var(\tilde{X}_{LS})=E[(\tilde{X}-E\tilde{X})(\tilde{X}-E\tilde{X})^T]\)</span>与估计量的均方误差矩阵<span class="math inline">\(E[X-\hat{X}][X-\hat{X}]^T\)</span>相等</strong>。可见标准最小二乘不需要噪声V的任何统计信息。</p><p>由(5)式可得： <span class="math display">\[\begin{align}Var(\tilde{X}_{LS})=E[X-\hat{X}][X-\hat{X}]^T &amp; = (H^TH)^{-1}H^TE(VV^T)H(H^TH)^{-1}\\&amp;=(H^TH)^{-1}H^TRH(H^TH)^{-1}\end{align}\]</span> 其中<span class="math inline">\(R=E(VV^T)\)</span>为测量误差（噪声）的（协）方差阵。</p><h4 id="加权最小二乘weighted-least-square">加权最小二乘（weighted least square）</h4><p>在经典最小二乘中，假定每一次测量的权重相同，但是一般来说近期数据比远期数据影响更大，因此引入加权最小二乘，其指标形式： <span class="math display">\[J_W(\hat{X})=\sum_{i=1}^{n}{(z_i-H_i\hat{X})^2}=(Z-H\hat{X})^TW(Z-H\hat{X})\]</span> 同样使其偏导数为0,可得 <span class="math display">\[\hat{X}_{LSW}=(H^TWH)^{-1}H^TWZ\]</span></p><hr><p>由附录<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>,若噪声不满足同方差，则普通最小二乘(4)并不是BLUE，此时噪声的协方差阵</p><p><span class="math inline">\(E[VV^T]=\sigma^2R,R\neq{I}\)</span> ,<span class="math inline">\(R=\begin{bmatrix}r_1\\&amp;\ddots\\&amp;&amp; r_n\end{bmatrix}\)</span>,即原模型存在异方差性。</p><p>设<span class="math inline">\(R=DD^T,D=\begin{bmatrix}\sqrt{r_1}\\&amp;\ddots\\&amp;&amp; \sqrt{r_n}\end{bmatrix}\)</span> ,用<span class="math inline">\(D^{-1}\)</span>同时左乘<span class="math inline">\(Z=HX+V\)</span>两端得到新的模型： <span class="math display">\[\begin{align}D^{-1}Z&amp;=D^{-1}HX+D^{-1}V \\Z^{\star}&amp;=H^{\star}X+V^{\star}\end{align}\]</span> 此时,原模型的加权最小二乘估计量为无偏的。 <span class="math display">\[\begin{align}E[V^{\star}V^{\star T}]&amp;=E[D^{-1}VV^TD^{-1\ T}]\\&amp;=D^{-1}E[VV^T]D^{-1\ T}\\&amp;=\sigma^2D^{-1}RD^{-1\ T}\\&amp;=\sigma^2I\end{align}\]</span> 此时得到的参数估计为： <span class="math display">\[\begin{align}\hat{X}_{LSW}&amp;=(H^{\star T}H^{\star})^{-1}H^{\star T}Z^{\star}\\&amp;=(H^TR^{-1}H)^{-1}H^TR^{-1}Z\end{align}\]</span> 可以证明（见附录），当<span class="math inline">\(W=R^{-1}\)</span>时，最小二乘估计时缺少初值条件下的<strong><u>线性无偏最小方差估计</u></strong>（BLUE,Best Linear Unbiased Estimation）——即能够使估计误差的方差阵最小，又称马尔可夫估计,其中 <span class="math display">\[R=E[VV^T]\]</span> 为随机噪声的（协）方差阵（对称正定阵）。</p><h4 id="递推最小二乘recursive-least-squarerls">2.递推最小二乘（Recursive Least Square,RLS）</h4><p>上述方法进行一次估计需要所有历史数据，不利于在线估计，考虑前n次测量： <span class="math display">\[Z_n=H_nX+V_n\]</span> 则加权的最小二乘估计为： <span class="math display">\[\hat{X}_{LSW}(n)=(H_{n}^TR_{n}^{-1}H_n)^{-1}H_{n}^TR_{n}^{-1}Z_n\]</span> 估计误差的（协）方差矩阵为： <span class="math display">\[\begin{align}P_n&amp;=E[\tilde{X}_{LSW}(n)\tilde{X}_{LSW}^T(n)]\\&amp;=E[-(H^TR^{-1}H)^{-1}]H^TR^{-1}VV^TR^{-1}H(H^TR^{-1}H)^{-1}\\&amp;=(H^TR^{-1}H)^{-1}H^TR^{-1}H(H^TR^{-1}H)^{-1}\\&amp;=(H^TR^{-1}H)^{-1}\end{align}\]</span> 结合上述两式，可得： <span class="math display">\[\hat{X}_{LSW}(n)=P_nH_{n}^TR_{n}^{-1}Z_n\]</span> 现得到一个新的测量值： <span class="math display">\[z_{n+1}=H_{n+1}X+v_{n+1}\]</span> 添加到矩阵中： <span class="math display">\[\hat{X}_{LSW}(n+1)=(H_{n+1}^TR_{n+1}^{-1}H_{n+1})^{-1}H_{n+1}^TR_{n+1}^{-1}Z_{n+1}\]</span> 将<u>新的测量噪声</u>加入到原本的测量噪声矩阵中：R阵应为对角阵： <span class="math display">\[R_{k+1}^{-1}=\begin{bmatrix}R_n^{-1} &amp; 0 \\0&amp;r^{-1}_{n+1}\end{bmatrix}\]</span> 将式子展开： <span class="math display">\[P_{n+1}^{-1}=H_{n+1}^TR_{n+1}^{-1}H_{n+1}=[H_n^T,h_{n+1}^T]\begin{bmatrix}R_n^{-1} &amp; 0 \\0&amp;r^{-1}_{n+1}\end{bmatrix}\begin{bmatrix}H_n\\h_{n+1}\end{bmatrix}=H_n^TR_n^{-1}H_n+h_{n+1}^Tr_{n+1}^{-1}h_{n+1}\]</span> 即： <span class="math display">\[P_{n+1}^{-1}=P_n^{-1}+h_{n+1}^Tr_{n+1}^{-1}h_{n+1}\]</span> 综上，可以推得： <span class="math display">\[\begin{align}P_{n+1}&amp;=P_n-P_nh_{n+1}^T[h_{n+1}P_nh_{n+1}^T+r_{n+1}]^{-1}h_{n+1}P_n\\K_{n+1} &amp;= P_{n+1}h_{n+1}^Tr_{n+1}^{-1}\\\hat{X}_{LSW}(n+1)&amp;=\hat{X}_{LSW}(n)+K_{n+1}[z_{n+1}-h_{n+1}\hat{X}_{LSW}(n)]\end{align}\]</span> 其中<span class="math inline">\(K_{n+1}\)</span>可将(31)代入展开为： <span class="math display">\[K_{n+1} = P_nh_{n+1}^T[h_{n+1}P_nh_{n+1}^T+r_{n+1}]^{-1}\]</span> 因此<span class="math inline">\(P_{n+1}\)</span>亦可表示为： <span class="math display">\[P_{n+1}=P_n-K_{n+1}h_{n+1}P_n\]</span></p><h4 id="卡尔曼滤波">3.卡尔曼滤波</h4><p>若被估计量X不随时间变化，或随时间缓慢变化则为“静态估计”，而被估计量随时间变化为“动态估计”。</p><h4 id="参考">4.参考</h4><blockquote><p>https://blog.csdn.net/qinruiyan/article/details/50793114</p><p>《最优估计理论》刘胜，张红梅，科学出版社</p><h6 id="最佳线性无偏估计gm假设">最佳线性无偏估计（GM假设）</h6><p>假设多元线性回归模型：<span class="math inline">\(Z=HX+V\)</span> <span class="math display">\[\begin{align}Z&amp;=(z_1,\dots,z_n)^T\\H&amp;=\begin{bmatrix}h_{ij}\end{bmatrix}_{n\times{p}}\\X&amp;=(x_o,\dots,x_p)\\V&amp;=(v_0,\dots,v_n)\end{align}\]</span> 则GM假设： <span class="math display">\[\begin{align}E(V|H)&amp;=0,\forall H\ (零均值)\\Var(V|H)&amp;=E(VV^T|H)=\sigma^2I_n\ (同方差且不相关)\end{align}\]</span> 则此时对参数X的最佳线性无偏估计为： <span class="math display">\[\hat{X}=(H^TH)^{-1}H^TZ\]</span></p><h6 id="最小二乘估计与最小方差估计等价条件证明">最小二乘估计与最小方差估计等价条件证明：</h6><figure><img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin%20Jac\AppData\Roaming\Typora\typora-user-images\image-20191216221314847.png" alt="image-20191216221314847"><figcaption>image-20191216221314847</figcaption></figure><h6 id="各种估计方法的比较">各种估计方法的比较：</h6><figure><img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin%20Jac\AppData\Roaming\Typora\typora-user-images\image-20191216221240802.png" alt="image-20191216221240802"><figcaption>image-20191216221240802</figcaption></figure></blockquote><section class="footnotes"><hr><ol><li id="fn1"><p>残差在数理统计中是指实际观察值和估计值之间的差。若设线性回归模型为<span class="math inline">\(Z=HX+V\)</span> ,其中Z为n维输出向量，H是<span class="math inline">\(n\times(p+1)\)</span> 阶设计矩阵，X是p+1维向量，V为n维随机变量(扰动)。则回归系数的估计值<span class="math inline">\(\hat{X}=(H^TH)^{-1}H^TZ\)</span> ，拟合值<span class="math inline">\(\hat{Z} = H\hat{X}=H(H^TH)^{-1}H^TZ\)</span>,残差为<span class="math inline">\(\hat{\epsilon}=z_i-\hat{z_i}=z_i-H_i\hat{X}\)</span> ，其由观测真值和H阵给出，不考虑噪声V。 [^ 2]: https://zh.wikipedia.org/wiki/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5<img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin Jac\AppData\Roaming\Typora\typora-user-images\image-20191215194027795.png" alt="image-20191215194027795" style="zoom:50%;"><a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>在线性回归模型中，如果随机噪声（误差）满足<strong>零均值、同方差且互不相关</strong>，则回归系数的最优线性无偏估计（BLUE，Best Linear unbiased estimator）就是普通最小二乘估计。<a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 最优估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo感知代码阅读笔记</title>
      <link href="/2020/02/04/perception/"/>
      <url>/2020/02/04/perception/</url>
      
        <content type="html"><![CDATA[<p>apollo 感知部分代码阅读 <a id="more"></a></p><p>[TOC]</p><h2 id="主入口">主入口</h2><p><code>cyber/mainboard/mainboard.cc/int main(int argc,char** argv){...}</code></p><blockquote><p>解析配置参数；初始化cyber环境；由Moudule Controller类创建对象<code>controller</code>,调用<code>controller.Init()</code> 启动各功能模块；进入Cyber RT消息循环，等待<code>apollo::cyber::WaitForShutdown();</code> 返回Main函数，清理资源退出。</p></blockquote><p><code>controller.Init()</code> 调用 <code>ModuleController::LoadAll()</code></p><p><code>cyber/mainboard/module_controller.cc/bool ModuleController::LoadAll(){...}</code></p><blockquote><p>循环读取DAG配置文件列表，得到配置文件中所有<code>dag_conf</code> ,调用</p><p><code>bool ModuleController::LoadModule(const std::string&amp; path)</code> 加载模块功能</p></blockquote><p><code>cyber/mainboard/module_controller.cc/ModuleController::LoadModule(&amp;path)</code></p><blockquote><p>根据路径得到dag文件配置，调用<code>bool ModuleController::LoadModule(const DagConfig&amp; dag_config)</code> 实现加载模型。</p></blockquote><ul><li>component文件结构：<ul><li>头文件</li><li>实现文件</li><li>构建文件：BUILD</li><li>DAG配置文件</li><li>Launch启动文件</li></ul></li><li>实现Component（Compnent组件构建过程）<ul><li>基于模板类<code>cyber::Component</code> 派生各组件类</li><li>在派生类(<code>FusionComponent</code> )中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></li><li>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类</li></ul></li><li>消息接收发送的方式</li></ul><hr><h2 id="感知模块对象创建过程">感知模块对象创建过程</h2><p>apollo中对象的创建大多采用直接法，也有部分对象使用单例模式创建<code>DECLARE_SINGLETON(AdapterManager)</code>,还有部分对象采用工厂模式创建。</p><p>感知（perception）模块位于命名空间<code>apollo::perception</code> 中，创建过程</p><p>可能用到了<strong>工厂模式</strong> 动态创建<code>apollo::perception::FusionCameraDetectionComponent</code>类对象，首先生成一个与之对应的工厂类，并将其加入到工厂集合类 <code>std::map</code> 中 (参考planning模块，是否如此 存疑)</p><p>具体参考文件：</p><p><code>cyber/class_loader/utility/...</code></p><p>创建过程位于<code>bool ModuleController::LoadModule(const DagConfig&amp; dag_config)</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ModuleController::LoadModule</span><span class="params">(<span class="keyword">const</span> DagConfig&amp; dag_config)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> load_path;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    class_loader_manager_.LoadLibrary(load_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; component : module_config.components()) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; class_name = component.class_name();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ComponentBase&gt; base =</span><br><span class="line">          class_loader_manager_.CreateClassObj&lt;ComponentBase&gt;(class_name);</span><br><span class="line">      <span class="keyword">if</span> (base == <span class="literal">nullptr</span> || !base-&gt;Initialize(component.<span class="built_in">config</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      component_list_.emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(base));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类对象指针找到后使用<code>classobj = factory-&gt;CreateObj();</code>即可将PerceptionComponent 类对象创建。</p><hr><h2 id="功能模块构建">功能模块构建</h2><blockquote><p>基于模板类<code>Component</code> 派生各组件类</p><p>在派生类<code>FusionComponent</code> 中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></p><p>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类</p></blockquote><ul><li>基于模板类<code>Component</code> 派生各组件类</li></ul><p>模板类Component最多可接受4各模板参数，每个模板参数表示一种输入信息类型。</p><p><code>cyber/component/component.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M0 = NullType, <span class="keyword">typename</span> M1 = NullType,</span><br><span class="line">          <span class="keyword">typename</span> M2 = NullType, <span class="keyword">typename</span> M3 = NullType&gt;</span><br><span class="line">class Component : <span class="keyword">public</span> ComponentBase &#123;...&#125;</span><br></pre></td></tr></table></figure><p>感知模块各组件类（继承于基类cyber::Component):</p><p><code>FusionCameraDetectionComponent</code> ,<code>FusionComponent</code>, <code>LaneDetectionComponent</code>,<code>LidarOutputComponent</code>,<code>radar_detection_component</code>,<code>RecognitionComponent</code>,<code>SegmentationComponent</code>,<code>TrafficLightPerceptionComponent</code>.</p><p>以<code>FusionComponent</code>为例,继承自<code>cyber::Component&lt;SensorFrameMessage&gt;</code>，消息参数为<code>SensorFrameMessage</code>，这些消息将会在<code>Proc</code>函数中周期性接收并处理。</p><p><code>perception/onborad/component/fusion_component.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FusionComponent</span> :</span> <span class="keyword">public</span> cyber::Component&lt;SensorFrameMessage&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  ~FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Proc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt;&amp; message)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InitAlgorithmPlugin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InternalProc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage <span class="keyword">const</span>&gt;&amp; in_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PerceptionObstacles&gt; out_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; viz_message)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::mutex s_mutex_;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint32_t</span> s_seq_num_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_method_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_main_sensor_;</span><br><span class="line">  <span class="keyword">bool</span> object_in_roi_check_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">double</span> radius_for_roi_object_check_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;fusion::ObstacleMultiSensorFusion&gt; fusion_;</span><br><span class="line">  <span class="built_in">map</span>::HDMapInput* hdmap_input_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;PerceptionObstacles&gt;&gt; writer_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;SensorFrameMessage&gt;&gt; inner_writer_;</span><br><span class="line">&#125;;</span><br><span class="line">CYBER_REGISTER_COMPONENT(FusionComponent);</span><br></pre></td></tr></table></figure><ul><li><p>在派生类<code>FusionComponent</code> 中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></p><p><code>Init()</code> 创建实际对象，创建消息处理回调函数，创建输出器writer</p><p><code>Proc()</code> 周期性接收消息，执行相关处理，并向其他模块输出消息。</p></li><li><p>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类，使<code>Cyber RT</code> 能够正确创建和加载该类对象。</p></li><li><p>BUILD构建文件</p><p><code>perception/onboard/component/BUILD</code></p><p>基于<code>perception_component_inner_camera</code> 生成 <code>libperception_component_camera.so</code></p><p>基于<code>perception_component_inner_lidar</code> 生成 <code>libperception_component_lidar.so</code></p><p>生成的共享库文件由<code>Cyber RT</code> 调度程序mainboard动态加载运行。</p></li><li><p>DAG配置文件(有向无环图)：<code>perception/production/dag</code></p><p>DAG配置文件是Cyber RT 调度程序<code>mainboard</code> 动态加载<code>perception</code> 模块的最终配置文件。</p><p>加载命令：<code>/apollo/cyber/mainboard -d /apollo/modules/perception/production/dag/dag_streamimg_perception.dag</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module_config &#123;</span><br><span class="line">  #共享库文件路径</span><br><span class="line">  module_library : <span class="string">"/apollo/bazel-bin/modules/perception/onboard/component/libperception_component_lidar.so"</span></span><br><span class="line"></span><br><span class="line"> components &#123;</span><br><span class="line">    #组件名称，mainboard动态加载</span><br><span class="line">    class_name : <span class="string">"SegmentationComponent"</span></span><br><span class="line">    <span class="built_in">config</span> &#123;</span><br><span class="line">      #模块名</span><br><span class="line">      name: <span class="string">"Velodyne128Segmentation"</span></span><br><span class="line">      #绝对路径，配置文件路径</span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/lidar/velodyne128_segmentation_conf.pb.txt"</span></span><br><span class="line"></span><br><span class="line">      flag_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/perception_common.flag"</span></span><br><span class="line">      #组件proc()函数中使用的消息接收器</span><br><span class="line">      readers &#123;</span><br><span class="line">          channel: <span class="string">"/apollo/sensor/lidar128/compensator/PointCloud2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Launch 启动文件:<code>modules/perception/prodution/launch/perception_all.launch</code></p><p>Launch配置文件使用<code>Cyber RT</code> 提供的python工具程序<code>cyber_launch</code> 加载<code>Perception</code> 模块所需的配置文件，启动命令如下</p><p><code>cyber_launch start /apollo/launch/perception_all.launch</code></p><p>典型片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;cyber&gt;  </span><br><span class="line">&lt;<span class="keyword">module</span>&gt;</span><br><span class="line">        &lt;name&gt;perception&lt;/name&gt;</span><br><span class="line">        &lt;dag_conf&gt;/apollo/modules/perception/production/dag</span><br><span class="line">      /dag_streaming_perception.dag&lt;/dag_conf&gt;</span><br><span class="line">        &lt;!-- <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">set</span>, use <span class="keyword">default</span> <span class="built_in">process</span> --&gt;</span><br><span class="line">        &lt;process_name&gt;perception&lt;/process_name&gt;</span><br><span class="line">        &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/module&gt;</span><br><span class="line">&lt;cyber&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收消息：</p><p>基于<code>Cyber RT</code>接收消息分为两种：</p><ul><li><p>虚函数：Proc()中处理指定的消息类型，周期性触发（接收），但最多只能接收4种消息类型（由cyber::Component的模板参数最多只有4个决定），一般用于模块主要输入信息的接收。</p></li><li><p>直接创建消息接收器，一般用于接收非周期性消息或模块的次要输入消息，例如：</p><p><code>modules/perception/onboard/component/fusion_camera_detection_component.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> camera_reader = node_-&gt;CreateReader(channel_name, camera_callback);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>发布消息：</p><p>基于<code>Cyber RT</code> 发布消息</p><p><code>fusion_camera_detection_component.cc/FusionCameraDetectionComponent::Init()</code>定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sensorframe_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(prefused_channel_name_);</span><br></pre></td></tr></table></figure><p><code>FusionCameraDetectionComponent::OnReceiveImage</code>中发布消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> send_sensorframe_ret = sensorframe_writer_-&gt;Write(prefused_message);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="具体算法分析">具体算法分析：</h2><h2 id="消息发送接收类型">消息发送接收类型：</h2><p><code>FusionCameraDetectionComponent::Init(){}</code> 中以模板类的方式开头定义了四个writer:</p><p>其内容是<code>InitConfig()</code> 时导入的proto消息配置文件<code>&quot;fusion_camera_detection_component.proto&quot;</code> 信息 :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> output_obstacles_channel_name = <span class="number">10</span> [<span class="keyword">default</span> = <span class="string">"/perception/obstacles"</span>];</span><br><span class="line"><span class="built_in">string</span> prefused_channel_name = <span class="number">12</span> [<span class="keyword">default</span> = <span class="string">"/perception/inner/PrefusedObjects"</span>];</span><br><span class="line"><span class="built_in">string</span> camera_perception_viz_message_channel_name = <span class="number">11</span> [<span class="keyword">default</span> = <span class="string">"/perception/inner/camera_viz_msg"</span>]; <span class="comment">//3d?</span></span><br><span class="line"><span class="built_in">string</span> camera_debug_channel_name = <span class="number">20</span> [<span class="keyword">default</span> = <span class="string">"/perception/camera_debug"</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;PerceptionObstacles&gt;(output_obstacles_channel_name_); </span><br><span class="line">sensorframe_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(prefused_channel_name_);</span><br><span class="line">camera_viz_writer_ = node_-&gt;CreateWriter&lt;CameraPerceptionVizMessage&gt;(</span><br><span class="line">    camera_perception_viz_message_channel_name_);</span><br><span class="line">camera_debug_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;apollo::perception::camera::CameraDebug&gt;(</span><br><span class="line">        camera_debug_channel_name_);</span><br></pre></td></tr></table></figure><h3 id="文件参数初始化的调用关系">文件参数初始化的调用关系：</h3><p><code>*.proto</code> 中包含的相关固定（默认）参数通过编译为对应<code>package</code> 命名空间下的类，然后<code>*.pt</code> 的文件通过<code>GetAbsolutePath()</code> 函数读取，最后通过<code>cyber::common::GetProtoFromFile()</code> 函数将<code>*.pt</code> 中的参数部分修改<code>*.proto</code> 中的默认参数，即得最终的配置参数，然后这些参数复制给对应的类成员属性。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app::PerceptionParam perception_param_; <span class="comment">//对应proto文件生成的类</span></span><br><span class="line">config_file = GetAbsolutePath(work_root, config_file); <span class="comment">//通过路径获取pt文件的路径(obstacle.pt)</span></span><br><span class="line">cyber::common::GetProtoFromFile(config_file, &amp;perception_param_);<span class="comment">//部分修改perception_param中的参数</span></span><br><span class="line">detector_init_options.gpu_id = perception_param_.gpu_id();<span class="comment">//将proto文件参数赋给具体类实例中的成员属性</span></span><br></pre></td></tr></table></figure><p>模型参数以及相关配置文件的修改位于：</p><p><code>modules/perception/production/data/perception/..</code>中，包含了各个传感器及其对应的功能模块的配置文件</p><h2 id="目前待解决的问题">目前待解决的问题：</h2><p><code>Cyber RT</code> 的调度与通信机制，例如Component::Proc()是如何被周期性調用的</p><p>camera app中如何被fusion中调用的，消息的传送方向。</p><h3 id="proto文件解析与c开发">1. Proto文件解析与C++开发</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.perception.camera.yolo; <span class="comment">//对应命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">YoloParam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> ModelParam model_param = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> NetworkParam net_param = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">optional</span> NMSParam nms_param = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “yolo.pb.h” <span class="comment">//此文件编译后产生</span></span></span><br><span class="line">yolo::YoloParam yolo_param_;<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><blockquote><p>https://www.jianshu.com/p/d2bed3614259</p></blockquote><p>.proto 文件以 package 声明开头，这有助于防止不同项目之间的命名冲突。在 C++ 中，生成的类将放在与包名匹配的 namespace （命名空间）中。</p><h3 id="tensorrt-模型量化方法">2. TensorRT 模型量化方法</h3><h3 id="caffe-blobternsorrtcaffe-特征提取的c接口">caffe blob、TernsorRT、caffe 特征提取的C++接口:</h3><h3 id="网络推断模型-inference_factory.cc的建立和区别与上面问题存在关联">3. 网络推断模型 （inference_factory.cc）的建立和区别(与上面问题存在关联)</h3><blockquote><p>CaffeNet</p><p>RTNet</p><p>RTNetInt8</p><p>PaddleNet</p></blockquote><h3 id="视频目标跟踪和目标检测的统一框架">4. 视频目标跟踪和目标检测的统一框架：</h3><blockquote><p>Detect to Track and Track to Detect</p></blockquote><h4 id="roi-pooling-track">Roi pooling track ?</h4><h3 id="目标跟踪-匈牙利算法hungarian-algorithm与km算法kuhn-munkres-algorithm">5. 目标跟踪 匈牙利算法（Hungarian Algorithm）与KM算法（Kuhn-Munkres Algorithm）</h3><blockquote><p>https://blog.csdn.net/NIeson2012/article/details/94472313</p><p>https://blog.csdn.net/zziahgf/article/details/85344859</p><p>https://blog.csdn.net/xiao__run/article/details/84374959</p><p>Deep sort论文需要看一下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机标定</title>
      <link href="/2020/02/04/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"/>
      <url>/2020/02/04/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="单应性矩阵">单应性矩阵</h3>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> 标定 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
            <tag> 标定 </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
