<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>apollo中cipv检测</title>
      <link href="/2020/02/29/apollo-cipv/"/>
      <url>/2020/02/29/apollo-cipv/</url>
      
        <content type="html"><![CDATA[<p>Apollo中CIPV(Closest-In Path Vehicle)为当前车道最接近的车辆，对象由3D边界框表示，其从上到下视图的2D投影将对象定位在地面上，然后检查每个对象是否在当前的车道中。在当前车道的对象中，最接近的一个车辆将被选为CIPV.</p><a id="more"></a><p><code>CIPV</code>通过检测道路上的关键物体以进行纵向控制,利用的信息包括物体检测输出及自身所在车道线<code>(object detection,ego-lane line)</code>。其可用于跟车，从跟踪对象和当前车辆运动中，估计对象的轨迹。该轨迹将指导对象如何在道路上作为一组移动并且可以预测未来的轨迹。有两种跟车尾随，一种是跟随特定车辆的纯尾随，另一种是CIPV引导的尾随，当检测到无车道线时，当前车辆遵循<code>CIPV</code>的轨迹。 <img src="/2020/02/29/apollo-cipv/perception_visualization_apollo_3.0.png"></p><p><strong>apollo中感知输出的可视化，左上角是基于图像的输出，左下角显示了对象的3D边界框。右图显示了车道线和物体的三维俯视图。CIPV标有红色框，黄线表示每辆车的轨迹。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// We use "right handed ZYX" coordinate system for euler angles</span></span><br><span class="line"> <span class="comment">// adjust pitch yaw roll in camera coords</span></span><br><span class="line"> <span class="comment">// Remember that camera coordinate</span></span><br><span class="line"> <span class="comment">// (Z)----&gt; X</span></span><br><span class="line"> <span class="comment">//  |</span></span><br><span class="line"> <span class="comment">//  |</span></span><br><span class="line"> <span class="comment">//  V</span></span><br><span class="line"> <span class="comment">//  Y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"> <span class="comment">//    area ID, corner ID and face ID</span></span><br><span class="line"> <span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"> <span class="comment">//    8 | 1 | 2       a</span></span><br><span class="line"> <span class="comment">//    ---------    0-----1   ^</span></span><br><span class="line"> <span class="comment">//      |   |       |   |    |</span></span><br><span class="line"> <span class="comment">//    7 | 0 | 3    d|   |b</span></span><br><span class="line"> <span class="comment">//      |   |       |   |</span></span><br><span class="line"> <span class="comment">//    ---------    3-----2</span></span><br><span class="line"> <span class="comment">//    6 | 5 | 4       c</span></span><br><span class="line"> <span class="comment">//----------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><h2 id="配置">配置</h2><p>使能<code>CIPV</code>需要在<code>modules/perception/production/conf/perception/camera/fusion_camera_detection_component.pb.txt</code> 中设置<code>enable_cipv:able</code></p><h2 id="初始化">初始化</h2><p>基本数据结构的定义位于<code>modules/perception/camera/app/cipv_camera.h</code></p><p><code>cipv</code>初始化位于<code>FuisonCameraDetectionComponent::Init()</code> 初始化所需参数包括了:</p><ul><li><p>图像与地平面之间的单应性矩阵(<code>homography_im2car_</code>)</p><p>该矩阵由可视化<code>Visualizer</code>功能模块计算获得，计算过程可以参照<code>Visualizer::adjust_angles()</code>,这一部分的初始化<code>visualize_.Init_all_info_single_camera(...)</code>由此处执行。</p></li><li><p><code>cipv</code>所需要的车道线的最少点数(最短长度)<code>(kMinLaneLineLengthForCIPV)</code></p><p>该参数默认为2</p></li><li><p>车道线的平均宽度<code>(kAverageLaneWidthInMeter)</code> 默认为3.7(米)</p></li><li><p>最大车辆宽度<code>(kMaxVehicleWidthInMeter)</code></p><p>默认为1.87米</p></li><li><p>平均帧率<code>(kAverageFrameRate)</code> 默认0.05 s</p></li><li><p><code>image_based_cipv_</code></p><p>布尔值,<code>true</code>:在图像空间中检测目标是否位于车道线内，<code>false:</code>在地平面空间中检测目标是否位于车道线</p></li><li><p><code>debug_level</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0: no debug message</span><br><span class="line">&#x2F;&#x2F; 1: minimal output</span><br><span class="line">&#x2F;&#x2F; 2: some important output</span><br><span class="line">&#x2F;&#x2F; 3: verbose message</span><br><span class="line">&#x2F;&#x2F; 4: visualization</span><br><span class="line">&#x2F;&#x2F; 5: all</span><br><span class="line">&#x2F;&#x2F; -x: specific debugging, where x is the specific number</span><br></pre></td></tr></table></figure></li></ul><h2 id="cipv主体流程">CIPV主体流程</h2><p>运行位于<code>FusionCameraDetectionComponent::InternalProc()</code>中，在主体的相关算法(障碍物跟踪检测、车道线检测)处理完成后运行,同时该部分用到了<code>motion_service</code>的信息(<code>MotionBuffer</code>中存储的车辆状态信息<code>VehicleStatus</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Determine CIPV</span></span><br><span class="line"> <span class="keyword">if</span> (enable_cipv_) &#123;</span><br><span class="line">   CipvOptions cipv_options;</span><br><span class="line">   <span class="keyword">if</span> (motion_buffer_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (motion_buffer_-&gt;<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">       AWARN &lt;&lt; <span class="string">"motion_buffer_ is empty"</span>;</span><br><span class="line">       cipv_options.velocity = <span class="number">5.0f</span>;</span><br><span class="line">       cipv_options.yaw_rate = <span class="number">0.0f</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       cipv_options.velocity = motion_buffer_-&gt;back().velocity;</span><br><span class="line">       cipv_options.yaw_rate = motion_buffer_-&gt;back().yaw_rate;</span><br><span class="line">     &#125;</span><br><span class="line">     ADEBUG &lt;&lt; <span class="string">"[CIPV] velocity "</span> &lt;&lt; cipv_options.velocity</span><br><span class="line">            &lt;&lt; <span class="string">", yaw rate: "</span> &lt;&lt; cipv_options.yaw_rate;</span><br><span class="line">     cipv_.DetermineCipv(camera_frame.lane_objects, cipv_options, world2camera,</span><br><span class="line">                         &amp;camera_frame.tracked_objects);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Get Drop points</span></span><br><span class="line">     <span class="keyword">if</span> (motion_buffer_-&gt;<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       cipv_.CollectDrops(motion_buffer_, world2camera,</span><br><span class="line">                          &amp;camera_frame.tracked_objects);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       AWARN &lt;&lt; <span class="string">"motion_buffer is empty"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>主要有两个处理函数:<code>DetermineCipv</code>,<code>CollectDrops</code> ,下面分别分析其主要实现的功能:</p><h3 id="determinecipv">DetermineCipv</h3><h3 id="collectdrops">CollectDrops</h3>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中fusion_camera_deteciton组件消息类型</title>
      <link href="/2020/02/28/apollo-fusion-camera-detection/"/>
      <url>/2020/02/28/apollo-fusion-camera-detection/</url>
      
        <content type="html"><![CDATA[<p>本文主要涉及Apollo感知部分Apollo的消息接受和发送，不涉及算法程序</p><a id="more"></a><p>整个<code>fusion_camera_detection_component</code>组件的配置文件:</p><p><code>moudles/perception/production/conf/perception/camera/fusion_camera_detection_component.pb.txt</code></p><h2 id="接收reader">接收（reader）</h2><p><strong>MotionService</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;channel_name_local = <span class="string">"/apollo/perception/motion_service"</span>;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> MotionServiceMsgType &amp;)&gt; motion_service_callback =</span><br><span class="line">    <span class="built_in">std</span>::bind(&amp;FusionCameraDetectionComponent::OnMotionService, <span class="keyword">this</span>,</span><br><span class="line">              <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line"><span class="keyword">auto</span> motion_service_reader =</span><br><span class="line">    node_-&gt;CreateReader(channel_name_local, motion_service_callback);</span><br></pre></td></tr></table></figure><p>对应的回调函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On receiving motion service input, convert it to motion_buff_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FusionCameraDetectionComponent::OnMotionService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> MotionServiceMsgType &amp;message)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    motion_buffer_-&gt;push_back(vehicledata);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>消息格式定义：<code>modules/perception/proto/motion_service.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MotionType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m00 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m01 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m02 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m03 = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m10 = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m11 = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m12 = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m13 = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m20 = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m21 = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m22 = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m23 = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m30 = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m31 = <span class="number">14</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m32 = <span class="number">15</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> m33 = <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">VehicleStatus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> roll_rate = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> pitch_rate = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> yaw_rate = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> velocity = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> velocity_x = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> velocity_y = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> velocity_z = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> time_ts = <span class="number">8</span>;                          <span class="comment">// time stamp</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> time_d = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">optional</span> MotionType motion = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Motion_Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> VehicleStatus vehicle_status = <span class="number">1</span>;  <span class="comment">// An array of vehicle_information stored for previous timestamps</span></span><br><span class="line">  <span class="keyword">optional</span> common.Header header = <span class="number">2</span>;                    <span class="comment">// Header</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CameraListeners</strong>:创建回调函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//modules/drivers/proto/sensor_image.proto 定义了Image的消息类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image&gt; ImageMsgType;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> ImageMsgType &amp;)&gt; camera_callback =</span><br><span class="line">    <span class="built_in">std</span>::bind(&amp;FusionCameraDetectionComponent::OnReceiveImage, <span class="keyword">this</span>,</span><br><span class="line">              <span class="built_in">std</span>::placeholders::_1, camera_name);<span class="comment">//jac!!20/1/14:回调</span></span><br><span class="line"><span class="keyword">auto</span> camera_reader = node_-&gt;CreateReader(channel_name, camera_callback);</span><br></pre></td></tr></table></figure><p>对应的回调函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FusionCameraDetectionComponent::OnReceiveImage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image&gt; &amp;message,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;camera_name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>图像消息格式定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> frame_id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> measurement_time = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> height = <span class="number">4</span>;  <span class="comment">// image height, that is, number of rows</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> width = <span class="number">5</span>;   <span class="comment">// image width, that is, number of columns</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> encoding = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> step = <span class="number">7</span>;  <span class="comment">// Full row length in bytes</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bytes</span> data = <span class="number">8</span>;   <span class="comment">// actual matrix data, size is (step * rows)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##　发送(writer)</p><h3 id="out_message">out_message</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::perception::PerceptionObstacles&gt; <span class="title">out_message</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) apollo::perception::PerceptionObstacles)</span></span>;</span><br></pre></td></tr></table></figure><p>该message的消息内容定义<code>modules/perception/proto/perception_obstacle.proto</code></p><p><strong>在<code>InternalProc()</code>函数进行的相关赋值：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MakeProtobufMsg(msg_timestamp, seq_num_, camera_frame.tracked_objects,</span><br><span class="line">camera_frame.lane_objects, *error_code,</span><br><span class="line">    out_message) != cyber::SUCC)</span><br></pre></td></tr></table></figure><h3 id="prefused_message">prefused_message</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; <span class="title">prefused_message</span><span class="params">(<span class="keyword">new</span> (<span class="built_in">std</span>::nothrow)</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          SensorFrameMessage)</span></span>;</span><br></pre></td></tr></table></figure><p>该message的消息内容定义:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorFrameMessage</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SensorFrameMessage() &#123; type_name_ = <span class="string">"SensorFrameMessage"</span>; &#125;</span><br><span class="line">  ~SensorFrameMessage() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetTypeName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> type_name_; &#125;</span><br><span class="line">  <span class="function">SensorFrameMessage* <span class="title">New</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SensorFrameMessage; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  apollo::common::ErrorCode error_code_ = apollo::common::ErrorCode::OK;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> sensor_id_;</span><br><span class="line">  <span class="keyword">double</span> timestamp_ = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> seq_num_ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> type_name_;</span><br><span class="line">  base::HdmapStructConstPtr hdmap_;</span><br><span class="line"></span><br><span class="line">  base::FramePtr frame_;</span><br><span class="line"></span><br><span class="line">  ProcessStage process_stage_ = ProcessStage::UNKNOWN_STAGE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在<code>InternalProc()</code>函数进行的相关赋值：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FusionCameraDetectionComponent::InternalProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image <span class="keyword">const</span>&gt; &amp;in_message,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;camera_name, apollo::common::ErrorCode *error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">  SensorFrameMessage *prefused_message,</span></span></span><br><span class="line"><span class="function"><span class="params">  apollo::perception::PerceptionObstacles *out_message)</span> </span>&#123;</span><br><span class="line">  ...  </span><br><span class="line">  prefused_message-&gt;timestamp_ = msg_timestamp;</span><br><span class="line">  prefused_message-&gt;seq_num_ = seq_num_;</span><br><span class="line">  <span class="comment">//单目相机检测阶段</span></span><br><span class="line">  prefused_message-&gt;process_stage_ = ProcessStage::MONOCULAR_CAMERA_DETECTION; </span><br><span class="line">  prefused_message-&gt;sensor_id_ = camera_name;</span><br><span class="line">  prefused_message-&gt;frame_ = base::FramePool::Instance().Get();</span><br><span class="line">  prefused_message-&gt;frame_-&gt;sensor_info = sensor_info_map_[camera_name];</span><br><span class="line">  prefused_message-&gt;frame_-&gt;timestamp = msg_timestamp</span><br><span class="line">  ...</span><br><span class="line">  prefused_message-&gt;frame_-&gt;sensor2world_pose = camera2world_trans;</span><br><span class="line">  prefused_message-&gt;frame_-&gt;objects = camera_frame.tracked_objects; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终发送"><strong>最终发送</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;PerceptionObstacles&gt;(output_obstacles_channel_name_); </span><br><span class="line">sensorframe_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(prefused_channel_name_);</span><br><span class="line">camera_viz_writer_ = node_-&gt;CreateWriter&lt;CameraPerceptionVizMessage&gt;(</span><br><span class="line">    camera_perception_viz_message_channel_name_);</span><br><span class="line">camera_debug_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;apollo::perception::camera::CameraDebug&gt;(</span><br><span class="line">        camera_debug_channel_name_);</span><br></pre></td></tr></table></figure><p>消息格式的定义基本可以在<code>modules/perception/proto/..</code>下找到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (output_camera_debug_msg_)&#123;</span><br><span class="line">    ...</span><br><span class="line">camera_debug_writer_-&gt;Write(camera_debug_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enable_visualization_) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">bool</span> send_viz_ret = camera_viz_writer_-&gt;Write(viz_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (output_final_obstacles_) &#123;</span><br><span class="line">    writer_-&gt;Write(out_message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> send_sensorframe_ret = sensorframe_writer_-&gt;Write(prefused_message);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中的kalman filter实现</title>
      <link href="/2020/02/28/apollo-kalmanfilter/"/>
      <url>/2020/02/28/apollo-kalmanfilter/</url>
      
        <content type="html"><![CDATA[<p>Apollo中的KalmanFilter实践</p><a id="more"></a><p>此部分更详细的解释可参考：https://zhuanlan.zhihu.com/p/45238681,此处仅为整理</p><h2 id="kalmanfilter基本形式">KalmanFilter基本形式</h2><figure><img src="/2020/02/28/apollo-kalmanfilter/1.jpg" alt="图片出处:优达学成(Udacity)无人驾驶学位课"><figcaption>图片出处:优达学成(Udacity)无人驾驶学位课</figcaption></figure><h3 id="代码实现">代码实现：</h3><p><code>modules/perception/cammera/lib/obstacle/tracker/commom/kalman_filter.cc</code></p><ul><li><p><strong>初始化：不同的运动模型，其状态量不同</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KalmanFilterConstVelocity::Init</span><span class="params">(Eigen::VectorXd x)</span> </span>&#123;</span><br><span class="line">  state_ &lt;&lt; x(<span class="number">0</span>), x(<span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">  inited_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>预测:使用历史信息对未来位置进行推测</strong> <span class="math display">\[x&#39;=Fx+u\\P&#39;=FPF^T+Q\]</span> 其中<code>F</code>为<strong>状态转移矩阵(state transistion matrix)</strong>,<code>u</code>为外部影响(比如加速度);<code>P</code>表示系统的不确定程度<strong>状态协方差矩阵(state covariance matrix)</strong>，初始值很大，随越来越多数据加入到滤波器中，不确定度会变小;<code>Q</code>表示<strong>过程噪声（process covariance matrix）</strong>，既无法用<code>x'=Fx+u</code>表示的噪声，比如车辆突然上坡。</p><p>恒速度模型的状态转移方程可以表示为:</p><p><img src="/2020/02/28/apollo-kalmanfilter/2.jpg"></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KalmanFilterConstVelocity::Predict</span><span class="params">(<span class="keyword">float</span> <span class="keyword">delta_t</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inited_) &#123;</span><br><span class="line">    state_transition_matrix_(<span class="number">0</span>, <span class="number">2</span>) = <span class="keyword">delta_t</span>;</span><br><span class="line">    state_transition_matrix_(<span class="number">1</span>, <span class="number">3</span>) = <span class="keyword">delta_t</span>;</span><br><span class="line">    state_ = state_transition_matrix_ * state_;</span><br><span class="line">    predict_state_ = state_;</span><br><span class="line">    variance_ = state_transition_matrix_ * variance_ *</span><br><span class="line">                    state_transition_matrix_.transpose() +</span><br><span class="line">                process_noise_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>校正，根据观测值对预测值进行校正：</strong> <span class="math display">\[y=z-Hx&#39;\]</span> 上式计算观测值<code>z</code>与预测值<code>x</code>的<code>残差y</code>。 其中<code>H</code>为<strong>测量矩阵</strong>，表示状态量和测量值之间的对应关系；<code>z</code>为实际观测值 <span class="math display">\[S=HP&#39;H^T+R\\K=P&#39;H^TS^{-1}\]</span> 上式计算得到了<strong>卡尔曼增益K(Kalman Gain)</strong> 其中<code>R</code>为<strong>测量噪声矩阵</strong>,表示的是测量值与真值的差异程度 <span class="math display">\[x=x&#39;+Ky\\P=(1-KH)P&#39;\]</span> 上述两个公式完成了卡尔曼滤波器的闭环，第一个公式完成了状态向量<code>x</code>的更新(综合考虑了预测值和观测值及系统噪声)；第二个公式由卡尔曼增益更新系统的不确定程度<code>P</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KalmanFilterConstVelocity::Correct</span><span class="params">(<span class="keyword">const</span> Eigen::VectorXd &amp;z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inited_) &#123;</span><br><span class="line">    Eigen::Vector2d measure;</span><br><span class="line">    measure &lt;&lt; z[<span class="number">0</span>], z[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// measurement covariance: S = H*P*H^T + R</span></span><br><span class="line">    Eigen::Matrix2d cov =</span><br><span class="line">        measure_matrix_ * variance_ * measure_matrix_.transpose() +</span><br><span class="line">        measure_noise_;</span><br><span class="line"></span><br><span class="line">    kalman_gain_ = variance_ * measure_matrix_.transpose() * cov.inverse();</span><br><span class="line">    variance_ = variance_ - kalman_gain_ * measure_matrix_ * variance_;<span class="comment">//不确定度更新</span></span><br><span class="line">    state_ = state_ + kalman_gain_ * (measure - measure_matrix_ * state_);<span class="comment">//状态更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute likelihood</span></span><br><span class="line">    <span class="keyword">auto</span> residual = measure - predict_state_.head(<span class="number">2</span>);<span class="comment">//获取predict_state_的前两个元素</span></span><br><span class="line">    likelihood_ =</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">exp</span>(<span class="number">-0.5</span> * residual.transpose() * cov.inverse() * residual) /</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">2</span> * M_PI * cov.determinant());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Init(z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到该函数最后计算了一个<strong>似然</strong>,<code>likelihood_</code>: 高斯分布 <span class="math display">\[likelihood=\frac{1}{\sqrt{2\pi|S|}}e^{-\frac{1}{2}r^TS^{-1}r}\]</span> 其中<code>r</code>为观测值与预测值之间的差值（残差residual）</p></li></ul><h2 id="扩展卡尔曼滤波extend-kalman-filter">扩展卡尔曼滤波(Extend Kalman Filter)</h2><p>实际车辆的运动并不能完全由恒定速度模型描述，补充非线性系统中使用的扩展卡尔曼滤波， 常见的其他运动模型有：</p><ul><li>一次运动模型（线性运动模型）<ul><li>恒定速度(Constant Velocity,CV)模型</li><li>恒定加速度(Constant Acceleration,CA)模型</li></ul></li><li>二次运动模型<ul><li>恒定转率和速度(Constant Turn Rate and Velocity,CTRV)模型</li><li>恒定转率和加速度模型(Constant Turn Rate and Acceleration,CTRA)模型</li></ul></li></ul><p>以毫米波雷达的感知为例:</p><figure><img src="/2020/02/28/apollo-kalmanfilter/3.jpg" alt="图片出处:优达学城无人驾驶学位课"><figcaption>图片出处:优达学城无人驾驶学位课</figcaption></figure><p>毫米波雷达基于多普勒效应检测，其检测的原始数据基于极坐标系，上图中包含了</p><blockquote><ol type="1"><li><span class="math inline">\(\rho\)</span> :毫米波雷达到障碍物的距离</li><li><span class="math inline">\(\varphi\)</span> :方向角</li><li><span class="math inline">\(\dot{\rho}\)</span> :距离的变化率，径向速度</li></ol></blockquote><p>与卡尔曼滤波器相似的步骤：</p><p><strong>1.初始化状态初值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExtendedKalmanFilter::Init</span><span class="params">(Eigen::VectorXd x)</span> </span>&#123;</span><br><span class="line">  Init();</span><br><span class="line">  state_ &lt;&lt; x(<span class="number">0</span>), x(<span class="number">1</span>), <span class="number">0</span>, x(<span class="number">2</span>);</span><br><span class="line">  inited_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.预测</strong> <span class="math display">\[x&#39;=Fx+u\\P&#39;=FPF^T+Q\]</span> <img src="/2020/02/28/apollo-kalmanfilter/4.jpg" alt="图片来自于知乎专栏https://zhuanlan.zhihu.com/p/63641680"></p><p>由于毫米波雷达测量障碍物径向位置和速度相对准确,不确定度较低，设置状态协方差阵:</p><p><img src="/2020/02/28/apollo-kalmanfilter/home/jachin/space/myblog/blog/source/_posts/apollo-kalmanfilter/5.jpg"></p><p>由于过程噪声Q对整个系统存在影响，但不确定影响程度，设置为单位阵或空值即可</p><p><strong>3.观测</strong> <span class="math display">\[y=z-Hx&#39;\]</span> 计算观测值<span class="math inline">\(z=[\rho,\varphi,\dot{\rho}]\)</span>和预测值<span class="math inline">\(x&#39;=[p_x,p_y,v_x,v_y]^T\)</span>之间的残差，由上面毫米波雷达的数据特性,其观测数据的维度是三维的并基于极坐标系，因此需要进行坐标转换,注意下式直接用转换后的坐标代替<span class="math inline">\(Hx&#39;\)</span>，并没有实际求<span class="math inline">\(H\)</span></p><figure><img src="/2020/02/28/apollo-kalmanfilter/7.jpg" alt="图片来源于知乎专栏"><figcaption>图片来源于知乎专栏</figcaption></figure><p>注意到这个转化过程是<strong>非线性</strong>的，因此习惯上将上述模型表示为: <span class="math display">\[y=z-h(x&#39;)\]</span> 其中<span class="math inline">\(h(x&#39;)\)</span>即为向量:</p><p><img src="/2020/02/28/apollo-kalmanfilter/8.jpg"></p><p>此时再看剩下的两个公式： <span class="math display">\[S=HP&#39;H^T+R\\K=P&#39;H^TS^{-1}\]</span> 在求解卡尔曼增益的过程中需要用到测量矩阵<span class="math inline">\(H\)</span>,所以还是要求解<span class="math inline">\(H\)</span></p><figure><img src="/2020/02/28/apollo-kalmanfilter/9.jpg" alt="图片来源于知乎专栏，侵删"><figcaption>图片来源于知乎专栏，侵删</figcaption></figure><p>上式可以更明显的看出，等式两边的转换是非线性的，即<span class="math inline">\(H\)</span>不再是常数。</p><p><strong>如果将高斯分布输入到一个非线性函数中，得到的结果将不再符合高斯分布，及卡尔曼滤波不再适用</strong>，因此需要将上面的非线性函数进行<strong>近似线性化</strong>，比较容易想到的方法就是一阶泰勒展开。</p><p>非线性函数<span class="math inline">\(y=h(x)\)</span>通过Taylor公式在<span class="math inline">\((x_0,y_0)\)</span>处展开为： <span class="math display">\[h(x)=h(x_0)+\frac{\dot{h}(x_0)}{1!}(x-x_0)+\frac{\ddot{h}(x_0)}{2!}(x-x_0)^2+\dots\]</span> 忽略二阶以上的高阶项，得到近似线性化方程： <span class="math display">\[h(x)\approx h(x_0)+\dot{h}(x_0)(x-x_0)\]</span> 扩展到多维向量： <span class="math display">\[h(x)\approx h(x_0)+\frac{\partial{h(x_0)}}{\partial{x}}(x-x_0)\]</span> 上述偏导可以通过<strong>雅克比(Jacobian)矩阵</strong>表示。</p><p><img src="/2020/02/28/apollo-kalmanfilter/10.jpg"></p><p>求得非线性函数<span class="math inline">\(h(x&#39;)\)</span>对<span class="math inline">\(p_x,p_y,v_x,v_y\)</span>的一阶偏导数，排列成矩阵，最终得到雅克比阵H</p><p><img src="/2020/02/28/apollo-kalmanfilter/11.jpg"></p><p>代入<span class="math inline">\(\rho,\varphi,\dot{\rho}\)</span>的函数，求偏导，即可得最终的结果：</p><p><img src="/2020/02/28/apollo-kalmanfilter/12.jpg"></p><p>最后在进行更新状态，即完成扩展卡尔曼滤波器的过程，整个过程与一般的卡尔曼滤波器相同，只不过多了非线性关系通过一阶泰勒展开局部线性化的过程</p><blockquote><p>本文中公式的图片来自于知乎专栏https://zhuanlan.zhihu.com/p/45238681</p><p>侵删</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中障碍物后处理</title>
      <link href="/2020/02/25/apollo-obstacle-postprocess/"/>
      <url>/2020/02/25/apollo-obstacle-postprocess/</url>
      
        <content type="html"><![CDATA[<p>Apollo中障碍物后处理</p><a id="more"></a><h2 id="对检测到的障碍物进行后处理的条件">对检测到的障碍物进行后处理的条件</h2><ul><li>bbox位于roi区域内(位于这一区域的其更容易投影到地平面),roi区域大概如图所示,红色部分</li><li>障碍物的中心距离相机中心小于阈值(30)</li></ul><p><img src="/2020/02/25/apollo-obstacle-postprocess/3.png" style="zoom:70%;"></p><h2 id="后处理的初始参数配置">后处理的初始参数配置</h2><p><img src="/2020/02/25/apollo-obstacle-postprocess/1.png"></p><p><code>object_center[1] +=dimension_hwl[0] / 2</code>则此时中心点接触地面 (即车辆坐标系中心下移至平面)</p><h2 id="postprocessobjwithground">PostProcessObjWithGround</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">postprocessor_-&gt;PostProcessObjWithGround(</span><br><span class="line">        obj_postprocessor_options, object_center, dimension_hwl, &amp;rotation_y);</span><br><span class="line"><span class="comment">//函数功能定义</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObjPostProcessor::PostProcessObjWithGround</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> ObjPostProcessorOptions &amp;options, <span class="keyword">float</span> center[<span class="number">3</span>], <span class="keyword">float</span> hwl[<span class="number">3</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span> *ry)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(hwl, options.hwl, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">float</span> bbox[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">memcpy</span>(bbox, options.bbox, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">4</span>);</span><br><span class="line">  *ry = options.ry;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// soft constraints</span></span><br><span class="line">  <span class="keyword">bool</span> adjust_soft =</span><br><span class="line">      AdjustCenterWithGround(bbox, hwl, *ry, options.plane, center);</span><br><span class="line">  <span class="keyword">if</span> (center[<span class="number">2</span>] &gt; params_.dist_far) &#123;</span><br><span class="line">    <span class="keyword">return</span> adjust_soft;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hard constraints</span></span><br><span class="line">  <span class="keyword">bool</span> adjust_hard = PostRefineCenterWithGroundBoundary(</span><br><span class="line">      bbox, hwl, *ry, options.plane, options.line_segs, center,</span><br><span class="line">      options.check_lowerbound);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> adjust_soft || adjust_hard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的的处理算法有两种：</p><ul><li><p><strong>AdjustCenterWithGround</strong>:软约束--通过中心点投影位于平面内的约束进行中心点的更新。</p><p>部分主要处理函数如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">iou_ini = GetProjectionScore(ry, bbox, hwl, center); <span class="comment">//获取角点投影box和检测box的交并比初始值</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//开始更新中心坐标</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">stop</span>)&#123;</span><br><span class="line">    common::IProjectThroughIntrinsic(k_mat_, center, x); <span class="comment">//center投影到图像坐标系 x</span></span><br><span class="line">    x[<span class="number">0</span>] *= common::IRec(x[<span class="number">2</span>]);</span><br><span class="line">    x[<span class="number">1</span>] *= common::IRec(x[<span class="number">2</span>]);<span class="comment">//齐次坐标</span></span><br><span class="line">    <span class="keyword">bool</span> in_front = common::IBackprojectPlaneIntersectionCanonical(</span><br><span class="line">        x, k_mat_, plane, center_test);<span class="comment">//再将此中心点根据平面约束投影回3d空间-&gt;center_test</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">float</span> iou_cur = GetProjectionScore(ry, bbox, hwl, center);</span><br><span class="line">    <span class="keyword">float</span> iou_test = GetProjectionScore(ry, bbox, hwl, center_test);</span><br><span class="line">        <span class="keyword">float</span> dist = common::ISqrt(common::ISqr(center[<span class="number">0</span>] - center_test[<span class="number">0</span>]) +</span><br><span class="line">                               common::ISqr(center[<span class="number">2</span>] - center_test[<span class="number">2</span>]));<span class="comment">//检测得到的center与平面内的center_test的距离</span></span><br><span class="line">    <span class="keyword">float</span> cost_cur = dist + WEIGHT_IOU * (<span class="number">1.0f</span> - (iou_cur + iou_test) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "cost___ " &lt;&lt; cost_cur &lt;&lt; "@" &lt;&lt; iter &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">if</span> (cost_cur &gt;= cost_pre) &#123;</span><br><span class="line">      <span class="built_in">stop</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cost_delta = (cost_pre - cost_cur) / cost_pre;</span><br><span class="line">      cost_pre = cost_cur;</span><br><span class="line">      center[<span class="number">0</span>] += (center_test[<span class="number">0</span>] - center[<span class="number">0</span>]) * lr;</span><br><span class="line">      center[<span class="number">2</span>] += (center_test[<span class="number">2</span>] - center[<span class="number">2</span>]) * lr; <span class="comment">//更新center,与之前"Transform模块中的center更新相似",此时的依据是点的反投影位于平面</span></span><br><span class="line">      ++iter;</span><br><span class="line">      <span class="built_in">stop</span> = iter &gt;= MAX_ITERATION || cost_delta &lt; EPS_COST_DELTA ||</span><br><span class="line">             cost_pre &lt; MIN_COST;</span><br><span class="line">    &#125;</span><br><span class="line">    lr *= params_.learning_r_decay; </span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">float</span> iou_res = GetProjectionScore(ry, bbox, hwl, center);</span><br><span class="line">  <span class="keyword">if</span> (iou_res &lt; iou_ini * params_.shrink_ratio_iou) &#123; <span class="comment">//0.9 IOu缩小比率，更新完center后若其iou反而缩减到原iou的0.9以下，则还是用初始值</span></span><br><span class="line">    <span class="built_in">memcpy</span>(center, center_input, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//更新失败</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/25/apollo-obstacle-postprocess/2.png"></p><p>由内参所表示的反投影关系：(x,y)-&gt;(X,Y,Z) <span class="math display">\[X=\frac{x-c_x}{f_x}*Z=umcx*Z\\Y=\frac{y-c_y}{f_y}*Z=vmcy*Z\\\]</span> 若X,Y,Z位于平面AX+BY+CZ+D=0内，则 <span class="math display">\[A*umcx*Z+B*vmcy*Z+C*Z+D=0\\A*umcx+B*vmcy+C=-\frac{D}{Z}\]</span></p></li><li><p><strong>PostRefineCenterWithGroundBoundary</strong>硬约束--</p><p>该函数通过<code>line_segs</code>(内部存储了当前帧检测物体的2D框信息),</p><p>部分主要处理如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// hard constraints</span></span><br><span class="line"><span class="keyword">bool</span> adjust_hard = PostRefineCenterWithGroundBoundary(</span><br><span class="line">      bbox, hwl, *ry, options.plane, options.line_segs, center,</span><br><span class="line">      options.check_lowerbound);</span><br><span class="line"><span class="comment">//该函数主要处理流程如下：</span></span><br></pre></td></tr></table></figure><p>GetDxDzForCenterFromGroundLineSeg</p><p>先通过平面约束得到2d box (两点)在 3d中的反投影，即将bbox2d中的两个点反投影到了3d平面中。</p><p>将坐标系转为车辆坐标系</p><p>得到障碍物中心与车辆中心的直线方程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateOffsetZ</span><span class="params">(T x_start, T z_start, T x_end, T z_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;T, T&gt; &amp;range, T *z_offset)</span> </span>&#123;</span><br><span class="line">  CHECK(range.first &lt; range.second);</span><br><span class="line">  <span class="keyword">if</span> (x_start &gt; x_end) &#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(x_start, x_end);</span><br><span class="line">    <span class="built_in">std</span>::swap(z_start, z_end);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T x_check_l = <span class="built_in">std</span>::<span class="built_in">max</span>(x_start, range.first);</span><br><span class="line">  T x_check_r = <span class="built_in">std</span>::<span class="built_in">min</span>(x_end, range.second);</span><br><span class="line">  T overlap_x = x_check_r - x_check_l;</span><br><span class="line">  <span class="keyword">if</span> (overlap_x &lt; <span class="number">1e-6</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T dz_divide_dx = (z_end - z_start) * common::IRec(x_end - x_start);</span><br><span class="line">  T z_check_l = z_start + (x_check_l - x_start) * dz_divide_dx;</span><br><span class="line">  T z_check_r = z_start + (x_check_r - x_start) * dz_divide_dx;</span><br><span class="line">  T z_nearest = <span class="built_in">std</span>::<span class="built_in">min</span>(z_check_l, z_check_r);</span><br><span class="line">  <span class="keyword">if</span> (z_nearest &lt; *z_offset) &#123;</span><br><span class="line">    *z_offset = z_nearest;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献：基于车载单目图像的3维地平面估计_向文辉</p><p><img src="/2020/02/25/apollo-obstacle-postprocess/66.png"></p><p><img src="/2020/02/25/apollo-obstacle-postprocess/67.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 障碍物检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tracking without bells and whistles论文阅读</title>
      <link href="/2020/02/23/tracking_without_bells_and_whistles/"/>
      <url>/2020/02/23/tracking_without_bells_and_whistles/</url>
      
        <content type="html"><![CDATA[<p>tracking without bells and whistles 论文阅读笔记 <strong>A detector is all you need for Multi-Object Tracking</strong></p><a id="more"></a><h2 id="fasterrcnn回顾">FasterRCNN回顾</h2><p><img src="/2020/02/23/tracking_without_bells_and_whistles/20170324121024882.png"></p><p>FasterRCNN将<strong>特征提取、Proposal提取、BoundingBox回归、分类</strong>整合到一个网络中：</p><ul><li><strong>特征提取</strong>：Faster R-CNN首先使用基础的conv+relu+pooling层提取候选图像的<strong>共享特征图</strong>，该特征图被共享用于后续的RPN(Region Proposal Network)层和全连接层(FC)</li><li><strong>区域候选网络</strong>（Region Proposal Network）：RPN网络用于生成候选图像块。该层通过<code>softmax</code>判断锚点<code>anchors</code>属于前景(foreground)或者背景(background)的概率，再利用边界框回归修正<code>anchors</code>获得获得较精确的proposals。(上面的分支分类anchor的前景和背景，下面的分支计算前景（即目标）anchor的偏移量(bbox回归)，实际上RPN实现了目标的定位)</li><li><strong>目标区池化</strong>(Roi Pooling):该层收集<code>输入特征图</code>和<code>候选的目标区域</code>，综合这些信息提取<code>目标区域的特征图</code>(proposal feature)，送入后续的全连接层进行目标类别的判断</li><li><strong>目标分类</strong>：利用<code>目标区域的特征图</code>计算目标区域的类别，同时再次边界框回归获得检测框最终的精确位置。</li></ul><p>FasterRCNN特征图每个点有9个anchor,而RPN实际就是在原图像的尺度上，设置了密密麻麻的anchor，然后通过CNN判断哪个anchor是没有目标的背景(background)，哪些anchor是有目标的前景(foreground)，boundingbox的回归用到了两次，实际训练过程如下，分为两次循环：</p><ol type="1"><li>在已经训练好的model上，训练RPN网络，对应stage1_rpn_train.pt (RPN出的bbox回归)</li><li>利用步骤1中训练好的RPN网络，收集proposals，对应rpn_test.pt</li><li>第一次训练Fast RCNN网络，对应stage1_fast_rcnn_train.pt(最终检测处的bbox回归)</li><li>第二训练RPN网络，对应stage2_rpn_train.pt</li><li>再次利用步骤4中训练好的RPN网络，收集proposals，对应rpn_test.pt</li><li>第二次训练Fast RCNN网络，对应stage2_fast_rcnn_train.pt</li></ol><p><img src="/2020/02/23/tracking_without_bells_and_whistles/23.jpg" style="zoom:80%;"></p><p><img src="/2020/02/23/tracking_without_bells_and_whistles/66.jpg" style="zoom:30%;"></p><blockquote><p>参考链接：</p><p>https://blog.csdn.net/shenziheng1/article/details/82907663</p><p>https://zhuanlan.zhihu.com/p/32404424</p></blockquote><h2 id="tracking-without-bells-and-whistles">tracking without bells and whistles</h2><h3 id="网络结构流程">网络结构流程</h3><p><img src="/2020/02/23/tracking_without_bells_and_whistles/tracking.png"></p><p>跟踪器： 轨迹(trajectory)由一系列针对k目标的有序bounding box组成的<span class="math inline">\(T_k=\{b_{t1}^k,b_{t2}^k,...\}\)</span>, <span class="math inline">\(b^k_t=(x,y,w,h)\)</span>，<span class="math inline">\(t\)</span>代表当前帧。 同时定义第<span class="math inline">\(t\)</span>帧中的目标边界框集合为<span class="math inline">\(B_t=\{b_{t}^{k1},b_t^{k2},...\}\)</span>,注意每个跟踪轨迹<span class="math inline">\(T_k\)</span>或者边界框集合<span class="math inline">\(B_t\)</span>包含的元素可以少于序列中轨迹或帧的总数量。</p><ol type="1"><li><strong>初始化</strong> 在t=0时，跟踪器初始化为第一次检测器检测到的目标的集合<span class="math inline">\(D_0=\{d_0^1,d_0^2,...\}=B_0\)</span>,在上图中，演示了接下来将要进行的两个步骤，对于给定帧<span class="math inline">\(t\)</span>的<strong>bounding box regression</strong> 和 <strong>track initialization</strong></li><li><p><strong>Bounding box regression</strong></p><p>首先，如图中蓝线所示，通过bbox regerssion扩展active trajectories到当前帧t:这是通过t-1帧的bbox <span class="math inline">\(b_{t-1}^k\)</span>回归得到t帧时物体新的位置<span class="math inline">\(b_t^k\)</span> ，将前一帧的坐标作为ROI Pooling的依据。</p><p>deactive一个trajectory的条件：</p><ul><li>物体消失或者被非检测物体类型遮挡(对应其类别分数<span class="math inline">\(s_t^k\)</span>低于<span class="math inline">\(\sigma_{active}\)</span>)</li><li>检测物体之间遮挡通过NMS处理（对于该帧中所有保留的边界框<span class="math inline">\(B_t\)</span> 根据它们之间的IOU阈值<span class="math inline">\(\lambda_{activate}\)</span>）</li></ul></li><li><p><strong>Bounding box initialization</strong></p><p>如何去判断一个新的<code>targets</code>?</p><p>如上图红色线所示，目标检测其同时提供了该帧(frame t)中的所有检测<span class="math inline">\(D_t\)</span> ，对应的检测物体想要组成新的trajectories,需要其与所有已经激活的trajectories的边界框<span class="math inline">\(b_t^k\)</span>小于<span class="math inline">\(\lambda_{new}\)</span> 。当该目标不能被现有的trajectories解释（即包含一个潜在的新目标时）才考虑该检测物体组成新的trajectories。</p></li></ol><p>疑问： 仅通过该帧边界框位置回归预测边界框下一帧的位置，会不会随时间积累产生偏移。因为并没有在下一帧进行相关的纠正，除非它采用上一帧的检测估计下一阵跟踪位置之后，在下一帧中采用新的检测框回归下下一帧的位置，</p><h3 id="motion-model">Motion Model</h3><h3 id="re-identification">Re-identification</h3><p>通过Siamese网络生成appearance vectors</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> track </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo 中的跟踪算法</title>
      <link href="/2020/02/22/apollo-track/"/>
      <url>/2020/02/22/apollo-track/</url>
      
        <content type="html"><![CDATA[<p>Apollo中的检测算法</p><a id="more"></a><p>跟踪的基本成员单位为封装object类为TrackObject类，最后<code>Target</code>类结构中包含<code>TrackObject</code>类及相关的估计方法。</p><h2 id="tracker_-predictframe预测部分">tracker_-&gt;Predict(frame):预测部分</h2><p>在新图像中预测候选障碍物 将输出赋值给frame-&gt;proposed_objects</p><h2 id="extractor_-extractframe特征提取部分">extractor_-&gt;Extract(frame):特征提取部分</h2><p>对每个检测到的对象进行特征提取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FeatureExtractorLayer</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;inference::Layer&lt;<span class="keyword">float</span>&gt;&gt; pooling_layer;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::Blob&lt;<span class="keyword">float</span>&gt;&gt; rois_blob;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::Blob&lt;<span class="keyword">float</span>&gt;&gt; top_blob;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feature_extractor_layer_ptr-&gt;pooling_layer-&gt;ForwardGPU(</span><br><span class="line">     &#123;feat_blob_, feature_extractor_layer_ptr-&gt;rois_blob&#125;,</span><br><span class="line">     &#123;frame-&gt;track_feature_blob&#125;);</span><br></pre></td></tr></table></figure><p>其中<code>feat_blob_</code>的现行定义是:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">feat_stride: <span class="number">32</span></span><br><span class="line">extractor &#123;</span><br><span class="line">  feat_blob: <span class="string">"conv4_3"</span></span><br><span class="line">  feat_type: ROIPooling</span><br><span class="line">  roi_pooling_param &#123;</span><br><span class="line">      pooled_h: <span class="number">3</span></span><br><span class="line">      pooled_w: <span class="number">3</span></span><br><span class="line">      use_floor: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样根据feat_blob_以及rois_blob(由bbox位置确定)进行<code>ROIPooling</code>将最终pool得到的最大值存到track_feature_blob中。</p><h2 id="tracker_-associate2dframe根据2d信息关联">tracker_-&gt;Associate2D(frame):根据2D信息关联</h2><h3 id="该部分的主要成员变量">该部分的主要成员变量</h3><ol type="1"><li><p>成员类帧列表:<code>FrameList</code> 包装了<code>CameraFrame</code>类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> frame_count_ = <span class="number">0</span>; <span class="comment">//添加帧的数量</span></span><br><span class="line"><span class="keyword">int</span> capability_ = <span class="number">0</span>;<span class="comment">//容量(14)表示14帧后开始覆盖</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CameraFrame *&gt; frames_;</span><br></pre></td></tr></table></figure></li><li><p>相似性map:<code>SimilarMap</code> 存储blob的嵌套vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::Blob&lt;<span class="keyword">float</span>&gt;&gt;&gt;&gt; map_sim;</span><br><span class="line"><span class="keyword">int</span> dim;<span class="comment">//=omt_param_.img_capability()=14</span></span><br></pre></td></tr></table></figure></li><li><p>相似性计算<code>BaseSimilar</code> <code>std::shared_ptr&lt;BaseSimilar&gt; similar_</code></p></li></ol><p><img src="/2020/02/22/apollo-track/2.png"></p><p>​ 其中GPUSimilar用到了BLAS(线性代数)库:https://blog.csdn.net/cocoonyang/article/details/58602654?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</p><ol start="4" type="1"><li><p><code>Target</code>类包含了跟踪物体的id和相关的状态信息,<code>tracked_objects</code>包含了被跟踪的物体vector,是<code>TrackObject</code>类 <code>Target</code>类为期望得到检测框匹配的跟踪物体</p><p><img src="/2020/02/22/apollo-track/4.png"></p></li><li><p><code>TrackObject</code>类则封装了跟踪目标<code>Object</code>类，记录该跟踪目标对应的帧id和传感器名称,是跟踪目标的最小封装单位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrackObject</span> &#123;</span></span><br><span class="line">  PatchIndicator indicator; <span class="comment">//保存了传感器的名称和目标在帧中的id</span></span><br><span class="line">  <span class="keyword">double</span> timestamp;</span><br><span class="line">  base::BBox2DF projected_box;<span class="comment">//由检测得到的原2dbox　经projected_matrix投影得到障碍物的bbox 这个矩阵是啥意思不太清楚 narrow to obstacle projected_matrix(应该是为了将不同的相机的bbox统一到一个尺度)</span></span><br><span class="line">  base::ObjectPtr object;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>PatchIndicator</code>类主要包含了两个变量,重载运算符&quot;==&quot;为frame_id和patch_id分别相等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> frame_id;<span class="comment">//为该检测目标对应的是第几帧(frame id )</span></span><br><span class="line"><span class="keyword">int</span> patch_id;<span class="comment">//该检测目标在该帧中的id(object id)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sensor_name;<span class="comment">//记录检测到的传感器名称</span></span><br></pre></td></tr></table></figure></li><li><p><code>ObstacleReference</code>类包含了与模板相关的参数：</p><p><img src="/2020/02/22/apollo-track/5.png"></p></li><li><p><code>reference</code>类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Reference</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> area = <span class="number">0.0f</span>;</span><br><span class="line">  <span class="keyword">float</span> k = <span class="number">0.0f</span>;</span><br><span class="line">  <span class="keyword">float</span> ymax = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>CameraGroundPlaneDetector</code>类，地平面检测的相关方法</p><p><img src="/2020/02/22/apollo-track/6.png"></p></li></ol><h3 id="d关联算法的实现">2D关联算法的实现</h3><ol type="1"><li>计算各帧与当前帧的余弦相似性:（第5步target和det_obj的Apperance的匹配分数会用到）</li><li>从已跟踪物体列表中去除最早帧之前的帧中检测到的目标</li><li>根据当前帧的检测物体，得到当前的检测跟踪列表</li></ol><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">ProjectBox(frame-&gt;detected_objects[i]-&gt;camera_supplement.box,</span><br><span class="line">             frame-&gt;project_matrix, &amp;(track_ptr-&gt;projected_box));<span class="comment">//图像2dbox投影到障碍物坐标系</span></span><br><span class="line">track_objects.push_back(track_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4" type="1"><li>校正当前帧检测目标的三维尺寸，执行了四种校正方式：分别为模板，参考地平面，标定，历史信息</li></ol><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reference_.CorrectSize(frame); <span class="comment">//</span></span><br></pre></td></tr></table></figure></p><ul><li><p>根据模板的最小最大尺寸校正检测目标的最小最大尺寸。(TypeRefinedBy<strong>Template</strong>)</p></li><li><p>根据障碍物参考校正检测目标的尺寸,可作为参考的目标类型类<code>CAR,VAN</code>,同时还需要一系列附加条件，可详见<code>ObstacleReference::UpdateReference(...)</code></p><p>(1). 根据sensor_name的不同 初始化ground_estiomator,执行<code>GameraGroundPlaneDetector</code>类的初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SyncGroundEstimator(sensor, frame-&gt;camera_k_matrix,</span><br><span class="line">                          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(img_width_),</span><br><span class="line">                          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(img_height_));</span><br></pre></td></tr></table></figure><p>该函数实际上执行<code>GameraGroundPlaneDetector</code>类的初始化,有相机内参相关参数初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ground_estimator.Init(k_mat, img_width, img_height, common::IRec(fx));</span><br></pre></td></tr></table></figure><p>(2).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ground_estimator.GetGroundModel(l)</span><br></pre></td></tr></table></figure><p>通过相机pitch和相机height(通过calibration获取)获取平面<span class="math display">\[a*X+b*Y+c*Z+d=0\]</span> （相机坐标系）</p></li><li><p>通过标定服务校正高度h</p></li><li><p>通过历史参考校正高度h</p></li></ul><figure><img src="/2020/02/22/apollo-track/21.png" alt="template"><figcaption>template</figcaption></figure><blockquote><p>此处矫正的三维尺寸在后面的<code>Transform</code>部分是否也被采用</p></blockquote><ol start="5" type="1"><li><p>生成假设</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 评估新检测目标与targets的相似性</span></span><br><span class="line"><span class="comment">// @param [in]: track_objects :该帧检测器新检测到的目标</span></span><br><span class="line"><span class="comment">// @param [in/out]: </span></span><br><span class="line"><span class="comment">// output:target匹配第(frame_id)帧中的第几个检测物(track_object),</span></span><br><span class="line"><span class="comment">//        并将该track_object加入到target的tracked_objects中</span></span><br><span class="line">GenerateHypothesis(track_objects);</span><br></pre></td></tr></table></figure><p>其中对应的主要成员变量类型<code>Hypothesis</code>的定义为:（此为target和object的）</p><p><img src="/2020/02/22/apollo-track/666.png"></p><p>处理函数：</p><p><img src="/2020/02/22/apollo-track/13.png"></p><p>得到target与对应det_obj的匹配分数后，根据分数由大到小分配,最终将检测物体(det_obj)加入到匹配分数最高的target的tracked_objects中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target.Add(det_obj); </span><br><span class="line"><span class="comment">//将det_obj添加到给定的target的tracked_objects中,并将该target的lost_age清零</span></span><br></pre></td></tr></table></figure><p>除了上面的四个分数，最终score还需要加上不同物体类型切换的代价值。</p><figure><img src="/2020/02/22/apollo-track/10.png" alt="type_change_cost"><figcaption>type_change_cost</figcaption></figure></li><li><p>创建新跟踪目标(target)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> new_count = CreateNewTarget(track_objects);</span><br></pre></td></tr></table></figure><p>由<code>track_objects</code>创建新的跟踪目标的条件有：</p><ol type="1"><li>首先该det_obj与现有的target的匹配分数很小，即该det_obj与现有target匹配失败<ol start="2" type="1"><li>该det_obj的box需要是有效的(bbox宽高大于20同时小于图像宽高)</li><li>该det_obj的box矩形没有被某个target的bbox覆盖 ,此处target的bbox指tracked_objects中最近检测的bbox</li><li>在上述条件都满足的前提下，需满足det_obj的高度大于最小模板的高度,也可以是未知类型(此时高度的模板未知)</li></ol></li></ol></li><li><p>超过存活周期(lost_age&gt;5)的target,否则执行(即正常跟踪的target)下列方法，通过<code>latest_object</code>进行相应更新.并调用对应的<code>滤波方法</code>进行预测</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target.UpdateType(frame);</span><br><span class="line">target.Update2D(frame);</span><br></pre></td></tr></table></figure><ul><li><p><strong>UpdateType():</strong></p><p>对于未丢失检测(lost_age=0)的target:</p><ol type="1"><li>计算该target的最近检测目标(latest_object-&gt;object)的高度与模板中等尺寸的高度接近程度,接近程度由高斯分布衡量:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//~N(mu=1.0,sigma=0.3)  反映了object的box_height与模板中等高度的接近程度</span></span><br><span class="line"><span class="keyword">float</span> alpha = gaussian(</span><br><span class="line">        <span class="built_in">rect</span>.<span class="built_in">height</span> /</span><br><span class="line">            (<span class="number">50</span> * (kMidTemplateHWL.at(object-&gt;sub_type).at(<span class="number">0</span>) + <span class="number">0.01f</span>)),</span><br><span class="line">        <span class="number">1.0f</span>, target_param_.type_filter_var());</span><br><span class="line"><span class="comment">//该target同类型的probs会往上叠加(在不同帧之间)，因为每帧该target都有一个对应的latest_object</span></span><br><span class="line">type_probs[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(object-&gt;sub_type)] += alpha;</span><br></pre></td></tr></table></figure><p>根据上述最大的<code>type_probs</code>更新target的对应目标类型</p><ol start="2" type="1"><li>将上述(alpha, object-&gt;size(0), object-&gt;size(1),object-&gt;size(2))组成4维向量，将此测量量添加到该target的<code>MaxNMeanFilter world_lwh</code>及<code>MeanFilter world_lwh_for_unmovable</code>中：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">world_lwh.AddMeasure(size_measurement); <span class="comment">//MaxNMeanFilter window=15 根据alpha由大到小</span></span><br><span class="line">world_lwh_for_unmovable.AddMeasure(size_measurement); <span class="comment">//测量值的均值和方差</span></span><br></pre></td></tr></table></figure><figure><img src="/2020/02/22/apollo-track/19.png" alt="MaxNMeanFilter"><figcaption>MaxNMeanFilter</figcaption></figure><p>这一步将得到该target 的15次测量值，按照alpha由大到小排序，并取平均更新3d object size,其中的object为该target的lastest_obj</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object-&gt;type == base::ObjectType::UNKNOWN_UNMOVABLE) &#123;</span><br><span class="line">  object-&gt;<span class="built_in">size</span> =</span><br><span class="line">      world_lwh_for_unmovable.get_state().block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">1</span>, <span class="number">0</span>).cast&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  object-&gt;<span class="built_in">size</span> = world_lwh.get_state().block&lt;<span class="number">3</span>, <span class="number">1</span>&gt;(<span class="number">1</span>, <span class="number">0</span>).cast&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>camera:</p><p>6mm : reliable z is 40(m) ,intrinsic(f) is approximate is 2000(像素)</p><p>12mm:reliable z is 80(m),instrinsic(f) is approximate si 4000(像素)</p></blockquote></li><li><p><strong>Update2D():</strong> 更新2d box的大小。</p><ol type="1"><li><p>向滤波器中添加测量值,进行滤波计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">measurement &lt;&lt; <span class="built_in">rect</span>.<span class="built_in">width</span>, <span class="built_in">rect</span>.<span class="built_in">height</span>;</span><br><span class="line">image_wh.AddMeasure(measurement);<span class="comment">//一阶低通filter</span></span><br><span class="line">measurement &lt;&lt; center.x, center.y;</span><br><span class="line">image_center.Correct(measurement);<span class="comment">//Kalman_Filter</span></span><br></pre></td></tr></table></figure></li><li><p>更新:得到该target最近最近检测物体(latest_object)的projected_box(单位：米)</p><figure><img src="/2020/02/22/apollo-track/20.png" alt="2d box update"><figcaption>2d box update</figcaption></figure></li></ol></li></ul><ol start="8" type="1"><li><p>在Association之后通过IOU合并重复的targets(可能是不同相机得到的)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CombineDuplicateTargets();</span><br></pre></td></tr></table></figure><ul><li><p>对目前的targets_两两之间计算其各自含有的tarcked_objects之间的IOU以及box宽和高的差异，计算得到score (此处计算的tracked_object要求他们的时间戳之差小于0.05，同时来自不同传感器)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">score += common::CalculateIOUBBox(box1, box2); </span><br><span class="line">...</span><br><span class="line">score -= <span class="built_in">std</span>::<span class="built_in">abs</span>((rect1.<span class="built_in">width</span> - rect2.<span class="built_in">width</span>) *</span><br><span class="line">                              (rect1.<span class="built_in">height</span> - rect2.<span class="built_in">height</span>) /</span><br><span class="line">                              (rect1.<span class="built_in">width</span> * rect1.<span class="built_in">height</span>));</span><br></pre></td></tr></table></figure><p>将最终平均得分作为这两个<code>target</code>之间的相似程度，并将结果保存到score_list中(包括了两个target的索引及其得分)</p></li><li><p>按照得分从大到小排序依次匹配，可以看出这一步骤与<code>OMTObstacleTracker::GenerateHypothesis()</code>相似不同的是我们这里要删除匹配成功的两个target中<code>id</code>大的那个,并将删除的那个target_del中的tracked_obj转移到target_save中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (targets_[pair.target].id &gt; targets_[pair.object].id) &#123;</span><br><span class="line">  index1 = pair.object;</span><br><span class="line">  index2 = pair.target;</span><br><span class="line">&#125;</span><br><span class="line">Target &amp;target_save = targets_[index1];</span><br><span class="line">Target &amp;target_del = targets_[index2];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target_del.Size(); i++) &#123;</span><br><span class="line">  <span class="comment">// no need to change track_id of all objects in target_del</span></span><br><span class="line">  target_save.Add(target_del[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并将target_save(target的引用)中的tracked_objects按照帧id(frame id)由小到大排序，并更新lastest_object。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(</span><br><span class="line">    target_save.tracked_objects.<span class="built_in">begin</span>(), target_save.tracked_objects.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="keyword">const</span> TrackObjectPtr object1, <span class="keyword">const</span> TrackObjectPtr object2) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> object1-&gt;indicator.frame_id &lt; object2-&gt;indicator.frame_id;</span><br><span class="line">    &#125;);<span class="comment">//将targe_save中的tracked_objects按照帧的id由小到大排序</span></span><br><span class="line">target_save.latest_object = target_save.get_object(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>然后将target_del中的tracked_objects给清零，最后调用<code>ClearTargets()</code>即可将<code>targets_</code>多余的target清除掉(将target从后往前填空)</p></li></ul></li><li><p>对经过滤波处理的box(单位：米)映射回图像坐标系（像素）</p><p>​</p></li></ol></li></ol><h2 id="tracker_-associate3dframe根据3d信息关联">tracker_-&gt;Associate3D(frame):根据3D信息关联</h2><h3 id="更新reference">1. 更新reference</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reference_.UpdateReference(frame,targets_);</span><br></pre></td></tr></table></figure><p>其中包含的数据结构有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Reference</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> area = <span class="number">0.0f</span>; <span class="comment">//box的面积</span></span><br><span class="line">  <span class="keyword">float</span> k = <span class="number">0.0f</span>;    <span class="comment">//object.H/box.h</span></span><br><span class="line">  <span class="keyword">float</span> ymax = <span class="number">0.0f</span>; <span class="comment">//box的bottom right</span></span><br><span class="line">&#125;;<span class="comment">//可参考的Target（CAR,VAN）所对应的属性</span></span><br></pre></td></tr></table></figure><p><code>Obstacle_reference</code>类中的主要参数:主要含义是<code>ref_map_</code>中存储了<code>reference_</code>对应元素的索引，即ref_map_中各个位置存储了索引，索引对应于<code>reference _</code>中的的对应Reference属性。</p><p><img src="/2020/02/22/apollo-track/22.png"></p><p>参数的相关默认值：</p><p><img src="/2020/02/22/apollo-track/27.png"></p><p><strong><code>ObstacleReference::Init</code>的初始化中执行的操作：</strong> 将图像下采样(ref_width_=width/25,ref_height_=height/25),将init_ref_map的大小设置为(ref_height_,ref_width_)的大小.然后对<code>init_ref_map</code>进行初始化,<code>init_ref_map</code>是一个嵌套vector结构,只对ref图像的下半部分处理，去除边缘，然后将这一部分区域的<code>init_ref_map</code>置为0，如蓝色区域所示。</p><p><img src="/2020/02/22/apollo-track/24.png"></p><p><img src="/2020/02/22/apollo-track/26.png"></p><p><strong><code>Reference update</code>中更新Reference中的相关参数</strong></p><ul><li><p><code>reference_</code>中的所有reference的area每次更新衰减0.98</p></li><li><p>​ 对于每个target中最近检测到的物体，如果是可以参考的类型(CAR,VAN)，同时其box的高度大于50，box的底边位置大于内参矩阵中的c_y(即box尽可能位于图像底部),此时该target可以被参考。将该box的底边中心点也进行下采样(y_discrete=y/25,x_discrete=x/25),这样可以与<code>ref_map</code>的尺寸对应。 ​ 如果此中心点所对应的<code>ref_map</code>为0(即该点对应的参考图第一次被使用)，将其对应的Reference信息push到数组<code>reference_</code>中存储，并将<code>ref_map</code>中对应位置置为当前<code>refs</code>存储的元素数(即将refs中对应的索引存储到ref_map的对应位置中);否则，若该点对应的ref_map大于零(表示该点已经存在某个物体，其中存储的值为当时的<code>refs</code>中对应的索引)，同时此时box的area大于之前存在的reference的area，则将属性进行替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.area = box.Area();</span><br><span class="line">r.ymax = y;</span><br><span class="line">r.k = obj-&gt;<span class="built_in">size</span>[<span class="number">2</span>] / (y - box.ymin); <span class="comment">// H/h</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>通过reference检测Ground</strong></p><p>​ 首先对于目前<code>refs</code>存储的所有<code>reference</code>，将其对应的box底边位置（y_max）以及深度倒数<code>1/z_ref</code>存储到<code>vd_samples</code>中,当reference的数量大于<code>min_nr_samples=6</code>时，可进行Ground的检测(需要在线标定的相机Pitch角度和相机离地平面的高度)</p><p><img src="/2020/02/22/apollo-track/28.png"></p><p><strong>DetetGround:</strong></p><p>若给定了相机坐标系下的平面，则由<span class="math inline">\(Ax+By+Cz+D=0 -&gt; a*y+b*disp+c=0\)</span> : ground4-&gt;ground3:</p><p><img src="/2020/02/22/apollo-track/29.png"></p><p><img src="/2020/02/22/apollo-track/IMG_0304.jpg" style="zoom:30%;"></p><p>否则根据之前的存储的<code>reference</code>进行地平面的检测,<code>CameraGroundPlaneDetector::DetectGroundFromSamples()</code></p><p>ground3与ground4的对应关系如上图所示，通过采样{y_max,1/z}即边界框下边界和深度的倒数即可通过一致性采样得到模型参数。</p><ul><li><p><strong>RobustBinaryFitRansac()</strong></p><p>两个功能函数：</p><ul><li>```c++ template <typename t> //a<em>y+b</em>disp + c = 0-&gt;disp = p0<em>y+p1 通过采样点建立模型 void GroundHypoGenFunc(const T </em>v, const T <em>d, T </em>p) { // disp = p0 * y + p1 -&gt; l = {p0, -1, p1} T x[2] = {v[0], d[0]}; T xp[2] = {v[1], d[1]}; T l[3] = {0}; common::ILineFit2d(x, xp, l); p[0] = -l[0] * common::IRec(l[1]); p[1] = -l[2] * common::IRec(l[1]); } <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;c++</span><br><span class="line">  template &lt;typename T&gt; &#x2F;&#x2F;平面拟合 代价函数</span><br><span class="line">  void GroundFittingCostFunc(const T *p, const T *v, const T *d, int n,</span><br><span class="line">                             int *nr_inlier,  &#x2F;&#x2F; NOLINT compatible for i-lib</span><br><span class="line">                             int *inliers,</span><br><span class="line">                             T *cost,  &#x2F;&#x2F; NOLINT</span><br><span class="line">                             T error_tol) &#123;</span><br><span class="line">    *cost &#x3D; static_cast&lt;T&gt;(0.0f);</span><br><span class="line">    *nr_inlier &#x3D; 0;</span><br><span class="line">    const T *refx &#x3D; v;</span><br><span class="line">    const T *refp &#x3D; d;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">      T d_proj &#x3D; refx[0] * p[0] + p[1];</span><br><span class="line">      T proj_err &#x3D; static_cast&lt;T&gt;(fabs(d_proj - refp[0]));</span><br><span class="line">      if (proj_err &lt; error_tol) &#123;</span><br><span class="line">        inliers[(*nr_inlier)++] &#x3D; i;</span><br><span class="line">        *cost +&#x3D; proj_err;</span><br><span class="line">      &#125;</span><br><span class="line">      ++refx;</span><br><span class="line">      ++refp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></typename></li></ul><p>以此为模板参数执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">common::RobustBinaryFitRansac&lt;<span class="keyword">float</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                              GroundHypoGenFunc&lt;<span class="keyword">float</span>&gt;,</span><br><span class="line">                              GroundFittingCostFunc&lt;<span class="keyword">float</span>&gt;, <span class="literal">nullptr</span>&gt;(</span><br><span class="line">          vs, ds, count_vd, p, &amp;nr_inliers, inliers, kThresInlier, <span class="literal">false</span>, <span class="literal">true</span>,</span><br><span class="line">          <span class="number">0.99f</span>, kMinInlierRatio)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部主要处理过程</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RobustBinaryFitRansac</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">int</span> nr_trials = IRansacTrials(s, confidence, inlierprob);<span class="comment">//获取Ransac尝试次数 (此处是16)</span></span><br><span class="line">    <span class="keyword">while</span> (nr_trials &gt; sample_count) &#123;</span><br><span class="line">        IRandomSample(indices, s, n, &amp;rseed); <span class="comment">//随机采样 从[0,n)中每次采2个索引</span></span><br><span class="line">        ...</span><br><span class="line">        HypogenFunc(samples_x, samples_xp, tmp_model); <span class="comment">//通过两个采样点获取模型参数</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//通过其他样本数据，验证获取的模型参数，计算代价 error_tol=KThresInlier判断内点的阈值</span></span><br><span class="line">        CostFunc(tmp_model, x, xp, n, &amp;nr_inliers, inliers + n, &amp;cost, error_tol);</span><br><span class="line">    <span class="keyword">if</span> ((nr_inliers &gt; *consensus_size) ||</span><br><span class="line">        (nr_inliers == *consensus_size &amp;&amp; cost &lt; best_cost)) &#123;</span><br><span class="line">      *consensus_size = nr_inliers; <span class="comment">//目前匹配的最多的内点数</span></span><br><span class="line">      best_cost = cost;</span><br><span class="line">      ICopy(tmp_model, model, k); <span class="comment">//将匹配内点数最多的模型导出</span></span><br><span class="line">        <span class="comment">// record inlier indices 将匹配最多的模型的内点索引记录</span></span><br><span class="line">      ICopy(inliers + n, inliers, *consensus_size);  </span><br><span class="line">      <span class="keyword">if</span> (adaptive_trial_count) &#123; <span class="comment">//自适应尝试</span></span><br><span class="line">        tmp_inlierprob = IDiv(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(*consensus_size), n);</span><br><span class="line">        <span class="keyword">if</span> (tmp_inlierprob &gt; actual_inlierprob) &#123;</span><br><span class="line">          actual_inlierprob = tmp_inlierprob;</span><br><span class="line">                <span class="comment">//调整(任意一个点为内点)的概率，以此调整trial次数</span></span><br><span class="line">          nr_trials = IRansacTrials(s, confidence, actual_inlierprob);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ILineFit2dTotalLeastSquare</strong>:最小二乘拟合 最后根据这些内点进行最小二乘拟合,得到平面<span class="math inline">\(a*y+b*disp + c = 0\ -&gt; p0*y - disp +p1=0\)</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common::ILineFit2dTotalLeastSquare(vd, l_best, count);</span><br></pre></td></tr></table></figure></li><li><p><strong>GetGroundPlanePitchHeight()</strong>:将ground3平面转换为相机坐标系下的ground4,并得到相机高度(height)和角度(pitch): <img src="/2020/02/22/apollo-track/31.png"></p></li><li><p><strong>GroundPlaneTracker()</strong> 构造函数： 注意到tracker的存储是从后往前添加(低索引存储新值)</p><p><img src="/2020/02/22/apollo-track/32.png"></p></li></ul><hr><blockquote><p>在机器人领域中，平面检测有多种方法，例如：</p><p>Plane segment finder:algorithm, implementation and applications[C].中采用了霍夫变换方法； Learning compact 3D models of indoor and outdoor environments with a mobile robot中通过随机选择3D点，并在其周围区域增长的方式查找最大点集拟合平面参数； Automatic 3D building reconstruction using plane-roof structures中通过随机一致性采样方法找到局部多边形并合并。</p></blockquote><p><strong>基于RANSAC随机一致性采样的鲁棒方法</strong></p><p>通过ransac算法不断的对平面方程参数进行估算，先介绍一下RANSAC算法:</p><p>RANSAC通过反复选取数据中的一组随机子集来达成目标，被选取的子集被假设为局内点，并通过下属方法进行验证： (1) 有一个模型适用于假设的局内点，及所有未知参数都能从假设的局内点中计算得出（<strong>拟合模型</strong>） (2) 用（1）中得到的模型去测试其他的数据，如果某个点适用于估计的模型(距离小于阈值)，认为它也是局内点。 (3) 如果有足够多的点被归类为假设的局内点，则估计的模型就足够合理。 (4) 然后，用所有假设的局内点重新估计模型，因为它仅仅被初始的假设局内点估计过。 (5) 最后根据估计局内点与模型的错误率来评估模型。</p><p>这个过程重复执行固定次数，每次产生的模型要么因为局内点太少而被舍弃，要么因为它比现有的模型更好而被采用。</p><p>相比于最小二乘采用了所有点，RANSAC仅采用局内点进行模型的计算，局外点并不影响模型效果。</p><p>对于平面的拟合基本步骤如下: (1) 随机取样：随机抽取数据作为样本 (2) 拟合模型：根据样本获取模型参数M (3) 判断距离: 判断所有数据点到模型的距离，将距离小于阈值的加入局内点，记录此时模型的局内点数 (4) 判断：局内点数目&gt;阈值，则利用此时的局内点重新估计模型，重复3-5次，将得到的局内点数最多的模型即为当前 的最佳模型；局内点数目&lt;阈值, 则跳出 (5) 跳到步骤(1)，循环N次</p><hr><h3 id="移除异常的移动">2. 移除异常的移动</h3><p>首先根据其位置信息，移除异常移动的target，并将这些target的最新检测目标创建新的target,同时更新这些新创建的target的2D和类型信息(通过相应的滤波器更新当前状态)</p><p><img src="/2020/02/22/apollo-track/30.png"></p><p>然后对target进行三维信息更新(target.Update3D),更新的状态有:</p><blockquote><p>FirstOrderRCLowPassFilter direction</p><p>MeanFilter world_center_for_unmovable;</p><p>KalmanFilterConstVelocity world_center;</p><p>KalmanFilterConstState&lt;2&gt; world_center_const; // constant position kalman state</p><p>MeanFilter world_velocity;</p><p>MeanFilter displacement_theta;//位移方向</p></blockquote><p>主要处理得到了<code>速度、位置和朝向</code></p><h2 id="tracker_-trackframe跟踪算法">tracker_-&gt;Track(frame):跟踪算法</h2>]]></content>
      
      
      <categories>
          
          <category> Apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> track </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单视图衡量论文阅读</title>
      <link href="/2020/02/20/single-view-metrology/"/>
      <url>/2020/02/20/single-view-metrology/</url>
      
        <content type="html"><![CDATA[<p>Single View Metrology 和3D bbox estiomation using deep learning and geometry 论文阅读笔记</p><a id="more"></a><h2 id="d-bbox-estimation-using-deep-learning-and-geometry">3D bbox estimation using deep learning and geometry</h2><p>通过神经网络输出三维物体朝向(3D object orientation)，三维物体尺寸(3d object dimensions)，结合2Dbbox 的几何约束，使能够恢复一个稳定的3D物体姿态（<span class="math inline">\(R,T\)</span>），通过Kitti数据集上的三维物体尺寸信息和三维物体bbox进行评估。 kitti数据集只评估3Dbbox的方向(orientation estimate)；此方法另外引入了3个额外的度量信息评估3d Box的准确性</p><ul><li>distance to center of box</li><li>distance to the center of the closest bounding box face</li><li>the overall bounding box overlap with the ground truth box（3D IOU）</li></ul><h2 id="d-bounding-box-estimation">3D Bounding box estimation</h2><p>前提:一个3D bbox 的投影应该包裹2D bbox，并同时假设2D detector 训练得到的bbox 是与3d bbox 投影有关的。</p><p><strong>2D bbox 每一边至少匹配3D bbox的一个角</strong> 即2D bbox 需要包裹住 3D bbox</p><p>3D box的描述为:</p><ul><li>中心位置 <span class="math inline">\(T=[t_x,t_y,t_z]^T\)</span>, (center of translation)</li><li>尺寸 <span class="math inline">\(D=[d_x,d_y.d_z]\)</span> （dimension）</li><li>方向 <span class="math inline">\(R(\theta,\phi,\alpha)\)</span>, (orientation) 采用方向角、仰角、翻滚角</li></ul><h3 id="d-bbox的投影与2d-bbox之间的约束关系">3D bbox的投影与2D bbox之间的约束关系</h3><p>在相机坐标系下确定位姿<span class="math inline">\((R,T)\in SE(3)\)</span> ,相机内参矩阵<span class="math inline">\(K\)</span> ,则一个物体坐标系下的三维坐标点<span class="math inline">\(X_o=[X,Y,Z,1]^T\)</span>投影到图像中的坐标<span class="math inline">\(x=[x,y,1]\)</span>的转换关系： <span class="math display">\[x=K[R\ \ \ \ T]X_o\]</span> 假设原始的物体坐标系的原点位于3D bbox 的中心，并且物体尺寸已知，则3D bbox顶点的坐标可以描述为： <span class="math display">\[X_1 = [d_x/2,d_y/2,d_z/2]^T,X_2 = [-d_x/2,d_y/2,d_z/2]^T,...,X_8=[-d_x/2,-d_y/2,-d_z/2]\]</span> 约束条件是2D bbox(<span class="math inline">\(x_{min},y_{min},x_{max},y_{max}\)</span>)的每一顶点至少被一个3D bbox 角点的投影得到，例如： 考虑3d bbox 顶点 <span class="math inline">\(X_0=[d_x/2,-d_y/2,d_z/2]\)</span> 投影到2d bbox左边 坐标<span class="math inline">\(x_{min}\)</span>,这用点对边的约束表示为下列等式。</p><figure><img src="/2020/02/20/single-view-metrology/image-20200220152658062.png" alt="image-20200220152658062"><figcaption>image-20200220152658062</figcaption></figure><p>其中<span class="math inline">\((.)_x\)</span>表示透视投影的x坐标，同样的方式可以推导出2d bbox的参数(<span class="math inline">\(x_{min},y_{min},x_{max},y_{max}\)</span>),总体来说，2D bbox的顶点为3d bbox提供了四个约束，但是这不足以限制3d bbox的九自由度（three for translation, three for rotation, and three for box dimensions），需要bbox的几何特性以及视觉外观进一步约束3d box。</p><p><img src="/2020/02/20/single-view-metrology/image-20200220181624364.png" alt="image-20200220181624364" style="zoom:80%;"></p><h3 id="如何选择回归参数">如何选择回归参数</h3><ul><li><p>方向角<span class="math inline">\(R(\theta,\phi,\alpha)\)</span></p></li><li><p>物体尺寸 <span class="math inline">\(D=[d_x,d_y.d_z]\)</span></p><p>估计物体尺寸而不估计位置的原因是物体尺寸的方差较小(车辆的尺寸基本一致)，同时不会因为旋转而发生变化(因为我们同时也在回归方向角)，物体尺寸的估计更容易与得到的物体类别紧密联系。</p></li></ul><p>通过回归得到的物体尺寸、3D bbox 方向、2D bbox 可以求得 物体位置，</p><p>仅考虑一般情况，3D bbox的8个顶点可以投影到任意的2D bbox的4个边，总共就有<span class="math inline">\(8^4=4096\)</span>中情况，但在大多数场景下，可以假定目标是竖直的，因此，2D bbox的顶部和底部只对应于3D bbox的顶部和底部(1024中情况)，同时目标不发生翻滚时(roll=0)，则垂直边的2D bbox 坐标<span class="math inline">\(x_{min},x_{max}\)</span>只能与3D bbox中的垂直边相关联，kitti中默认(roll = 0 ,pitch =0)，因此，最终投影关系的匹配数量只有64种情况,下图给出了一些匹配的情况，正面为蓝色，背面为红色框。</p><p><img src="/2020/02/20/single-view-metrology/corre.png" style="zoom: 67%;"></p><p><img src="/2020/02/20/single-view-metrology/m248gym63e.jpg" style="zoom:80%;"></p><h3 id="orientation-estimation">Orientation Estimation</h3><p><img src="/2020/02/20/single-view-metrology/image-20200220162637624.png" alt="image-20200220162637624" style="zoom:80%;"></p><p>上图右面的全局图像中，汽车的行驶方向并没有改变，但是在左边截取的图像中 显然汽车的方向发生了变化。因此在相机参考系下通过检测窗口获取物体的方向是不可行的，因为其余在图像中的位置相关。</p><p><img src="/2020/02/20/single-view-metrology/2.png" style="zoom:75%;"></p><p>上图所示，全局方向为<span class="math inline">\(\theta\)</span> (3d bbox方向)，局部方向<span class="math inline">\(\theta_{l}\)</span>为相机中心与检测框中心(假设为目标中心)的射线确定。由于<span class="math inline">\(\theta_l\)</span>会随着检测框中图像的不同而变化，因此训练的参数为<span class="math inline">\(\theta_l\)</span> 。通过给定相机内参<span class="math inline">\(\theta_{ray}\)</span>的计算是很容易的，通过计算的到的<span class="math inline">\(\theta_{ray}\)</span>以及估计得到的局部方向<span class="math inline">\(\theta_{l}\)</span>很容易就可以得到全局方向<span class="math inline">\(\theta=\theta_l+\theta_{ray}-2\pi\)</span>。</p><h3 id="网络结构">网络结构</h3><p><img src="/2020/02/20/single-view-metrology/170408.png" style="zoom:80%;"></p><p>在方向估计时</p><p><img src="/2020/02/20/single-view-metrology/image-20200220173628484.png" alt="image-20200220173628484" style="zoom: 80%;"></p><p><img src="/2020/02/20/single-view-metrology/image-20200220173530008.png" alt="image-20200220173530008" style="zoom:80%;"></p><p>在尺寸估计时，由于同一类别的物体方差很小，因此估计的是相对于标准(平均)尺寸（通过训练集上的尺寸可以计算得到）的差值。</p><p><img src="/2020/02/20/single-view-metrology/173312.png" style="zoom:75%;"></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单视图衡量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo编译过程及存在的问题</title>
      <link href="/2020/02/19/detect_build/"/>
      <url>/2020/02/19/detect_build/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>bazel 降级</p><blockquote><p>Latest Versions of Bazel Doesn't support git_repository (which is still used by tensorflow_hub), so Uninstalling Bazel 0.24.1 and installing Bazel 0.18.1 worked.</p></blockquote><p>https://www.betaflare.com/3714.html</p>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sort和DeepSort论文阅读笔记</title>
      <link href="/2020/02/19/Sort_DeepSort_read/"/>
      <url>/2020/02/19/Sort_DeepSort_read/</url>
      
        <content type="html"><![CDATA[<p>Sort和DeepSort多目标跟踪论文阅读笔记</p><a id="more"></a><h2 id="sort和deepsort论文阅读笔记">Sort和DeepSort论文阅读笔记</h2><h3 id="概述">概述</h3><h4 id="一些术语">1.一些术语</h4><p><strong>Trajectory</strong>(轨迹)：一条轨迹对应这一目标在一个时间段内的位置序列</p><p><strong>Tracklet</strong>(轨迹段)：形成Trajectory过程中的轨迹片段。完整的Trajectory是由属于同一目标的Tracklets组成。</p><p><strong>ID switch</strong>(ID切换)：对于同一个目标，由于跟踪算法误判导致其ID发生切换的次数，理想的跟踪算法ID switch应为0。</p><h4 id="评价指标">2.评价指标</h4><p>最主要的评价指标是<code>MOTA</code> ,该指标包含了三个要素：FP、FN、identity switches(ID switch)。MOTA越高代表跟踪的综合性能越好。</p><h4 id="框架策略">3.框架策略</h4><ul><li><p>Tracking - by - detection(TBD)</p></li><li><p>Detection-Free Tracking(DFT)</p></li></ul><p>MOT问题本质上可以视为数据关联的问题，即如何将不同时刻的检测目标关联起来，关联目标主要以目标<code>motion</code>的建模和<code>apperance</code>即目标的外观作为关联的根据。</p><h3 id="sort">Sort</h3><p>在卡尔曼滤波的基础上+匈牙利算法将<strong>卡尔曼滤波预测的BBox</strong>与<strong>物体检测的BBox</strong>进行了匹配，选择合适的物体检测BBox作为下一时刻的<strong>物体跟踪BBox</strong>。</p><h4 id="detection">1.Detection</h4><p>采用了FasterRCNN，</p><h4 id="estimation-model">2. Estimation Model</h4><p>通过<code>linear constant velocity model</code>（线性恒速度模型）估计帧间物体的位移。 <span class="math display">\[x = [u,v,s,r,\dot{u},\dot{v},\dot{s}]^{T}\]</span> 每一个目标的状态采用上述模型描述，其中<code>u</code>和<code>v</code>分别表示目标中心水平和垂直方向像素位置；<code>s</code>和<code>r</code>分别表示面积(scale)和目标边界框的长宽比(aspect ratio)。当一个检测与目标相关联之后，检测得到的bbox被用于更新目标的状态（被更新的状态中，速度分量由卡尔曼滤波器估计得到）；若没有检测与目标关联，利用线性恒速度模型对其状态进行简单预测无需纠正。</p><h4 id="data-association">3.Data Association</h4><p>在分配检测结果到现有的跟踪目标过程中，每一个跟踪目标的bbox通过卡尔曼滤波器提前预测。然后计算每个检测目标和预测的跟踪目标的bbox的交并比(IOU)作为代价矩阵。最后通过<code>匈牙利算法(Hungarian algorithm)</code>解决最优分配问题，小于阈值<span class="math inline">\(IOU_{min}\)</span>的目标不会分配此检测器。</p><h4 id="creation-and-deletion-of-track-identities">4.Creation and Deletion of Track Identities</h4><p>当目标进入或者离开图像，相应需要创建和销毁跟踪的ID。</p><p>对于创建一个跟踪目标，根据是检测与目标的重叠(IOU)小于一定阈值 <span class="math inline">\(IOU_{min}\)</span> ，即认为此检测是一个未被跟踪的对象，并将其状态进行初始化(形状为检测的bbox形状，速度为0),由于此点速度无法估计，因此速度分量的协方差应初始化为一个较大的值，以表征此不确定性。同时，新加入的目标应经过一段试用期，目标需要与检测相关联，以积累足够的证据，防止<code>false positive</code>。</p><p>跟踪终止，当在<span class="math inline">\(T_{Lost}\)</span>帧没有检测到与之关联的检测。这可以防止跟踪器数量的无限增长和由于<u>长时间不根据检测修正的预测</u>导致的定位误差。一般<span class="math inline">\(T_{Lost}\)</span>被设置为1，因为<code>恒速度模型</code>不能很好的描述目标的动态特性，其次本工作关注于帧与帧之间的跟踪，<code>目标的重识别</code>超出了本工作的内容。另外，尽早地删除丢失的目标有利于提高效率。</p><hr><h3 id="deep-sort">Deep Sort</h3><p>由于Sort对于物体遮挡没有显式地处理，因此其<code>ID Switch</code>很高,因此DeepSort中融入了apperance information,即结合了运动和外观的信息。</p><h4 id="deep-association-metric">1. Deep Association Metric</h4><ul><li><strong>state space:</strong> <span class="math inline">\((u,v)\)</span> 为bbox中心位置，<span class="math inline">\(r\)</span>为纵横比，<span class="math inline">\(h\)</span>为高度，以及它们在图像坐标系下的相对速度</li></ul><p><span class="math display">\[(u,v,\gamma,h,\dot{x},\dot{y},\dot{\gamma},\dot{h})\]</span></p><p>依然采取恒速度的线性观测模型进行估计，直接估计的状态为<span class="math inline">\((u,v,r,h)\)</span>，</p><ul><li><p><strong>assignment problem</strong>:</p><p>Sort 中将新检测到的物体与状态估计得到的预测框进行匹配采用的是<code>匈牙利算法</code>。在DeepSort中需要综合运动和外观信息进行匹配,对此设计了两个合适的度量。</p><p><em>1.motion information:</em> Mahalanobis distance <span class="math display">\[d^{(1)}(i,j)=(d_j-y_i)^{T}S_i^{-1}(d_j-y_i)\]</span> 其中<span class="math inline">\(d_j\)</span>为第<span class="math inline">\(j\)</span>个检测到的bbox，<span class="math inline">\(y_i\)</span>为第<span class="math inline">\(i\)</span>个估计的bbox，马氏距离,指标为,本文阈值为<span class="math inline">\(t^{(1)} = 9.4877\)</span> <span class="math display">\[b_{i,j}^{(1)}=1[d^{(1)}(i,j)\leq t^{(1)}]\]</span> <em>2.apperance information:</em> cosine distance <span class="math display">\[d^{(2)}(i,j)=min\{1-r_j{}^{T}r_k^{(i)}|r_k^{(i)}\in R_i\}\]</span> 对于每个新检测到的bbox <span class="math inline">\(d_j\)</span>，我们计算外观描述（apperance descrioptor）<span class="math inline">\(r_j\)</span>,<span class="math inline">\(||r_j||=1\)</span>。同时，创建<span class="math inline">\(R_k=\{r_k^{(i)}\}_{k=1}^{L_k}\)</span>为最近<span class="math inline">\(L_k=100\)</span>次成功跟踪后 物体检测bbox对应的<span class="math inline">\(L_k\)</span>个特征向量集合。然后第二种度量方式通过第<span class="math inline">\(i\)</span>个跟踪物体特征向量与第<span class="math inline">\(j\)</span>个检测特征向量之间的最小余弦距离表示。</p><p>同样引入一个二元变量表示此关联是否被允许： <span class="math display">\[b_{i,j}^{(2)}=1[d^{(2)}(i,j)\leq t^{(2)}]\]</span> 外观描述特征向量如何获取？文章中采用了CNN网络获取，结构如下：</p><p><img src="/2020/02/19/Sort_DeepSort_read/cnn.png" style="zoom:75%;"></p><p>综上，通过加权获得最终的度量标准:<span class="math inline">\(c_{i,j}=\lambda d^{(1)}(i,j)+(1-\lambda)d^{(2)}(i,j)\)</span>，同时对应的关联标准<span class="math inline">\(b_{i,j}=\prod_{m=1}^{2}b_{i,j}^{(m)}\)</span>,当相机有较大运动时，取<span class="math inline">\(\lambda=0\)</span>是合适的选择。但基于卡尔曼滤波器推断的马氏距离仍用于忽视不可行的分配。</p></li><li><p><strong>Matching Cascade</strong></p><p>解决了度量问题后，如何匹配track 和 detect，文中提出如下方式：</p><p><img src="/2020/02/19/Sort_DeepSort_read/match.png"></p><p>输入为跟踪集合和检测集合，索引分别为<span class="math inline">\(T,D\)</span> ;首先根据之前的公式计算了代价矩阵<strong>C</strong>和门控矩阵<strong>B</strong>。然后对跟踪器最长存在时间进行迭代，在第6行中选择跟踪器子集<span class="math inline">\(T_n\)</span>(过去n帧都没有被检测器匹配的跟踪目标)，第7行根据代价矩阵匹配<span class="math inline">\(T_n\)</span>和为别分配的检测器目标。第8，9行更新匹配和未匹配的集合，最终返回<span class="math inline">\(M,U\)</span> 。</p><p>显然此循环保证了优先将检测的新目标分配给最近的跟踪。最终匹配阶段，通过和Sort中一样的IOU关联算法作用于age=1的未被匹配跟踪目标，这有助于解释外观的突然变化（例如由于被静态场景局部遮挡）。</p></li><li><p><strong>Deep Apperance Descriptor</strong></p><p>通过在行人重识别数据集上的训练CNN。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标跟踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>caffe 学习伊始</title>
      <link href="/2020/02/18/caffe-learn-start/"/>
      <url>/2020/02/18/caffe-learn-start/</url>
      
        <content type="html"><![CDATA[<p>caffe 学习系列 <a id="more"></a></p><p>打算系统学习caffe源码，现在这占个坑 目前打算阅读顺序:SyncedMemory-&gt;Blob-&gt;layer-&gt;Net-&gt;solver 将开一系列笔记： (1)caffe源码学习SyncedMemory (2)caffe源码学习Blob ...</p>]]></content>
      
      
      <categories>
          
          <category> caffe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> caffe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中的detector</title>
      <link href="/2020/02/18/apollo-detector/"/>
      <url>/2020/02/18/apollo-detector/</url>
      
        <content type="html"><![CDATA[<p>Apollo中Detector的相关结构 <a id="more"></a></p><h2 id="kitti数据结构">KITTI数据结构</h2><p>kitti数据集采集方式参考http://www.cvlibs.net/datasets/kitti/setup.php <img src="/2020/02/18/apollo-detector/passat_sensors_920.png" style="zoom:50%;"></p><p>数据集的标签形式： <img src="/2020/02/18/apollo-detector/kitti_label.png" style="zoom:80%;"></p><p>label描述:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#Values    Name      Description</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">   1    type         Describes the type of object: &#39;Car&#39;, &#39;Van&#39;, &#39;Truck&#39;,</span><br><span class="line">                     &#39;Pedestrian&#39;, &#39;Person_sitting&#39;, &#39;Cyclist&#39;, &#39;Tram&#39;,</span><br><span class="line">                     &#39;Misc&#39; or &#39;DontCare&#39;</span><br><span class="line">   1    truncated    Float from 0 (non-truncated) to 1 (truncated), where</span><br><span class="line">                     truncated refers to the object leaving image boundaries</span><br><span class="line">   1    occluded     Integer (0,1,2,3) indicating occlusion state:</span><br><span class="line">                     0 &#x3D; fully visible, 1 &#x3D; partly occluded</span><br><span class="line">                     2 &#x3D; largely occluded, 3 &#x3D; unknown</span><br><span class="line">   1    alpha        Observation angle of object, ranging [-pi..pi]</span><br><span class="line">   4    bbox         2D bounding box of object in the image (0-based index):</span><br><span class="line">                     contains left, top, right, bottom pixel coordinates</span><br><span class="line">   3    dimensions   3D object dimensions: height, width, length (in meters)</span><br><span class="line">   3    location     3D object location x,y,z in camera coordinates (in meters)</span><br><span class="line">   1    rotation_y   Rotation ry around Y-axis in camera coordinates [-pi..pi]</span><br><span class="line">   1    score        Only for results: Float, indicating confidence in</span><br><span class="line">                     detection, needed for p&#x2F;r curves, higher is better.</span><br></pre></td></tr></table></figure></blockquote><h2 id="多任务yolo--3d">多任务YOLO -3D</h2><ul><li><p><strong>3D bounding box描述</strong></p><p><img src="/2020/02/18/apollo-detector/3d_bbox.png" style="zoom:80%;"></p><p>​ 对任意相机坐标系下的障碍物3D bbox有9个自由度，因此可以由9个参数表示（中心点<span class="math inline">\(T={\{X,Y,Z}\}\)</span>,长宽高<span class="math inline">\(D=\{L,W,H\}\)</span>,以及各坐标轴旋转角<span class="math inline">\(R=\{\phi,\varphi,\theta\}\)</span>）,等价与3D框的8点描述(需要24个参数)。</p><p>​ 由3D bbox通过相机内参投影即可获得2D bbox　但是反之直接由2D bbox得到完整3D bbox是不可行的。</p><p>​ 首先通过一些假设简化需要获取的3D框参数数量：</p><p>​ １）地面平行假设：</p><p>​ - 通过假设地面平行，则3D障碍物只沿垂直地面的坐标轴旋转，另两个方向并未旋转，即只有yaw偏移角度， 令roll和pitch的旋转角均为0</p><p>​ - 此时，障碍物中心高度与相机高度相当，可简化认为障碍物Z=0</p><p><img src="/2020/02/18/apollo-detector/2dto3d.png" style="zoom:80%;"></p><p>​ 通过成熟的2D障碍物检测算法，可以较准确的得到图像上2D边界框的像素位置(<span class="math inline">\(h,w,c_x,c_y\)</span>)</p><p>​ 对3D障碍物的6维描述中，可以选择神经网络来预测方差较小的参数，例如障碍物的真实物理大小(同类别的障碍物的物理大小不会出现量级上的偏差)，同时yaw旋转角度也能较容易的预测。</p><p>​ 目前，无法通过训练直接得到的参数是障碍物中心相对相机坐标系的偏移量X和Y,若得到X和Y，即通过<span class="math inline">\(\sqrt{X^2+Y^2}\)</span>计算得到在同一水平面上障碍物离相机的真实距离，也就是实现了单目测距。</p><p>实现单目相机3D障碍物检测所需的步骤总结如下：</p><ol type="1"><li>训练网络，预测大部分参数：</li></ol><ul><li>图像中障碍物2D bbox检测</li><li>障碍物物理（真实）尺寸（依据同类别物体的方差较小）</li><li>相对偏转角yaw(不因障碍物在图像中位置所影响)</li></ul><ol start="2" type="1"><li>通过图像几何学方法，计算障碍物中心点相对相机坐标系的偏移量X分量和Y分量( <span class="math inline">\(T={X,Y,0}\)</span>)</li></ol></li><li><p><strong>实现多任务的输出</strong>：</p><p>​ 目标检测的2D bbox(单位为像素),3D真实物体尺寸(长宽高，单位为米)，障碍物的类别以及障碍物的相对偏转角(alpha与kitti数据集定义相同)</p><p>​ 模型训练需要注意： ​ (1) 确保数据集标注质量，尤其是3D障碍物框。可借助激光雷达辅助标注</p><p>​ (2) 定义合适的损失函数，可以参考[3D Bounding Box Estimation Using Deep Learning and Geometry][https://arxiv.org/abs/1612.00496]</p><p>​ (3) 相关数据增强，避免过拟合，左右对称翻转有意义，上下翻转无意义。</p><p>​ (4) anchor和yolo相同，是通过聚类获得的。</p><p>​</p><p>在训练完成获得上述参数之后，接下来需要考虑如何计算出障碍物里相机的距离，通过内参矩阵和几何学关系，联系图像中3D障碍物大小（像素）和真实3D坐标系下障碍物大小(单位为米)之间的关系。</p><p><img src="/2020/02/18/apollo-detector/3dbox.png"></p><p>通过单视图衡量([single view metrology][http://ieeexplore-ieee-org-s.ivpn.hit.edu.cn:1080/document/791253])来解释此几何关系：任一物体，已知其实际的长宽高、朝向和距离，则它在图像中的具体形状大小唯一确定，反之亦然。（此处，我们通过物体图像尺寸、实际物理尺寸和朝向角推断物体距离）</p><p>对于每种障碍物，根据其平均尺寸，建立查询表，覆盖360度yaw角度变化，来映射不同的距离，查询表可以定义单位标尺(例如在图像某个2d位置上，高一米的障碍物在图像上有多高）通过单位标尺对应的像素数目，快速查到车的真实高度。</p><p>综上，Apollo中单目相机下的障碍物检测流程为如下图所示，检测速度可达30hz以上。 <img src="/2020/02/18/apollo-detector/3dobstacle_pipe.png"></p></li></ul><p>输入单幅图像－》通过网络预测大部分参数－》基于单视图度量方法，预测剩余参数(距离和中心点坐标) 其中,在车辆颠簸的情况下，相机内参基本不会发生变化，而外参可以借助在线标定(online calibration)得到实时的外参，提高单目测距的准确性。可以通过车道线来校准，两条平行线无穷远处相交，通过车道线信息，可以帮助我们在线调整传感器标定。</p><p>提高单目测距准确性的方法： (1)借助跟踪算法的上下帧之间的关联性，修正物体朝向和速度 (2)激光雷达和毫米波雷达能够提供准确的测距信息，进行传感器融合。 (3)若物体有遮挡，则要求神经网络能够预测遮挡程度的百分比，并根据遮挡情况给出更准确的距离判断。 (4)最终和其他传感器的融合进行测距是必不可少的，当地面坡度不平时，单目相机检测结果在进行传感器融合时，参考应 该降低，融合时是做graph-graph之间的匹配，不需要过度担心相机的准确率。</p><h2 id="apollo中的yolo3d">Apollo中的YOLO3D</h2><p><img src="/2020/02/18/apollo-detector/yolo3dr4.png"></p><p><img src="/2020/02/18/apollo-detector/areaid.png"></p><p><strong>outout_blobs</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">loc_pred</span><br><span class="line">obj_pred</span><br><span class="line">cls_pred</span><br><span class="line">ori_pred</span><br><span class="line">dim_pred</span><br><span class="line">brvis_pred</span><br><span class="line">brswt_pred</span><br><span class="line">ltvis_pred</span><br><span class="line">ltswt_pred</span><br><span class="line">rtvis_pred</span><br><span class="line">rtswt_pred</span><br><span class="line">area_id_pred</span><br><span class="line">vis_pred</span><br><span class="line">cut_pred</span><br><span class="line">conv9</span><br><span class="line">conv10</span><br><span class="line">conv3_3</span><br></pre></td></tr></table></figure><h2 id="cuda编程">CUDA编程</h2><p>核函数使用方法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;&lt;&lt;griddim,blockdim,<span class="keyword">extern</span> shared memory,GPU stream&gt;&gt;&gt;(param...);</span><br></pre></td></tr></table></figure></p><p>其中中间参数可以控制核函数运行所占用的资源： <code>griddim</code>为调用的block数，<code>blockdim</code>为调用的thread数，后面两个参数分别表示动态定义共享内存大小和可使用的SM处理器数。 <img src="/2020/02/18/apollo-detector/cuda_block.png" style="zoom:50%;"></p><p>kernel函数的定义采用<code>__global__</code>修饰符修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resize_linear_kernel &lt;&lt; &lt; grid, block &gt;&gt; &gt;</span><br><span class="line">      (src.gpu_data(), dst-&gt;mutable_gpu_data(),</span><br><span class="line">          origin_channel, origin_height, origin_width,</span><br><span class="line">          stepwidth, height, width, fx, fy);</span><br></pre></td></tr></table></figure><p><img src="/2020/02/18/apollo-detector/kenelprogram.png"></p><h2 id="tensorrt">TensorRT</h2><p>官方开发手册：https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#c_topics</p><p>参考博客:https://www.cnblogs.com/vh-pg/p/11680658.html</p><p>模型从导入TensorRT到执行<code>inference</code>大致经过一下三个阶段:</p><ul><li>Network Definition</li><li>Builder</li><li>Engine</li></ul><p>使用过程中首先通过<code>TensorRT</code>的全局方法<code>creatInferBuilder()</code>创建一个<code>IBuilder</code>类指针，然后由该指针调用<code>IBuilder</code>类创建<code>Network</code>和<code>Engine</code>类的指针。 <code>INetworkDefinition</code>类 <code>INetworkDefinition</code>类即为网络定义，可通过<code>IBuilder</code>类方法<code>creatNetwork()</code>返回其指针。 <code>ICudaEngine</code> <code>ICudaEngine</code>类即为Engine，可通过<code>IBuilder</code>类方法<code>buildCudaEngine()</code>/<code>buildEngineWithConfig()</code>返回其指针。 Engine的运行需要一个运行时的环境，通过<code>createExecutionContext()</code>方法为对应的<code>ICudaEngine</code>生成一个 <code>IExecutionContext</code>类型的运行环境context。</p><p><img src="/2020/02/18/apollo-detector/tensorrtinfer.png"></p><p><img src="/2020/02/18/apollo-detector/apollo_tensorrt.png"></p><p><img src="/2020/02/18/apollo-detector/coordination_04.png"></p><h2 id="transform">Transform</h2><h3 id="成员属性">成员属性</h3><p><img src="/2020/02/18/apollo-detector/trans.png"></p><p>类成员比较简单，但是内部定义的ObjMapper 类的主要内部成员包括了内参矩阵，图像的宽和高， <strong>ry_score_是啥待定</strong> ry是rotation_y的含义 ，以及目标映射参数,每个方向上的方差即位置的不确定度。</p><p><img src="/2020/02/18/apollo-detector/trans2.png"></p><p>​ <img src="/2020/02/18/apollo-detector/trans3.png" style="zoom:80%;"> <img src="/2020/02/18/apollo-detector/home/jachin/space/myblog/blog/source/_posts/apollo-detector/trans4.png" style="zoom:90%;"></p><p>还有objMapper的配置参数：</p><p><img src="/2020/02/18/apollo-detector/trans6.png"></p><p>ObjectTemplateManager 类中管理了物体类别与尺寸的关联：</p><p><img src="/2020/02/18/apollo-detector/trans88.png"></p><p>其初始化中主要执行下列文件：</p><p><img src="/2020/02/18/apollo-detector/trans66.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TemplateMap min_template_hwl_;</span><br><span class="line">TemplateMap mid_template_hwl_;</span><br><span class="line">TemplateMap max_template_hwl_;</span><br></pre></td></tr></table></figure><p>其内部成员变量表示物体类别与对应三个大中小尺寸的对应关系：<code>object_template.pt</code>中定义</p><p><img src="/2020/02/18/apollo-detector/trans99.png"></p><h3 id="transform-过程">Transform 过程</h3><p>具体执行过程，通过循环获取检测到的每一个目标，进行三步处理：</p><p><img src="/2020/02/18/apollo-detector/trans7.png"></p><ul><li><p>首先，通过参数输入检测到的目标，相机内参，图像高宽，以及theta_ray(应该是相机到目标的中心射线的角度)。然后为3d bbox的计算准备相关参数，将参数赋值给obj_mapper_options。</p><p>其中进行了函数<code>MatchTemplates(</code>base::ObjectSubType sub_type, float *dimension_hwl<code>)</code></p><p>分别获取了当前检测到物体类别所对应的模板，包含了大中小三个尺寸。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;base::ObjectSubType, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; &gt; TemplateMap;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/18/apollo-detector/2.png" style="zoom:50%;"></p><p><img src="/2020/02/18/apollo-detector/trans234.png"></p></li><li><p>有了上述信息之后，就可以开始3d BBox的处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 3d bbox处理</span></span><br><span class="line"><span class="comment">// @param [in]: obj_mapper_options</span></span><br><span class="line"><span class="comment">// @param [in/out]: obj_center,dimension_hwl,rotation_y 　其中obj_center未知</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObjMapper::Solve3dBbox</span><span class="params">(<span class="keyword">const</span> ObjMapperOptions &amp;options, <span class="keyword">float</span> center[<span class="number">3</span>],<span class="keyword">float</span> hwl[<span class="number">3</span>], <span class="keyword">float</span> *ry)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// call 3d solver</span></span><br><span class="line">  <span class="keyword">bool</span> success =Solve3dBboxGivenOneFullBboxDimensionOrientation(bbox, hwl, ry, center);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检查输入尺寸的合理性。</p><p>计算3dbox函数如下,主要就是求解3d bbox的位置即center</p><p><img src="/2020/02/18/apollo-detector/trans_over.png"></p><p><img src="/2020/02/18/apollo-detector/trans999.png"></p></li></ul><hr><p>分割一下，上面的有时间再补充</p><p><img src="/2020/02/18/apollo-detector/trans444.png"></p><p>如果2d bbox 么有被截断（在图像范围内）：</p><hr><h3 id="总体流程图">总体流程图：</h3><p><img src="/2020/02/18/apollo-detector/Transform.png"></p><h2 id="参考文献">参考文献</h2><blockquote><p>1.single view metrology[http://ieeexplore-ieee-org-s.ivpn.hit.edu.cn:1080/document/791253] 2.http://www.cvlibs.net/datasets/kitti/setup.php 3.https://cloud.tencent.com/developer/article/1418687</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perception </tag>
            
            <tag> detector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bazel C++编译入门</title>
      <link href="/2020/02/16/bazel-learn/"/>
      <url>/2020/02/16/bazel-learn/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="安装">安装</h2><p>参考：https://docs.bazel.build/versions/master/install.html</p><p>apt 安装失败，通过binary安装,安装文件下载：https://github.com/bazelbuild/bazel/releases</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install g++ unzip zip</span><br><span class="line"><span class="comment"># Ubuntu 16.04 (LTS) uses OpenJDK 8 by default:</span></span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu 18.04 (LTS) uses OpenJDK 11 by default:</span></span><br><span class="line">sudo apt-get install openjdk-11-jdk</span><br><span class="line">sudo bash bazel-&lt;version&gt;-installer-linux-x86_64.sh --user</span><br><span class="line"></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin"</span></span><br></pre></td></tr></table></figure><h2 id="编译">编译</h2><p>参考教程:https://docs.bazel.build/versions/master/tutorial/cpp.html</p><h3 id="工作区workspace">工作区(workspace)</h3><p>bazel基于工作区(workspace)的概念编译，工作区存放了所有的源代码和Bazel编译输出文件的目录，也就是整个项目的根目录，与bazel编译相关的文件:</p><ul><li>WORKSPACE文件，用于指定当前文件夹就是一个Bazel的工作区，所以WORKSPACE文件总是存在于项目的根目录下。</li><li>一个或多个BUILD文件，用于告诉Bazel怎么构建项目的不同部分。(如果工作区中的一个目录包含含BUILD文件，即为一个package)</li></ul><p>如果要指定一个目录为Bazel工作区，只要在该目录下创建一个空的WORKSPACE文件即可。当Bazel编译项目是，所有的输入和依赖想都必须在同一个工作区中，不同的工作区的文件，除非linked否则彼此独立。</p><p>WORKSPACE文件中可以设置第三方代码库，即外部引用</p><h3 id="build文件组成">BUILD文件组成</h3><p>BUILD文件中最重要的指令是编译指令，告诉Bazel如何编译输出，比如是生成可执行二进制文件还是链接库。BUILD文件中每一天编译指令被称为一个target，它指向一系列的源文件和依赖，一个target也可以指向别的target。</p><p>bazelbuild的简单例子可以参考：https://github.com/bazelbuild/examples</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"@rules_cc//cc:defs.bzl"</span>, <span class="string">"cc_binary"</span>)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">name = <span class="string">"hello-world"</span>,</span><br><span class="line">srcs = [<span class="string">"hello-world.cc"</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>name</code>即为该target名称，<code>src</code>包含了源文件，<code>cc_binary</code>为内置的生成二进制文件的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build //main:hello-world</span><br></pre></td></tr></table></figure><p>在WORSPACE目录下上述命令行指令即可实现编译，<code>main:hello-world</code>表示位于main目录下的target <code>helo-world</code>,同时获得如下输出，生成的二进制文件位于<code>bazel-bin/main/hello-world</code> <strong>路径相对于WORKSPACE</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO: Found 1 target...</span><br><span class="line">Target //main:hello-world up-to-date:</span><br><span class="line">  bazel-bin/main/hello-world</span><br></pre></td></tr></table></figure><h3 id="多个target同时编译">多个target同时编译</h3><p>对于大型项目来说，一般会把它拆分成多个<code>target</code>和多个<code>package</code>来实现快速增量的编译。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"@rules_cc//cc:defs.bzl"</span>, <span class="string">"cc_binary"</span>, <span class="string">"cc_library"</span>)                   </span><br><span class="line"></span><br><span class="line">cc_library(</span><br><span class="line">   name = <span class="string">"hello-greet"</span>,</span><br><span class="line">   srcs = [<span class="string">"hello-greet.cc"</span>],</span><br><span class="line">   hdrs = [<span class="string">"hello-greet.h"</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">    name = <span class="string">"hello-world"</span>,</span><br><span class="line">    srcs = [<span class="string">"hello-world.cc"</span>],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">":hello-greet"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在这个BUILD文件中，首先编译了<code>hello-greet</code>这个库(利用bazel内置的cc_library编译指令)，然后在编译<code>hello-world</code>这个二进制文件。<code>hellow-world</code>这个target的<code>deps</code>属性告诉Bazel，要构建<code>hello-world</code>这个二进制文件，首先需要<code>hello-greet</code>这个库。</p><h3 id="多个package同时编译">多个package同时编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">└── stage3</span><br><span class="line">    ├── lib</span><br><span class="line">    │   ├── BUILD</span><br><span class="line">    │   ├── hello-time.cc</span><br><span class="line">    │   └── hello-time.h</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── BUILD</span><br><span class="line">    │   ├── hello-greet.cc</span><br><span class="line">    │   ├── hello-greet.h</span><br><span class="line">    │   └── hello-world.cc</span><br><span class="line">    ├── README.md</span><br><span class="line">    └── WORKSPACE</span><br></pre></td></tr></table></figure><p>两个BUILD对应的为两个package,因此对于Bazel来说，整个工作区包含了两个package: lib和main。两个目录下的<code>BUILD</code>文件分别定义如下： main下的BUILD文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"@rules_cc//cc:defs.bzl"</span>, <span class="string">"cc_binary"</span>, <span class="string">"cc_library"</span>)                   </span><br><span class="line"></span><br><span class="line">cc_library(</span><br><span class="line">    name = <span class="string">"hello-greet"</span>,</span><br><span class="line">    srcs = [<span class="string">"hello-greet.cc"</span>],</span><br><span class="line">    hdrs = [<span class="string">"hello-greet.h"</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">    name = <span class="string">"hello-world"</span>,</span><br><span class="line">    srcs = [<span class="string">"hello-world.cc"</span>],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">":hello-greet"</span>,</span><br><span class="line">        <span class="string">"//lib:hello-time"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>lib/BUILD</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">load(<span class="string">"@rules_cc//cc:defs.bzl"</span>, <span class="string">"cc_library"</span>)                                </span><br><span class="line"></span><br><span class="line">cc_library(</span><br><span class="line">    name = <span class="string">"hello-time"</span>,</span><br><span class="line">    srcs = [<span class="string">"hello-time.cc"</span>],</span><br><span class="line">    hdrs = [<span class="string">"hello-time.h"</span>],</span><br><span class="line">    visibility = [<span class="string">"//main:__pkg__"</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>显然main下的<code>hello-world</code>这个target依赖于<code>lib</code>这个package中的<code>hello-time</code>target 即(<code>deps = [&quot;//lib:hello-time&quot;]</code>),Bazel通过<code>deps</code>这个属性知道自己的依赖项。同时注意到<code>lib/BUILD</code>文件中的将<code>hello-time</code>这个target显示可见(通过<code>visibility</code>属性)，这是因为默认情况下targets只对同一个BUILD文件里的其他targets可见。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build //main:hello-world</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>doxygen</title>
      <link href="/2020/02/16/doxygen/"/>
      <url>/2020/02/16/doxygen/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>参考：https://www.ibm.com/developerworks/cn/aix/library/au-learningdoxygen/index.html</p></blockquote><h2 id="安装doxygen">安装doxygen</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install flex bison</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/doxygen/doxygen.git</span><br><span class="line"><span class="built_in">cd</span> doxygen</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. &amp; make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="使用doxygen生成文档">使用Doxygen生成文档</h2><p>--目前应用好像有困难　　暂时先不写了</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Component 组件注册过程</title>
      <link href="/2020/02/16/cyber-component/"/>
      <url>/2020/02/16/cyber-component/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CYBER_REGISTER_COMPONENT(FusionCameraDetectionComponent);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYBER_REGISTER_COMPONENT(name) \</span></span><br><span class="line">  CLASS_LOADER_REGISTER_CLASS(name, apollo::cyber::ComponentBase)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register class macro</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_LOADER_REGISTER_CLASS(Derived, Base) \</span></span><br><span class="line">  CLASS_LOADER_REGISTER_CLASS_INTERNAL_1(Derived, Base, __COUNTER__)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_LOADER_REGISTER_CLASS_INTERNAL_1(Derived, Base, UniqueID) \</span></span><br><span class="line">  CLASS_LOADER_REGISTER_CLASS_INTERNAL(Derived, Base, UniqueID)</span><br></pre></td></tr></table></figure><p>最终实际执行： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_LOADER_REGISTER_CLASS_INTERNAL(Derived, Base, UniqueID)     \</span></span><br><span class="line">  <span class="keyword">namespace</span> &#123;                                                             \</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ProxyType</span>##<span class="title">UniqueID</span> &#123;</span>                                            \</span><br><span class="line">    ProxyType##UniqueID() &#123;                                               \</span><br><span class="line">      apollo::cyber::class_loader::utility::RegisterClass&lt;Derived, Base&gt;( \</span><br><span class="line">          #Derived, #Base);                                               \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125;;                                                                      \</span><br><span class="line">  <span class="keyword">static</span> ProxyType##UniqueID g_register_class_##UniqueID;                 \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> Base&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterClass</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; base_class_name)</span> </span>&#123;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"registerclass:"</span> &lt;&lt; class_name &lt;&lt; <span class="string">","</span> &lt;&lt; base_class_name &lt;&lt; <span class="string">","</span></span><br><span class="line">        &lt;&lt; GetCurLoadingLibraryName();</span><br><span class="line"></span><br><span class="line">  utility::AbstractClassFactory&lt;Base&gt;* new_class_factrory_obj =</span><br><span class="line">      <span class="keyword">new</span> utility::ClassFactory&lt;Derived, Base&gt;(class_name, base_class_name);</span><br><span class="line">  new_class_factrory_obj-&gt;AddOwnedClassLoader(GetCurActiveClassLoader());</span><br><span class="line">  new_class_factrory_obj-&gt;SetRelativeLibraryPath(GetCurLoadingLibraryName());</span><br><span class="line"></span><br><span class="line">  GetClassFactoryMapMapMutex().lock();</span><br><span class="line">  ClassClassFactoryMap&amp; factory_map =</span><br><span class="line">      GetClassFactoryMapByBaseClass(<span class="keyword">typeid</span>(Base).name());</span><br><span class="line">  factory_map[class_name] = new_class_factrory_obj;</span><br><span class="line">  GetClassFactoryMapMapMutex().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列容器</title>
      <link href="/2020/02/13/sequence-containers/"/>
      <url>/2020/02/13/sequence-containers/</url>
      
        <content type="html"><![CDATA[<p>c++ 模板库中序列容器的使用</p><a id="more"></a><p>序列(顺序)容器以线性序列的方式存储元素。它没有对元素进行排序，元素的顺序和存储它们的顺序相同,主要有以下五种标准的序列容器：</p><blockquote><ul><li>array&lt;T,N&gt;(数组容器):长度固定的序列，存放N个T类型的对象，不能增加或删除元素。</li><li>vector<T>(向量容器):长度可变的序列，存放T类型的对象，只能在序列的末尾增删元素。</T></li><li>deque<T>(双向队列容器):长度可变的序列，两端均可增删元素。</T></li><li>list<T>(链表容器):长度可变的序列，存放T类型对象，在序列任何地方都可以增加或删除元素。(双向链表)</T></li><li>forward_list<T>(正向链表容器)，长度可变，由T类型对象组成的序列。(单向链表)</T></li></ul></blockquote><p>下面具体介绍容器中常见的函数成员用法(限于篇幅，主要介绍典型的vector容器和list容器)</p><p>为了方便介绍STL的相关内容，首先介绍STL库的相关前置知识和思想，主要包括：</p><blockquote><ul><li>模板</li><li>容器</li><li>迭代器</li><li>智能指针</li><li>算法</li></ul></blockquote><h3 id="一前置知识">一、前置知识</h3><ul><li><p><strong>模板</strong></p><p>模板是一组函数或类的参数实现，模板并不是可执行代码，而是用于生成代码的配方，没有使用的模板会被编译器忽略。</p><p><strong>模板函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp; <span class="title">larger</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;<span class="comment">//&amp;表示引用</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">first</span><span class="params">(<span class="string">"To be or not to be "</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">second</span><span class="params">(<span class="string">"This is a question"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; larger(first, second) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b =<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; larger(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; To be <span class="keyword">or</span> <span class="keyword">not</span> to be </span><br><span class="line">&gt;&gt;&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>模板函数可以隐式推断传入类型，当然也可以显式指定类型</p><p><strong>模板类</strong></p><p>引入以下实现一个数组类的实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; //memory 要置于shared_ptr之前　真神奇</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/shared_ptr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A *elements;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Array</span><span class="params">(<span class="keyword">size_t</span> arraySize)</span></span>;   <span class="comment">//显式构造函数</span></span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;other);          <span class="comment">//拷贝构造函数 </span></span><br><span class="line">    Array(Array &amp;&amp;other);               <span class="comment">//转移构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Array() &#123;&#125;;                   <span class="comment">//析构函数</span></span><br><span class="line">    A &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> index);        <span class="comment">//Subscript operator</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> index) <span class="keyword">const</span>;  <span class="comment">// Subscript operator</span></span><br><span class="line">    Array &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;rhs);   <span class="comment">// Assignment operator</span></span><br><span class="line">    Array &amp;<span class="keyword">operator</span>=(Array &amp;&amp;rhs);   <span class="comment">//Move assignment operator　&amp;&amp;:右值引用</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;     <span class="comment">//Accessor for count</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拷贝构造函数利用现有对象初始化创建新对象(Array<int> A2 =A1)，为防止shallow copy ,需要重载此函数。</int></p><p>如果想要将A3的属性赋值给A4(A4 = A3),则需要重载operator。</p><p>类成员模板函数定义(std::nothrow 用于申请内存不足时返回nullptr)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line">Array&lt;A&gt;::Array(<span class="keyword">size_t</span> arraySize) : elements(<span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) A[arraySize]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elements == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Memory allocation faliure in Array constructor."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//没有足够的内存会返回nullptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">inline</span> Array&lt;A&gt;::Array(<span class="keyword">const</span> Array &amp;other):elements(<span class="keyword">new</span>(<span class="built_in">std</span>::nothrow) A[other.count]), count(other.count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elements == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Memory allocation faliure in Array constructor."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i&#123;<span class="number">0</span>&#125;; i &lt; count; i++)&#123;</span><br><span class="line">            elements[i] = other.elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>容器</strong></p><p>容器是STL各种功能的基础，是以特定形式存储和组织其他对象的对象，容器中数据的访问采用iterators,STL提供以下几种类型的容器：</p><ul><li><strong>序列容器(sequence containers)：</strong>以线性组织的方式存储对象，和数组类似，但是不需要连续的存储空间。</li><li><strong>关联容器(Associative Containers)：</strong>存储和键关联的对象。可以通过相关联的建从关联容器中获取对应的值，也可通过迭代器从关联容器中得到对象。</li><li><strong>容器适配器(Container Adapters):</strong> 是提供了替换机制的适配类模板，可以用来访问基础的序列容器和关联容器。</li></ul><p>STL容器存储的是对象的副本。STL要求移动构造函数和复制运算符必须被指定为noexcept，即不会抛出异常。容器在堆上存放对象，并自动管理它们所占用的内存，一个T类型的对象如果要存放在容器中，需要满足一些特定要求，这些要求取决与你对元素执行的操作，通常有复制、移动、交换等操作,下面给出一个满足在容器中存放的T类型对象的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T();<span class="comment">//default constructor</span></span><br><span class="line">    T(<span class="keyword">const</span> T &amp;t);<span class="comment">//copy constructor</span></span><br><span class="line">    ~T();<span class="comment">//Destructor</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> T &amp;t);<span class="comment">//重载＝运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在关联容器中使用对象的话，对象需要定义operator&lt;(),提供小于运算符，来使用sort()和merge()这类算法。</p></li><li><p><strong>迭代器</strong></p><p>​ 当使用容器时，不可避免地会使用到iterators去访问数据，迭代器是一个行为类似于指针的模板类对象，只要迭代器iter指向一个有效对象，就可以通过使用*iter解引用的方式来获取一个对象的引用。如果iter指向一个可以访问成员的类对象，类成员就可以通过iter-&gt;member来使用。</p><p>​ 迭代器将算法和不同类型容器的元素联系了起来，获取迭代器的方式有：</p><ul><li>调用容器对象<code>begin()</code>和<code>end()</code>，返回的这两个迭代器分别指向第一个和最后一个元素下一个位置。<code>end()</code>返回的迭代器并没有指向一个有效的元素，所以既不能解引用，也不能递增它。亦可以通过调用<code>std::beign(container)</code>和<code>std::end(contrainer)</code> 获取的迭代器是等价的。</li></ul><p>　不同的算法要求具有不同功能的迭代器，下面由简至繁依次列出不同类别的迭代器：</p><blockquote><ul><li><strong>输入迭代器(input iterators)</strong>提供对对象的只读访问，必须支持表达式<code>*iter</code>以引用它所指向的值，且输入迭代器无减量运算(iter--是错误的)。常用操作(iter++ 、iter1 == iter2、iter1 != iter2)</li><li><strong>输出迭代器(output iterators)</strong> 提供对对象的只写访问，必须支持表达式<code>*iter=new_value</code>,同样其无减量操作</li><li><strong>正向迭代器(forward iterators)</strong>结合了输入和输出迭代器的功能，可以使用多次。</li><li><strong>双向迭代器(bidirectional iterators)</strong>具有和正向迭代器同样的功能，但允许进行前向和后向遍历，一次可以使用减量操作和增量操作</li><li><strong>随机访问迭代器(random access iterators)</strong>提供了和双向迭代器同样的功能，但是能支持对元素的随机访问。同时支持<code>iter+n</code>,<code>iter-n</code>或者直接通过索引访问<code>iter[n]</code>,等同于<code>*(iter+n)</code>,还可通过<code>iter1-iter2</code>获得两个迭代器之间元素的个数。</li></ul></blockquote><ul><li><p>迭代器适配器</p><p>适配器类模板定义了三种不同的迭代器:反向迭代器(reverse iterators)、插入迭代器(insert iterators)和移动迭代器(move iterators)。</p><p>插入迭代器:</p><blockquote><p>后向插入迭代器(back_insert_itreator)通过调用成员函数<code>push_back()</code>将一个新元素添加到容器的尾部。<code>vecotr</code>、<code>list</code>、<code>deque</code>容器具有一个<code>push_back()</code>函数。</p><p>前向插入迭代器(front_insert_iterator)通过调用成员函数<code>push_front()</code>将一个新元素添加到容器的头部。<code>list</code> 、<code>forward_list</code> 、<code>deque</code>容器均有一个<code>push_front()</code>函数</p></blockquote></li></ul></li><li><p>智能指针</p><p>智能指针是一个可以模仿原生指针(指向静态变量或堆上生成的变量)的模板类，主要区别在于：</p><ul><li>智能指针只能用来保存<code>堆</code>上分配的内存的地址。</li><li>不能像对原生指针一样对智能指针进行一些自增或是自减这样的算数运算。</li></ul><p>对于在自由存储区创建的对象，通常使用智能指针而不是原生指针。智能指针的优势是不用担心内存的释放，可以在容器中使用智能指针，如果使用一个类的基类作为智能指针的类型参数，可以用它指向一个派生类对象，这保存了一个对象的指针而不是对象，因而能够保持这个对象的多态性,std明明空间中定义了三种不同类型的智能指针模板：</p><ul><li><p><code>unique_ptr&lt;T&gt;</code>对象就像一个指向类型T的指针，具有排它的特性，不存在多个<code>unique_ptr&lt;T&gt;</code> 指向同一个地址，即一个<code>unique_ptr&lt;T&gt;</code>完全拥有它所指向的内容。可以使用std::move()移出其存储的地址，移出后该<code>unique_ptr&lt;T&gt;</code>变为无效。</p></li><li><p><code>shared_ptr&lt;T&gt;</code>对象和<code>unique_ptr&lt;T&gt;</code>不同的是多个<code>shared_ptr&lt;T&gt;</code>可以指向同一个地址，共享对象的所有权，引用计数保存了指向给定地址的<code>shared_ptr&lt;T&gt;</code>的数量，当引用计数为0时，分配的内存自动释放。</p></li><li><p><code>weak_ptr&lt;T&gt;</code>可以从一个<code>shared_ptr&lt;T&gt;</code>创建，它们指向同一个地址，创建<code>weak_ptr&lt;T&gt;</code>不会增加<code>shared_ptr&lt;T&gt;</code>对象的引用次数，所以其会组织所指向对象的销毁。使用<code>weak_ptr&lt;T&gt;</code>主要原因是为了避免<strong>循环引用</strong>。</p><p><strong>unique_ptr<T></T></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">pname</span><span class="params">(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span> (<span class="string">"Algernon"</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>或者使用<code>memory</code>头文件中函数<code>make_unique&lt;T&gt;()</code>函数来生成<code>unique_ptr&lt;T&gt;</code>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pname = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"Algernon"</span>)</span><br></pre></td></tr></table></figure><p>​ 注意不能以传值的方式将一个<code>unique_ptr&lt;T&gt;</code>对象传入函数中，因为它们不支持拷贝，<strong>必须使用引用的方式</strong>,同时只能通过移动或生成它们的方式，在容器中存放<code>unique_ptr&lt;T&gt;</code>对象。<code>unique_ptr&lt;T&gt;</code>对象析构会释放它所指向对象的内存。在解引用一个指针时，需要先判断其是否为空,<code>if(!pname)</code> 可以将<code>pname</code>隐式转换为布尔型。</p><p>​ 类的<code>get()</code>成员函数可以返回一个<code>unique_ptr&lt;T&gt;</code>所包含的原生指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> pstr &#123;unique_p.<span class="built_in">get</span>()&#125;</span><br></pre></td></tr></table></figure><p><strong>shared_ptr<T></T></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">pdata</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">999.0</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>或者使用<code>memory</code>头文件中函数<code>make_shared&lt;T&gt;()</code>来生成<code>shared_ptr&lt;T&gt;</code>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">double</span>&gt;(<span class="number">999.0</span>);</span><br></pre></td></tr></table></figure><p>使用<code>shared_prt&lt;T&gt;</code>的成员函数<code>get()</code> 可以获得一个原生指针:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pvalue = pdata.<span class="built_in">get</span>() <span class="comment">//return double*</span></span><br></pre></td></tr></table></figure><p>使用<code>reset()</code>函数重置指针,<code>unique()</code>可以查看对象的实例数，<code>use_count()</code>返回当前被调用对象的实例个数</p><p><strong>weak_ptr<T></T></strong></p><p><code>weak_ptr&lt;T&gt;</code>只能由<code>shared_ptr&lt;T&gt;</code>对象或已有的<code>weak_ptr&lt;T&gt;</code>创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata = <span class="built_in">std</span>::make_shared&lt;X&gt;();</span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;X&gt; <span class="title">pwdata</span> <span class="params">(pdata)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;X&gt; <span class="title">pwdata2</span> <span class="params">(pwdata)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>算法</strong></p><p>算法提供了计算和分析的函数，算法通过迭代器访问数据元素。</p><p>将函数作为实参传入另一个函数主要由以下三种方式：</p><ol type="1"><li>使用函数指针。</li><li>传入一个<code>函数对象</code>作为实参</li><li>使用<code>lambda</code>表达式作为形参</li></ol><ul><li><p>函数对象</p><p>函数对象也称仿函数，是重载了函数调用运算符<code>operator()()</code>的类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volume</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x ,<span class="keyword">double</span> y ,<span class="keyword">double</span> z)</span></span>&#123;<span class="keyword">return</span> x*y*z;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Volume volume;<span class="comment">//create a functor</span></span><br><span class="line"><span class="keyword">double</span> room &#123;volume(<span class="number">16</span>,<span class="number">12</span>,<span class="number">8.5</span>)&#125;;</span><br></pre></td></tr></table></figure></li><li><p>lambda表达式</p><p>一个lambda表达式定义了一个匿名函数，lambda可以捕获它们作用域内的变量,然后利用它们.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="keyword">double</span> value) &#123;<span class="keyword">return</span> value*value*value;&#125;</span><br></pre></td></tr></table></figure><p><code>[ ]</code>称为<code>lambda</code>引入符，表示了<code>lambda</code>表达式的开始，内部为捕获列表，引入符后面圆括号<code>()</code>表示了参数列表，与一般函数类似，<code>{}</code>中即为函数主体,值得注意的是示例中并没有具体指定返回类型，返回类型默认由返回值的类型，无返回值则为<code>void</code>，若要指定返回值<code>[](double value)-&gt;double {return value*value*value;}</code></p><p>可以使用变量来保存<code>lambda</code>的地址,然后变量可以当做函数指针使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cube = [](<span class="keyword">double</span> value)&#123;<span class="keyword">return</span> value*value*value;&#125;</span><br><span class="line"><span class="keyword">double</span> x &#123;<span class="number">2.5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">"cubed is: "</span> &lt;&lt; cube(x) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>将lambda表达式传给函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIter,<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(ForwardIter first,ForwoardIter last,F fun)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = first;iter!= last;++iter)</span><br><span class="line">*iter = fun(*iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形参fun接受任意合适的lambda表达式，也接受函数对象或普通的函数指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">change(<span class="built_in">std</span>::<span class="built_in">begin</span>(data),<span class="built_in">std</span>::<span class="built_in">end</span>(data),[] (<span class="keyword">int</span> value)&#123;<span class="keyword">return</span> value*value;&#125;);</span><br></pre></td></tr></table></figure><p>标准库的<code>functional</code>头文件定义了一个模板类型<code>std::function&lt;&gt;</code> ,对任意类型函数指针的封装，又给定的返回类型和形参类型。前面表示lambda表达式的变量可以按如下方式定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span> (<span class="keyword">double</span>)&gt; op = [] (<span class="keyword">double</span> value)&#123;<span class="keyword">return</span> value*value*value;&#125;;</span><br></pre></td></tr></table></figure><p>op现在可以作为实参，传给任意接受函数实参且签名相同的函数。</p><p><strong>捕获列表</strong></p><p><img src="/2020/02/13/sequence-containers/lambda.png"></p><p>默认捕获子句捕获和lambda表达式定义同样范围的所有变量。若<code>[]</code>中有<code>=</code>则为按值传递;若为<code>&amp;</code>则为按引用传递。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 模板类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中的神经网络框架</title>
      <link href="/2020/02/13/apollo-nn/"/>
      <url>/2020/02/13/apollo-nn/</url>
      
        <content type="html"><![CDATA[<h3 id="模型类型">模型类型</h3><p>model_type</p><p><code>modules/perception/inference/inference_factory.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Inference *<span class="title">CreateInferenceByName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;proto_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;weight_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;outputs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;inputs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;model_root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="string">"CaffeNet"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CaffeNet(proto_file, weight_file, outputs, inputs);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"RTNet"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RTNet(proto_file, weight_file, outputs, inputs);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"RTNetInt8"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RTNet(proto_file, weight_file, outputs, inputs, model_root);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"PaddleNet"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PaddleNet(proto_file, weight_file, outputs, inputs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RTNet 表示使用TensorRT加速</p>]]></content>
      
      
      <categories>
          
          <category> Apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apollo </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中can卡配置</title>
      <link href="/2020/02/08/can-conf/"/>
      <url>/2020/02/08/can-conf/</url>
      
        <content type="html"><![CDATA[<p>apollo开源框架中can卡的配置 <a id="more"></a></p><p>[TOC]</p><h3 id="前置内容">1. 前置内容</h3><p>本文主要参考：https://zhuanlan.zhihu.com/p/61838008</p><p>Apollo 在车辆的信息交互和车辆配置上均使用了<code>Protobuf</code></p><blockquote><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener" title="protobuf 相关介绍">[1]</a></p></blockquote><p>通常车企采用DBC文件完成CAN信号的定义和解析,由于Apollo中采用了Protobuf进行模块间的通信和配置，因此车企需要使用Apollo提供的工具基于DBC生成Apollo可用的proto文件。</p><blockquote><p>DBC文件是用来描述CAN网络通信信号的一种格式文件。</p></blockquote><p>一般各车厂DBC文件的定义不同并严格保密，为了解决无人驾驶系统中与车辆交互的问题，Apollo搭建了《开放汽车认证平台》，由此，方便无人驾驶的车辆部署，<code>ApolloAuto/apollo/tree/master/modules/canbus/vehicle</code> 中有目前支持的参考车辆目录。新增车辆需要新建一个目录以及对应的文件，通过工具可基于DBC文件快速生成Apollo参考车辆适配层模板， <span id="jump">工具</span>位于<code>ApolloAuto/apollo/tree/master/modules/tools/gen_vehicle_protocol</code> 下，使用方法参考<code>readme</code>。<a href="http://apollo.auto/docs/procedure_cn.html" target="_blank" rel="noopener" title="针对车辆CAN DBC文件如何生成proto文件">[3]</a></p><blockquote><p>该平台作为软硬件中间层，提出了开放车辆接口标准，定义了系统与车辆的线控接口，负责完成系统与汽车的具体交互，同时该平台抽象出了与车型无关的信号作为上层算法模块的输入，使得上层平台可以与底层车辆解耦。</p><p>具体线控需求规范可参考：https://link.zhihu.com/?target=http%3A//apollo-homepage.bj.bcebos.com/Apollo_by_wire_requirement.xlsx</p></blockquote><h3 id="apollo-cancard参数配置文件">2. Apollo Cancard参数配置文件</h3><h4 id="apollo-中采用proto文件管理相关配置">2.1 apollo 中采用proto文件管理相关配置</h4><p>apollo 激活车辆的配置文件的相关路径为<code>modules/canbus/conf/canbusconf.pb.txt</code>, 可在该文件中定义<strong>车型</strong>及对应的CAN card参数.</p><ul><li>apollo 中相关算法默认车辆是Lincoln MKZ ,如何置换或添加新的车辆到Apollo中可参考文档：<code>apollo/docs/howto/hwo_to_add_a_new_vehicle.md</code> <span id="newvehicle">  </span></li></ul><blockquote><ul><li>Implement the new vehicle controller :<code>class NewVehicleController final : public VehicleController{...}</code></li><li>Implement the new message manager：<code>class NewVehicleMessageManager : public MessageManager {...}</code></li><li>Implement the new vehicle factory:<code>class NewVehicleFactory : public AbstractVehicleFactory {...}</code></li><li>Register the New Vehicle:<code>void VehicleFactory::RegisterVehicleFactory(){...}</code></li><li>Update the configuration file: <code>vehicle_parameter{...}</code> 这就是下面要描述的。</li></ul></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vehicle_parameter &#123;</span><br><span class="line">  brand: LINCOLN_MKZ <span class="comment">//车型 该参数决定了车辆的相关标定参数</span></span><br><span class="line">  max_enable_fail_attempt: <span class="number">5</span> </span><br><span class="line">  driving_mode: COMPLETE_AUTO_DRIVE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">can_card_parameter &#123;</span><br><span class="line">  brand: ESD_CAN <span class="comment">//CAN卡通信方式，还有比如socket类型</span></span><br><span class="line">  type: PCI_CARD <span class="comment">//Can卡类型，还有比如USB_CARD</span></span><br><span class="line">  channel_id: CHANNEL_ID_ZERO </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enable_debug_mode: <span class="literal">false</span></span><br><span class="line">enable_receiver_log: <span class="literal">false</span></span><br><span class="line">enable_sender_log: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上述参数配置文件的参数含义由下面的<code>proto</code> 文件决定：</p><ul><li><code>modules/canbus/proto/canbus_conf.proto</code></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.canbus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/drivers/canbus/proto/can_card_parameter.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/canbus/proto/vehicle_parameter.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CanbusConf</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> VehicleParameter vehicle_parameter = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> apollo.drivers.canbus.CANCardParameter can_card_parameter = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> enable_debug_mode = <span class="number">3</span> [default = <span class="literal">false</span>];</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> enable_receiver_log = <span class="number">4</span> [default = <span class="literal">false</span>];</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> enable_sender_log = <span class="number">5</span> [default = <span class="literal">false</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p><code>modules/canbus/proto/vehicle_parameter.proto</code></p><p>该文件中定义了车辆的相关参数</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.canbus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/canbus/proto/chassis.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"modules/common/configs/proto/vehicle_config.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">VehicleParameter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> apollo.common.VehicleBrand brand = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> max_engine_pedal = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> max_enable_fail_attempt = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">optional</span> Chassis.DrivingMode driving_mode = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细各文件内容此处略去不表，<code>VehicleBrand</code> 表示apollo支持的车辆品牌,目前有<code>LINCOLN_MKZ、GEM、LEXUS、TRANSIT、GE3、WEY、ZHONGYUN、CH</code></p><hr><ul><li><p><code>modules/drivers/canbus/proto/can_card_parameter.proto</code></p><p>该文件中定义了cancard的三个相关参数定义</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.drivers.canbus;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">CANCardParameter</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">CANCardBrand</span> </span>&#123;</span><br><span class="line">    FAKE_CAN = <span class="number">0</span>;</span><br><span class="line">    ESD_CAN = <span class="number">1</span>;</span><br><span class="line">    SOCKET_CAN_RAW = <span class="number">2</span>;</span><br><span class="line">    HERMES_CAN = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">CANCardType</span> </span>&#123;</span><br><span class="line">    PCI_CARD = <span class="number">0</span>;</span><br><span class="line">    USB_CARD = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">CANChannelId</span> </span>&#123;</span><br><span class="line">    CHANNEL_ID_ZERO = <span class="number">0</span>;</span><br><span class="line">    CHANNEL_ID_ONE = <span class="number">1</span>;</span><br><span class="line">    CHANNEL_ID_TWO = <span class="number">2</span>;</span><br><span class="line">    CHANNEL_ID_THREE = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> CANCardBrand brand = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> CANCardType type = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> CANChannelId channel_id = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="信号交互">2.2 信号交互</h4><p>通常车企采用DBC文件完成CAN信号的定义和解析，Apollo则大量使用了Protobuf来进行模块间的通信和配置，因此车企需要通过Apollo提供的<a href="#jump">工具</a>基于DBC来生成Apollo可用<code>Proto</code>文件：以<u>广汽传祺GE3 开发者版</u> 为例</p><p><code>modules/canbus/proto/ge3.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.canbus;</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Ge3</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> Pc_bcm_201 pc_bcm_201 = <span class="number">1</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcs_3_308 scu_bcs_3_308 = <span class="number">2</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_epb_203 pc_epb_203 = <span class="number">3</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_bcs_202 pc_bcs_202 = <span class="number">4</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_vcu_205 pc_vcu_205 = <span class="number">5</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Pc_eps_204 pc_eps_204 = <span class="number">6</span>; <span class="comment">// control message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_vcu_2_313 scu_vcu_2_313 = <span class="number">7</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_1_301 scu_1_301 = <span class="number">8</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_2_302 scu_2_302 = <span class="number">9</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_3_303 scu_3_303 = <span class="number">10</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcm_304 scu_bcm_304 = <span class="number">11</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcs_1_306 scu_bcs_1_306 = <span class="number">12</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_bcs_2_307 scu_bcs_2_307 = <span class="number">13</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_epb_310 scu_epb_310 = <span class="number">14</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_vcu_1_312 scu_vcu_1_312 = <span class="number">15</span>; <span class="comment">// report message</span></span><br><span class="line">  <span class="keyword">optional</span> Scu_eps_311 scu_eps_311 = <span class="number">16</span>; <span class="comment">// report message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="车辆配置">2.3 车辆配置</h4><p>Protobuf 提供了名为<code>TextFormat</code> 的序列化格式（该格式可读性强，类似于Json），配合事先定义的Proto文件，开发者可以轻易实现从可读的配置文件到具体对象的实力的反射，配置文件经过反序列化后可以作为业务代码类的输入，这种方式使得配置更加便捷，具有很好的向后兼容性。</p><p>Apollo 中大量采用了这种方式管理配置，Apollo激活车辆的配置文件为<code>modules/canbus/conf/canbus_conf.pb.txt</code> ,开发者可以再次定义车型以及对应的CAN card的参数，例如只需修改<code>vehicle_parameter</code> 相对应的字段，即可使Apollo支持相应的车型。</p><hr><h3 id="代码实现">3 代码实现</h3><h4 id="canbus模块">3.1 Canbus模块</h4><p>软件实现上，Apollo通过<code>CANBus</code> 模块来实现对车辆的管理和通讯。</p><p><code>CANBus</code> 模块接收并执行来自Contorl模块的指令，同时收集汽车底盘的状态（由Apollo抽象出的一组与车型无关的信号）。<code>CANBus</code> 模块处理这些状态与各个汽车底盘信号的映射关系，随后将这些状态反馈回<code>Control</code>模块，以此兼容不容车型。</p><figure><img src="/2020/02/08/can-conf/Apollo_3_5_software_architecture.png" alt="img"><figcaption>img</figcaption></figure><p><code>modules/canbus/proto/chassis.proto</code> 对Apollo抽象出的信号进行了定义，大体包括以下信息：</p><blockquote><p>DrivingMode: COMPLETE_MANUAL、COMPLETE_AUTO_DRIVE 、...</p><p>ErrorCode(错误码): 控制指令周期不准、底盘转向错误、人工接管</p><p>GearPosition(档位): 前进、后退、驻停等</p><p>底盘信息：车速、转速、油门、里程计</p><p>Gps</p><p>轮速</p></blockquote><p><code>CANBus</code> 模块主要由以下两个部件组成：</p><blockquote><p>Vehicle: the vehicle itself,including its controller and message manager</p><p>CAN Client: CAN client has been moved to <code>/modules/drivers/canbus</code> since it is shared by different sensors utilizing the canbus protocol <a href="https://github.com/ApolloAuto/apollo/tree/master/modules/canbus" target="_blank" rel="noopener" title="canbus">[4]</a></p></blockquote><p>针对<code>Vehicle</code>部分进行着重介绍： - <code>Vehicle</code>的Controller（<code>modules/cnabus/vehicle/vehicle_controller.h</code>）类图如下（简化）:</p><figure><img src="/2020/02/08/can-conf/vehiclecontroller.png" alt="vehicleController"><figcaption>vehicleController</figcaption></figure><p><code>Vehicle Controller</code> 类负责完成与汽车底盘的具体交互，以下为部分接口说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief start the vehicle controller. 注：干函数会在内部起一个名为”SecurityDogThread-Func“ 的线程</span></span><br><span class="line"><span class="comment"> * 该线程会周期性检查与底盘的通讯状况，关键信号是否相应，是否有错误等</span></span><br><span class="line"><span class="comment"> * @return true if successfully started.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Start</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief stop the vehicle controller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief calculate and return the chassis.</span></span><br><span class="line"><span class="comment"> * 注：该函数完成了汽车底盘信号和Apollo内部定义的底盘状态信号的映射</span></span><br><span class="line"><span class="comment"> * @returns a copy of chassis. Use copy here to avoid multi-thread issues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Chassis <span class="title">chassis</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief update the vehicle controller.</span></span><br><span class="line"><span class="comment"> * 该函数用于执行来自Control模块的具体指令，根据指令要求和汽车目前所处的模式(完全自动、完全手动等)来为执行器的信号(档位、油门、转向)进行赋值</span></span><br><span class="line"><span class="comment"> * @param command the control command</span></span><br><span class="line"><span class="comment"> * @return error_code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> common::ErrorCode <span class="title">Update</span><span class="params">(<span class="keyword">const</span> control::ControlCommand &amp;command)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>Vehicle的<code>MessageManger</code>类负责完成具体对信号的接收、发送、解析等。</p><p>其类图<code>modules/drivers/canbus/can_common/message_manager.h</code>如下</p><figure><img src="/2020/02/08/can-conf/messagemanager.png" alt="MessageManager Class"><figcaption>MessageManager Class</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于指定系统接收的信号</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SensorType&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">bool</span> <span class="title">need_check</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MessageManager</span>&lt;SensorType&gt;:</span>:AddRecvProtocolData() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于指定系统向汽车底盘发送的控制信号</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SensorType&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">bool</span> <span class="title">need_check</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MessageManager</span>&lt;SensorType&gt;:</span>:AddSendProtocolData() &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p>以<code>ge3</code> 车型为例，<code>ge3</code> 文件夹下包含如下文件：</p><figure><img src="/2020/02/08/can-conf/ge3file.png" alt="ge3-file"><figcaption>ge3-file</figcaption></figure><p>根据Apollo的官方文件<code>how_to_add_a_new_vehicle</code> 想为Apollo添加<code>ge3</code> 车型需要完成以下<a href="#newvehicle">内容</a>：</p><blockquote><ul><li><p>实现新的车辆控制器--<code>ge3_controller.cc</code>,继承<code>VehicleController</code> 类</p></li><li><p>实现新的消息管理器-- ge3_message_manager.cc ,继承<code>MessageManager</code> 类</p></li><li><p>实现新的车辆工厂类 -- ge3_vehicle_factory.cc ,继承<code>AbstractVehicleFactory</code> 类</p></li><li><p>更新配置文件</p><ul><li><p>在<code>modules/canbus/vehicle/vehicle_factory.cc</code> 中进行注册</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Register(apollo::common::GE3, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Ge3VehicleFactory();</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>更新配置文件<code>modules/canbus/conf/canbus_conf.pb.txt</code></p></li></ul></li></ul></blockquote></li></ul></li></ul><h4 id="canbus工厂模式">3.2 CANBus工厂模式</h4><p>通过上述方法能够增加新车型的原因在于Apollo的配置基于<code>工厂模型</code> （参见另一篇文章）实现的。</p><blockquote><p>工厂方法模式（Factory method pattern）是一种实现了“工厂”概念的<code>面向对象设计模式</code> 。就像其他<code>创建型模式</code>一样，它也是处理在不指定<code>对象</code>具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个<code>类</code> ”。工厂方法让类的实例化推迟到子类中进行。<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#cite_note-1(https://zh.wikipedia.org/wiki/工厂方法#cite_note-1)" target="_blank" rel="noopener">[5]</a></p></blockquote><p>CANBus模块中Vehicle相关的内容使用工厂模式抽象出了<code>VehicleController</code>,<code>MessageManager</code>,<code>AbstractVehicleFactory</code> 三个接口。CANBus的<strong>业务</strong>代码(<code>canbus_component.cc</code>) 通过以上接口来操纵具体的对象，用户无需关心具体的对象是什么，从而实现了业务逻辑和目标对象的解耦。</p><p>在Canbus模块中，工厂类为&quot;VehicleFactory&quot;,继承于工厂模板&quot;Factory&quot;。&quot;VehicleFactory&quot;工厂维护了键值对为“VehicleParameter::VechileBrand”和&quot;AbstractVehicleFactory&quot;的Map。</p><p>如下所示，每新注册注册一种车型，该Map中就会插入一条汽车品牌(VehicleBrand)和该品牌汽车生产工厂(AbstractVehicleFactory)的键值对。(ProductCreator 采用Lambda 表达式)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VehicleFactory::RegisterVehicleFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Register(apollo::common::LINCOLN_MKZ, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LincolnVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::GEM, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GemVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::LEXUS, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LexusVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::TRANSIT, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TransitVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::GE3, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ge3VehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::WEY, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeyVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::ZHONGYUN, []() -&gt; AbstractVehicleFactory * &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZhongyunVehicleFactory();</span><br><span class="line">  &#125;);</span><br><span class="line">  Register(apollo::common::CH,</span><br><span class="line">           []() -&gt; AbstractVehicleFactory * &#123; <span class="keyword">return</span> <span class="keyword">new</span> ChVehicleFactory(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当VehicleFactory类的<code>CreateVehicle</code>方法被调用时，&quot;VehicleFactory&quot;会根据输入的汽车品牌，在Map中查找并返回可以生产这种汽车的工厂。</p><p>例如输入汽车品牌为<code>GE3</code> ，&quot;VehicleFactory&quot;会返回<code>Ge3VehicleFactory</code> ,<code>Ge3VehicleFactory</code>继承于<code>AbstractVehicleFactory</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Creates an AbstractVehicleFactory object based on vehicle_parameter</span></span><br><span class="line"><span class="comment"> * @param vehicle_parameter is defined in vehicle_parameter.proto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AbstractVehicleFactory&gt; <span class="title">CreateVehicle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> VehicleParameter &amp;vehicle_parameter)</span></span>;</span><br></pre></td></tr></table></figure><p><code>AbstractVehicleFactory</code> 工厂会产出一组适用于该品牌车型的产品即<code>MessageManager</code>和<code>Vehiclecontroller</code></p><p><code>modules/canbus/vehicle/ge3/ge3_vehicle_factory.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VehicleController&gt;</span><br><span class="line">Ge3VehicleFactory::CreateVehicleController() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VehicleController&gt;(<span class="keyword">new</span> ge3::Ge3Controller());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageManager&lt;::apollo::canbus::ChassisDetail&gt;&gt;</span><br><span class="line">Ge3VehicleFactory::CreateMessageManager() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageManager&lt;::apollo::canbus::ChassisDetail&gt;&gt;(</span><br><span class="line">      <span class="keyword">new</span> ge3::Ge3MessageManager());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ge3VehicleFactory</code> 最终会生产处一组适用于该品牌车型的产品，即<code>VehicleController</code> 和 <code>MessageManager</code></p><h3 id="canbus组件">4.Canbus组件</h3><p>​ 最后介绍CANBus模块的CanbusComponent，该类继承于<code>apollo::cyber::TimerComponent</code> ，主要作用是处理来自控制模块的控制指令，并将信号消息发送至CAN card。</p><p>​ CanbusComponent 的初始化函数（Init）主要完成以下工作：</p><ol type="1"><li><p>读取Canbus配置文件</p><p><code>modules/canbus/conf/canbusconf.pb.txt</code></p><p><code>modules/canbus/proto/canbus_conf.proto</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!GetProtoConfig(&amp;canbus_conf_)) &#123;</span><br><span class="line">  AERROR &lt;&lt; <span class="string">"Unable to load canbus conf file: "</span> &lt;&lt; ConfigFilePath();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据配置文件初始化<code>Can-client</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can_client_ = can_factory-&gt;CreateCANClient(canbus_conf_.can_card_parameter());</span><br></pre></td></tr></table></figure></li><li><p>根据配置文件获取汽车工厂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VehicleFactory vehicle_factory;</span><br><span class="line">  vehicle_factory.RegisterVehicleFactory();</span><br><span class="line">  <span class="keyword">auto</span> vehicle_object =</span><br><span class="line">      vehicle_factory.CreateVehicle(canbus_conf_.vehicle_parameter());</span><br></pre></td></tr></table></figure></li><li><p>获取该汽车工厂生产的<code>message_manager</code> 和 <code>Vehicle_controller</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message_manager_ = vehicle_object-&gt;CreateMessageManager();</span><br><span class="line"><span class="keyword">if</span> (can_receiver_.Init(can_client_.<span class="built_in">get</span>(), message_manager_.<span class="built_in">get</span>(),</span><br><span class="line">                         canbus_conf_.enable_receiver_log()) != ErrorCode::OK) &#123;...&#125;</span><br><span class="line"><span class="keyword">if</span> (can_sender_.Init(can_client_.<span class="built_in">get</span>(), canbus_conf_.enable_sender_log()) !=</span><br><span class="line">      ErrorCode::OK) &#123;...&#125;</span><br><span class="line">vehicle_controller_ = vehicle_object-&gt;CreateVehicleController();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>使能Can收发和<code>Vehicle_controller</code></p><p>初始化完成后，<code>CanbusComponent</code> 会周期性的报告车身状态，并执行来自<code>Control</code> 模块和<code>Guardian</code>模块的指令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanbusComponent::Proc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PublishChassis();</span><br><span class="line">  <span class="keyword">if</span> (FLAGS_enable_chassis_detail_pub) &#123;</span><br><span class="line">    PublishChassisDetail();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="comment">//周期性执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//事件触发，Reader回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanbusComponent::OnControlCommand</span><span class="params">(<span class="keyword">const</span> ControlCommand &amp;control_command)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanbusComponent::OnGuardianCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> GuardianCommand &amp;guardian_command)</span> </span>&#123;</span><br><span class="line">  apollo::control::ControlCommand control_command;</span><br><span class="line">  control_command.CopyFrom(guardian_command.control_command());</span><br><span class="line">  OnControlCommand(control_command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="参考链接">参考链接</h3><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener" title="protobuf 相关介绍">1</a> https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html protobuf 相关介绍</p><p><a href="https://zhuanlan.zhihu.com/p/61838008" target="_blank" rel="noopener" title="本文主要参考文章">2</a> https://zhuanlan.zhihu.com/p/61838008 本文主要参考文章</p><p><a href="http://apollo.auto/docs/procedure_cn.html" target="_blank" rel="noopener" title="针对车辆CAN DBC文件如何生成proto文件">3</a> http://apollo.auto/docs/procedure_cn.html 针对车辆CAN DBC文件如何生成proto文件</p><p><a href="https://github.com/ApolloAuto/apollo/tree/master/modules/canbus" target="_blank" rel="noopener" title="canbus">4</a> https://github.com/ApolloAuto/apollo/tree/master/modules/canbus &quot;canbus&quot;</p><p><a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#cite_note-1(https://zh.wikipedia.org/wiki/工厂方法#cite_note-1)" target="_blank" rel="noopener">5</a> https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#cite_note-1(https://zh.wikipedia.org/wiki/工厂方法#cite_note-1)</p><p>[6] https://zhuanlan.zhihu.com/p/61838008</p></blockquote><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人驾驶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo工厂模式解析</title>
      <link href="/2020/02/07/factory-mode/"/>
      <url>/2020/02/07/factory-mode/</url>
      
        <content type="html"><![CDATA[<p>apollo 中工厂模式相关知识介绍 <a id="more"></a></p><p>[TOC]</p><p>本文主要参考：<a href="https://blog.csdn.net/davidhopper/article/details/79197075" target="_blank" rel="noopener" class="uri">https://blog.csdn.net/davidhopper/article/details/79197075</a></p><p>工厂模式的定义和实现相关资料可参考：</p><blockquote><ul><li><a href="https://zh.wikipedia.org/wiki/工厂方法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95</a></li><li>《设计模式：可复用面向对象软件的基础》</li></ul></blockquote><h3 id="apollo-对象的创建方式">1. Apollo 对象的创建方式</h3><p>基本由 栈创建对象、堆创建对象、单例模式创建对象、工厂模式创建对象</p><p>Apollo项目中对象的创建，大多使用直接法，例如：</p><ul><li><p>//在栈(stack)上直接创建对象</p><p>ADCTrajectory not_ready_pb;</p></li><li><p>//在堆(heap)上直接创建对象</p><p>ZeroCopyOutputStream *output = new FileOutputStream(file_descriptor);</p></li></ul><blockquote><p>堆和栈的主要区别在于 <code>生命周期</code> 和 <code>性能</code> 由于栈的特性，栈上的对象不需要手动管理内存，而堆由程序员自行负责何时用delete释放内存，动态内存的生命周期由我们决定更加灵活。</p></blockquote><ul><li>还有部分通过<code>单例模式</code>创建：<code>DECLARE_SINGLETON(CanClientFactory)</code> ,其定义如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SINGLETON(classname)                                      \</span></span><br><span class="line"> <span class="keyword">public</span>:                                                                  \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> classname *<span class="title">Instance</span><span class="params">(<span class="keyword">bool</span> create_if_needed = <span class="literal">true</span>)</span> </span>&#123;              \</span><br><span class="line">    <span class="keyword">static</span> classname *instance = <span class="literal">nullptr</span>;                                 \</span><br><span class="line">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">std</span>::once_flag flag;                                         \</span><br><span class="line">      <span class="built_in">std</span>::call_once(flag,                                                \</span><br><span class="line">                     [&amp;] &#123; instance = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) classname(); &#125;); \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">    <span class="keyword">return</span> instance;                                                      \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CleanUp</span><span class="params">()</span> </span>&#123;                                                 \</span><br><span class="line">    <span class="keyword">auto</span> instance = Instance(<span class="literal">false</span>);                                      \</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">nullptr</span>) &#123;                                            \</span><br><span class="line">      CallShutdown(instance);                                             \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line"> <span class="keyword">private</span>:                                                                 \</span><br><span class="line">  classname();                                                            \</span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(classname)</span><br></pre></td></tr></table></figure><p>​ 其中内嵌宏 <code>DISALLOW_COPY_AND_ASSIGN(classname)</code>的定义如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line">  classname(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;    \</span><br><span class="line">  classname &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure> ​ 因此：<code>DECLARE_SINGLETON(CanClientFactory)</code> 展开后的定义为： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SINGLETON(CanClientFactory)                                      \</span></span><br><span class="line"> <span class="keyword">public</span>:                                                                  \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> CanClientFactory *<span class="title">Instance</span><span class="params">(<span class="keyword">bool</span> create_if_needed = <span class="literal">true</span>)</span> </span>&#123;              \</span><br><span class="line">    <span class="keyword">static</span> CanClientFactory *instance = <span class="literal">nullptr</span>;                                 \</span><br><span class="line">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">std</span>::once_flag flag;                                         \</span><br><span class="line">      <span class="built_in">std</span>::call_once(flag,                                                \</span><br><span class="line">                     [&amp;] &#123; instance = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) CanClientFactory(); &#125;); \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">    <span class="keyword">return</span> instance;                                                      \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CleanUp</span><span class="params">()</span> </span>&#123;                                                 \</span><br><span class="line">    <span class="keyword">auto</span> instance = Instance(<span class="literal">false</span>);                                      \</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">nullptr</span>) &#123;                                            \</span><br><span class="line">      CallShutdown(instance);                                             \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line"> <span class="keyword">private</span>:                                                                 \</span><br><span class="line">  CanClientFactory();                                                            \</span><br><span class="line">  CanClientFactory(<span class="keyword">const</span> CanClientFactory &amp;) = <span class="keyword">delete</span>;    \</span><br><span class="line">  CanClientFactory &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> CanClientFactory &amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></p><p>​ 上述代码的意义，首先定义一个静态公有函数Instance(),该函数在栈上创建一个<code>CanClientFactory</code> 类的静态对象，然后返回该对象指针。同时，将<code>CanClientFactory</code> 类的默认构造函数、复制（或称拷贝）构造函数、复制赋值运算符（或称操作符）定义为私有（private）函数，即禁止进行隐式类型转换和复制操作。<strong>单例模式保证一个类只有一个实例，并提供一个访问它的全局访问点，即通过静态指针来指向此唯一实例</strong></p><blockquote><p>c++中的static关键词可以用于修改局部变量，函数，类的数据成员以及对象。</p><p>​ 静态局部变量只初始化一次，然后每次函数调用时保持其值。</p><p>​ 静态成员函数可以直接用类来调用，不需要创建实例来调用。</p><p>静态对象：<code>static Test t1；</code></p><p>​ 静态对象只初始化一次，并且在整个程序的生命周期中都存在，静态对象保存在静态存储区，在程序结束时销毁。</p></blockquote><ul><li><p>还有部分对象通过工厂模式创建对象，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @class VehicleFactory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief This class is a factory class that will generate different</span></span><br><span class="line"><span class="comment"> * vehicle factories based on the vehicle brand.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> common::util::Factory&lt;apollo::common::VehicleBrand,</span><br><span class="line">                                   AbstractVehicleFactory&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief register supported vehicle factories.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RegisterVehicleFactory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Creates an AbstractVehicleFactory object based on vehicle_parameter</span></span><br><span class="line"><span class="comment">   * @param vehicle_parameter is defined in vehicle_parameter.proto</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AbstractVehicleFactory&gt; <span class="title">CreateVehicle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> VehicleParameter &amp;vehicle_parameter)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于工厂模式的介绍，可以参考：下面简单介绍</p><p>[https://blog.csdn.net/linwh8/article/details/51232834][https://blog.csdn.net/linwh8/article/details/51232834]</p><p>[https://www.runoob.com/design-pattern/abstract-factory-pattern.html][https://www.runoob.com/design-pattern/abstract-factory-pattern.html]</p></li></ul><h3 id="浅谈工厂模式">2. 浅谈工厂模式</h3><p><img src="/2020/02/07/factory-mode/factorymode.png"></p><p>首先<code>ProductFactory</code>可以想象为生产某种产品（抽象类产品）的某类工厂（抽象类工厂），此抽象类工厂演变出许多实例化对象，即为实际的工厂（工厂实例化对象）：<code>ConcreteProductFactoryA,ConcreteProductFactoryB</code> ,而这两个<strong>实例化工厂</strong>生产的内容与抽象工厂定义的内容一致，即包含一个抽象类product。</p><p>然后<code>Product</code>某种产品（抽象类产品），它能演变出许多实例化对象:<code>ConcreteProductA,ConcreteProductB</code> ,也就是上面的实例化工厂都能生产A、B两种产品。</p><p>举个栗子：</p><p>现在由生产口罩的工厂（抽象类工厂）：工厂A(工厂实例化对象)，工厂B(工厂实例化对象)。这两个工厂都生产口罩（抽象类产品）：KN95口罩（产品实例化对象）、一次性医用口罩(产品实例化对象)。</p><h3 id="apollo项目工厂模式分析">3.Apollo项目工厂模式分析</h3><p>​ Apollo采用的是抽象工厂模式，因为该项目使用模板定义工厂类，因此工厂模式经典定义中的抽象工厂类不再需要，Apollo提供了一个工厂模板(<code>modules/common/util/factory.h</code>) ,该模板可支持任何类型的输入，类图如下：</p><p><img src="/2020/02/07/factory-mode/ApolloFactory.png"></p><blockquote><p>Factory类中包含了<code>Register()</code>、<code>Unregister()</code> 、<code>Empty()</code>、<code>CreateObjectOrNull()</code>、<code>CreateObject()</code> 等公有函数，其中<code>Register()</code> 、<code>Unregister()</code>函数用于注册和反注册产品类，其作用与经典模式中抽象工厂接口类的功能类似，<code>Empty()</code> 函数用于判断当前工厂类中是否包含产品创建函数，<code>CreateObjectOrNull()</code>、<code>CreateObject()</code> 函数用于创建可能包含空指针和不包含空指针的产品类对象。</p></blockquote><p>​ Factory工厂模板维护了一个Map用来管理<code>IdentifierType</code>和<code>ProductCreator</code>的键值对，根据输入的<code>IdentifierType</code>,模板可以返回<code>ProductCreator</code>生产的产品，从而实现了从<code>IdentifierType</code>到<code>Productde</code> &quot;映射&quot;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IdentifierType, <span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">ProductCreator</span> = <span class="title">AbstractProduct</span> *(*)(),</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">MapContainer</span> = <span class="title">std</span>:</span>:<span class="built_in">map</span>&lt;IdentifierType, ProductCreator&gt;&gt;</span><br></pre></td></tr></table></figure><p>Factory类模板中参数<code>ProductCreator=AbstractProduct*（*）()</code> 全部采用简洁的Lambda表达式实现</p><blockquote><p>lambda 表达式：</p><p>完整格式声明：<code>[capture list] (params list) mutable exception-&gt; return type { function body }</code></p><p>capture list:捕获外部变量列表 params list:形参列表 exception:异常设定（一般省略）</p></blockquote><p>Apollo项目中对Factory类实例化的情形包括但不限于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> common::util::Factory&lt;apollo::common::VehicleBrand,</span><br><span class="line">                                   AbstractVehicleFactory&gt;&#123;<span class="comment">/*.../*&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanClientFactory</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> apollo::common::util::Factory&lt;CANCardParameter::CANCardBrand,</span><br><span class="line">                                           CanClient&gt; &#123;<span class="comment">/*.../*&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apollo::common::util::Factory&lt;TaskConfig::TaskType, NaviTask&gt; task_factory_;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common::util::Factory&lt;PlannerType, Planner&gt; planner_factory_</span><br></pre></td></tr></table></figure><p>注册产品类代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NaviPlanner::RegisterTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  task_factory_.Register(TaskConfig::NAVI_PATH_DECIDER,</span><br><span class="line">                         []() -&gt; NaviTask* &#123; <span class="keyword">return</span> <span class="keyword">new</span> NaviPathDecider(); &#125;);</span><br><span class="line">  task_factory_.Register(TaskConfig::NAVI_SPEED_DECIDER,</span><br><span class="line">                         []() -&gt; NaviTask* &#123; <span class="keyword">return</span> <span class="keyword">new</span> NaviSpeedDecider(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的产品创建函数<code>ProductCreator=AbstractProduct*（*）()</code> 采用Lambda表达式实现。</p><p>创建具体的产品类对象的代码为:</p><p><code>modules/planning/planner/navi/navi_planner.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NaviPlanner::Init</span><span class="params">(<span class="keyword">const</span> PlanningConfig&amp; <span class="built_in">config</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// NaviPlanner is only used in navigation mode based on the real-time relative</span></span><br><span class="line">  <span class="comment">// map.</span></span><br><span class="line">  <span class="keyword">if</span> (!FLAGS_use_navigation_mode) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">"NaviPlanner is only used in navigation mode."</span>;</span><br><span class="line">    AERROR &lt;&lt; msg;</span><br><span class="line">    <span class="keyword">return</span> Status(ErrorCode::PLANNING_ERROR, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AINFO &lt;&lt; <span class="string">"In NaviPlanner::Init()"</span>;</span><br><span class="line">  RegisterTasks();</span><br><span class="line">  PlannerNaviConfig planner_conf =</span><br><span class="line">      <span class="built_in">config</span>.navigation_planning_config().planner_navi_config();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> task : planner_conf.task()) &#123;</span><br><span class="line">    tasks_.emplace_back(</span><br><span class="line">        task_factory_.CreateObject(<span class="keyword">static_cast</span>&lt;TaskConfig::TaskType&gt;(task)));</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Created task:"</span> &lt;&lt; tasks_.back()-&gt;Name();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; task : tasks_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!task-&gt;Init(<span class="built_in">config</span>)) &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">msg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          common::util::StrCat(<span class="string">"Init task["</span>, task-&gt;Name(), <span class="string">"] failed."</span>))</span></span>;</span><br><span class="line">      AERROR &lt;&lt; msg;</span><br><span class="line">      <span class="keyword">return</span> Status(ErrorCode::PLANNING_ERROR, msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件为：<code>modules/planning/conf/planning_config_navi.pb.txt</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">planner_type : NAVI</span><br><span class="line">planner_navi_config &#123;</span><br><span class="line">  task : NAVI_PATH_DECIDER</span><br><span class="line">  task : NAVI_SPEED_DECIDER</span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>上述配置文件表明，<code>NaviPlanner</code>类动态生成了<code>NAVI_PATH_DECIDER</code> 、<code>NAVI_SPEED_DECIDER</code> 任务对象。</p>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apollo </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo InternalProc 感知处理流程</title>
      <link href="/2020/02/07/Apollo-IntenalProc/"/>
      <url>/2020/02/07/Apollo-IntenalProc/</url>
      
        <content type="html"><![CDATA[<p>Apollo 总体感知算法处理流程</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> 感知 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo回调函数概览</title>
      <link href="/2020/02/06/OnReceiveImages/"/>
      <url>/2020/02/06/OnReceiveImages/</url>
      
        <content type="html"><![CDATA[<h3 id="一onreceiveimages内部函数处理流程">一、OnReceiveImages()内部函数处理流程:</h3><a id="more"></a><ol type="1"><li>由FusionCameraDetectionComponent::Init()中的InitCameraListeners()创建回调函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FusionCameraDetectionComponent::OnReceiveImage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image&gt; &amp;message,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;camera_name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>函数参数说明：</p><blockquote><p>apollo::drivers::Image类包含：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> apollo.common.Header header = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> frame_id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">double</span> measurement_time = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> height = <span class="number">4</span>;  <span class="comment">// image height, that is, number of rows</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> width = <span class="number">5</span>;   <span class="comment">// image width, that is, number of columns</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> encoding = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> step = <span class="number">7</span>;  <span class="comment">// Full row length in bytes</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">bytes</span> data = <span class="number">8</span>;   <span class="comment">// actual matrix data, size is (step * rows)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该消息类型文件定义：<code>modules/drivers/proto/sensor_image.proto</code></p></blockquote><blockquote><p><code>std::string &amp;camera_name</code> 包含两类：</p><ul><li>front_6mm</li><li>front_12mm</li></ul></blockquote><ol start="2" type="1"><li>进行TimeStamp的判断之后：</li></ol><ul><li><p>创建<code>apollo::perception::PerceptionObstacles</code> 对象<em><code>out_message</code></em></p><blockquote><p>类定义位于modules/perception/proto/perception_obstacle.proto</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PerceptionObstacles</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> PerceptionObstacle perception_obstacle = <span class="number">1</span>;  <span class="comment">// An array of obstacles</span></span><br><span class="line">  <span class="keyword">optional</span> common.Header header = <span class="number">2</span>;                    <span class="comment">// Header</span></span><br><span class="line">  <span class="keyword">optional</span> common.ErrorCode error_code = <span class="number">3</span> [default = OK];</span><br><span class="line">  <span class="keyword">optional</span> LaneMarkers lane_marker = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">optional</span> CIPVInfo cipv_info = <span class="number">5</span>;  <span class="comment">// Closest In Path Vehicle (CIPV)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>创建<code>SensorFrameMessage</code> 类对象<em><code>prefused_message</code></em></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorFrameMessage</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SensorFrameMessage() &#123; type_name_ = <span class="string">"SensorFrameMessage"</span>; &#125;</span><br><span class="line">  ~SensorFrameMessage() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetTypeName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> type_name_; &#125;</span><br><span class="line">  <span class="function">SensorFrameMessage* <span class="title">New</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SensorFrameMessage; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  apollo::common::ErrorCode error_code_ = apollo::common::ErrorCode::OK;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> sensor_id_;</span><br><span class="line">  <span class="keyword">double</span> timestamp_ = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> seq_num_ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> type_name_;</span><br><span class="line">  base::HdmapStructConstPtr hdmap_;</span><br><span class="line"></span><br><span class="line">  base::FramePtr frame_;</span><br><span class="line"></span><br><span class="line">  ProcessStage process_stage_ = ProcessStage::UNKNOWN_STAGE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote></li></ul><ol start="3" type="1"><li>调用函数<code>IntenalProc(message,camera_name,&amp;error_code,prefused_message.get(),out_message.get())</code></li></ol><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FusionCameraDetectionComponent::InternalProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::drivers::Image <span class="keyword">const</span>&gt; &amp;in_message,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;camera_name, apollo::common::ErrorCode *error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">SensorFrameMessage *prefused_message,</span></span></span><br><span class="line"><span class="function"><span class="params">apollo::perception::PerceptionObstacles *out_message)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实现对接收到图像信息的处理，程序前部分实现对<code>prefused_message</code> 和 <code>camera_frame</code>相关数据与参数的赋值，获取相机到世界坐标系的仿射矩阵</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera2world_trans_wrapper_map_[camera_name]-&gt;GetSensor2worldTrans(...);</span><br></pre></td></tr></table></figure><p>填充图像数据,其中数据来自OnreceiveMessage接收到的消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">camera_frame.data_provider-&gt;FillImageData(</span><br><span class="line">    image_height_, image_width_,</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span> *&gt;(in_message-&gt;data().data()),</span><br><span class="line">    in_message-&gt;encoding())</span><br></pre></td></tr></table></figure><p>有了数据之后，科技进行算法处理了，运行<code>camera_obstacle_pipelin_-&gt;Perception(&amp;camera_frame)</code> ,实现主要图像算法处理。</p><ul><li><code>Perception</code>中主要的处理函数如下</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObstacleCameraPerception::Perception</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> CameraPerceptionOptions &amp;options, CameraFrame *frame)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//lane detector and postprocessor</span></span><br><span class="line">        lane_detector_-&gt;Detect(lane_detetor_options, frame)</span><br><span class="line">        ...</span><br><span class="line">        lane_postprocessor_-&gt;Process2D(lane_postprocessor_options, frame)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//Calibration service</span></span><br><span class="line">        frame-&gt;calibration_service-&gt;Update(frame);</span><br><span class="line">    ...</span><br><span class="line">        lane_postprocessor_-&gt;Process3D(lane_postprocessor_options, frame)</span><br><span class="line">        ...</span><br><span class="line">        WriteLanelines(write_out_lane_file_, lane_file_path, frame-&gt;lane_objects)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Obstacle prediction</span></span><br><span class="line">    tracker_-&gt;Predict(tracker_options, frame)      </span><br><span class="line">    <span class="comment">// detect :detector 根据provider名称建立</span></span><br><span class="line">    detector-&gt;Detect(detector_options, frame)</span><br><span class="line">    WriteDetections(...)<span class="comment">//write all detections results as kitti format</span></span><br><span class="line">    <span class="comment">//extarctor</span></span><br><span class="line">    extractor_-&gt;Extract(extractor_options, frame)</span><br><span class="line">    <span class="comment">//tracker Associate2D</span></span><br><span class="line">    tracker_-&gt;Associate2D(tracker_options, frame)</span><br><span class="line">    <span class="comment">//Transform</span></span><br><span class="line">    transformer_-&gt;Transform(transformer_options, frame)</span><br><span class="line">    <span class="comment">//Obstacle postprocessor</span></span><br><span class="line">    obstacle_postprocessor_-&gt;<span class="built_in">Process</span>(obstacle_postprocessor_options,</span><br><span class="line">                                        frame)</span><br><span class="line">    <span class="comment">//tracker Associate3D</span></span><br><span class="line">    tracker_-&gt;Associate3D(tracker_options, frame)</span><br><span class="line">    <span class="comment">//track</span></span><br><span class="line">    tracker_-&gt;Track(tracker_options, frame)</span><br><span class="line">    <span class="comment">//save tracked detections results as kitti format</span></span><br><span class="line">    WriteDetections(tracked_detection_out_dir,frame-&gt;tracked_objectes);</span><br><span class="line">    <span class="comment">//填充多边形并设置锚点</span></span><br><span class="line">    FillObjectPloygonFromBBox3D(tracked_object)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><ol start="4" type="1"><li><p>make protobuf message</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MakeProtobufMsg(msg_timestamp, seq_num_, camera_frame.tracked_objects,</span><br><span class="line">                      camera_frame.lane_objects, *error_code,</span><br><span class="line">                      out_message)</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FusionCameraDetectionComponent::MakeProtobufMsg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> msg_timestamp, <span class="keyword">int</span> seq_num,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt; &amp;objects,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::LaneLine&gt; &amp;lane_objects,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> apollo::common::ErrorCode error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">    apollo::perception::PerceptionObstacles *obstacles)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Determine CIPV</p></li></ol><h3 id="二detector-and-tracker">二、detector and tracker</h3><p>​ 目前发表的相关检测跟踪的算法(ResNet,YOLO等)主要面向广泛的计算机视觉的应用，与自动驾驶领域中的检测和跟踪还是存在一定的区别的，由于汽车行驶在结构化、规则化的道路上，面向的场景更为具体，有很多的几何约束可以用于检测；其次，自动驾驶中的检测模型需要输出的信息更多，包括了障碍物的尺寸、朝向、速度等信息，然而如果以上任务都分别由专用的模块进行处理，则对系统负担较大，处理流程太长，因此还需要做<strong>多任务学习</strong>和网络结构的适配。</p><p>​ 一个完整的系统除了深度学习模型，还需要做一些后处理，后处理模块针对下游模块，对后续的影响比较直接。在视觉感知中，后处理主要分为三个部分：</p><p>​ 第一是2D-3D的几何计算，2D到3D的转换需要考虑的因素包括:</p><blockquote><ul><li>相机pose 的影响</li><li>接地点</li><li>稳定性</li></ul></blockquote><p>​ 第二是时序信息计算，主要针对跟踪处理，需要注意以下几点：</p><blockquote><ul><li>对相机帧率和延时有要求，要求跟踪必须是一个轻量级的模块，因为检测已经占据了大部分时间</li><li>充分利用检测模型的输出信息（特征、类别等）进行跟踪</li><li>可以考虑轻量级Metric Learning</li></ul></blockquote><p>​ 第三是多相机的环视融合</p><blockquote><ul><li>相机布局决定融合策略，要做好视野重叠</li></ul></blockquote><p>​ 检测——&gt;2D to 3D转换 ——&gt;跟踪——&gt;位置、速度</p><p>​ HM目标跟踪器的主要功能是跟踪分割步骤检测到的障碍物。通常，它通过将当前检测结果与现有跟踪列表相关联的方式，形成和更新跟踪列表。如果原来的目标都不在出现则删除旧跟踪列表，在确认新的检测结果之后会生成新的跟踪列表。</p><p>​ 关联之后，将会估计更新后的跟踪列表的运动状态。HM目标跟踪器使用Hungarian算法（匈牙利算法）对检测和跟踪(detection-to-track)进行关联，使用Robust Kalman Filter（鲁棒卡尔曼滤波）进行运动估计。</p><ul><li><p>检测到跟踪关联</p><p>将检测与现有的跟踪列表进行关联时，Apollo构建了一个二分图并使用Hungarian算法对检测和跟踪(detection-to-track)进行关联，使用<code>Robust Kalman Filter</code> (鲁棒卡尔曼滤波器)进行运动估计。</p></li><li><p>计算关联距离矩阵</p><p>首先建立一个关联距离矩阵。一个给定的检测和跟踪之间的距离可以通过一系列关联属性进行计算，这些关联属性包括运动一致性和外观一致性。<code>HM</code> 跟踪器中距离计算中使用的一些属性如下所示：</p><p>​</p><table><thead><tr class="header"><th>关联属性名称</th><th>评估一致性的说明</th></tr></thead><tbody><tr class="odd"><td>location_distance</td><td>运动</td></tr><tr class="even"><td>direction_distance</td><td>运动</td></tr><tr class="odd"><td>bbox_size_distance</td><td>外观</td></tr><tr class="even"><td>point_num_distance</td><td>外观</td></tr><tr class="odd"><td>histogram_distance</td><td>外观</td></tr></tbody></table></li></ul><p><strong>(1)tracker-&gt;Predict()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OMTObstacleTracker::Predict</span><span class="params">(<span class="keyword">const</span> ObstacleTrackerOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 CameraFrame *frame)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;target : targets_) &#123;</span><br><span class="line">    target.Predict(frame);</span><br><span class="line">    <span class="keyword">auto</span> obj = target.latest_object;</span><br><span class="line">    frame-&gt;proposed_objects.push_back(obj-&gt;object);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对跟踪列表中的每一个target通过kalman相关模型进行预测，获得新图像中的候选障碍物目标添加到<code>frame-&gt;proposed_objects</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Target::Predict</span><span class="params">(CameraFrame *frame)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">delta_t</span> =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(frame-&gt;timestamp - latest_object-&gt;timestamp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">delta_t</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  image_center.Predict(<span class="keyword">delta_t</span>);</span><br><span class="line">  <span class="keyword">float</span> acc_variance = target_param_.world_center().process_variance();</span><br><span class="line">  <span class="keyword">float</span> delta_t_2 = <span class="keyword">delta_t</span> * <span class="keyword">delta_t</span>;</span><br><span class="line">  <span class="keyword">float</span> pos_variance = <span class="number">0.25f</span> * acc_variance * delta_t_2 * delta_t_2;</span><br><span class="line">  <span class="keyword">float</span> vel_variance = acc_variance * delta_t_2;</span><br><span class="line">  world_center.process_noise_(<span class="number">0</span>, <span class="number">0</span>) = pos_variance;</span><br><span class="line">  world_center.process_noise_(<span class="number">1</span>, <span class="number">1</span>) = pos_variance;</span><br><span class="line">  world_center.process_noise_(<span class="number">2</span>, <span class="number">2</span>) = vel_variance;</span><br><span class="line">  world_center.process_noise_(<span class="number">3</span>, <span class="number">3</span>) = vel_variance;</span><br><span class="line">  world_center.Predict(<span class="keyword">delta_t</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const position kalman predict</span></span><br><span class="line">  world_center_const.process_noise_.setIdentity();</span><br><span class="line">  world_center_const.process_noise_(<span class="number">0</span>, <span class="number">0</span>) = vel_variance * delta_t_2;</span><br><span class="line">  world_center_const.process_noise_(<span class="number">1</span>, <span class="number">1</span>) =</span><br><span class="line">      world_center_const.process_noise_(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  world_center_const.Predict(<span class="keyword">delta_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) detector-&gt;Detect</strong> 根据图像信息(frame)检测障碍物,接口定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: detect obstacle from image.</span></span><br><span class="line"><span class="comment">// @param [in]: options</span></span><br><span class="line"><span class="comment">// @param [in/out]: frame</span></span><br><span class="line"><span class="comment">// obstacle type and 2D bbox should be filled, required,</span></span><br><span class="line"><span class="comment">// 3D information of obstacle can be filled, optional.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Detect</span><span class="params">(<span class="keyword">const</span> ObstacleDetectorOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">                    CameraFrame *frame)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>其中主要进行前向推理过程(inference),apollo支持的推理框架由<code>Inference</code>这个协议类确定，并通过&quot;inference_factory&quot;进行对象创建，目前支持：<code>CaffeNet</code>、<code>RTNet</code>、<code>RTNetInt8</code>、<code>PaddleNet</code>这几种类型的模型结构。</p><blockquote><p>RTNet是TensorRT框架生成的模型，TensorRT是高性能的深度学习<strong>推理</strong>优化器，将跨平台的&quot;Tensorflow,caffe,MxNet,Pytorch&quot;等深度学习框架训练好的模型解析后进行统一的部署。</p></blockquote><p>主要检测部分的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_objects_gpu(yolo_blobs_, stream_, types_, nms_, yolo_param_.model_param(),</span><br><span class="line">                  light_vis_conf_threshold_, light_swt_conf_threshold_,</span><br><span class="line">                  overlapped_.<span class="built_in">get</span>(), idx_sm_.<span class="built_in">get</span>(), &amp;(frame-&gt;detected_objects));</span><br></pre></td></tr></table></figure><p>其实现位于<code>region_output.cu</code>中,最终检测检测结果添加到<code>frame-&gt;detected_objects</code>,各输入参数含义如下。</p><p><code>yolo_blobs_</code>:为yolo前向推断模型结构，blob为一个封装了<code>SyncedMemory</code>的包装器，作为图像，特征图的基本计算单元 <code>stream_</code>:由cudaStream_t定义cuda中的流，可以实现一个设备上同时运行多个核函数。 <code>types_</code>:为检测的目标类型; <code>nms_</code>: 为nms的相关参数 ; <code>yolo_param_.model_param()</code>:模型的相关参数(一些阈值) <code>light_vis_conf_threshold_</code>和<code>light_swt_conf_threshold_</code>: vis指visible,swt指swtich 值得是车灯检测的相关阈值</p><blockquote><p>cuda-c (后缀名<code>.cu</code>)方便我们利用GPU并行处理来加速程序的运行速度</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
          <category> 感知 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slam初探</title>
      <link href="/2020/02/04/slam1/"/>
      <url>/2020/02/04/slam1/</url>
      
        <content type="html"><![CDATA[<img src="/2020/02/04/slam1/slam.png"><center>图1. slam 流程图</center>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo中的标定</title>
      <link href="/2020/02/04/apollo_calibration/"/>
      <url>/2020/02/04/apollo_calibration/</url>
      
        <content type="html"><![CDATA[<p>Apollo中的在线标定：用于获取实时外参(针对由于路面颠簸等情况造成相机位姿改变的校正)</p><a id="more"></a><h2 id="calibration_service">Calibration_service</h2><h3 id="初始化">1. 初始化</h3><p><strong>配置文件与配置信息</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">calibration_service_param &#123;</span><br><span class="line">  plugin_param &#123;</span><br><span class="line">      name : <span class="string">"OnlineCalibrationService"</span></span><br><span class="line">      root_dir : <span class="string">""</span></span><br><span class="line">      config_file : <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  calibrator_method : <span class="string">"LaneLineCalibrator"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/apollo_calibration/init.png"></p><p><code>modules/perception/camera/lib/calibration_service/online_calibration_service/online_calibration_service.cc</code></p><p><img src="/2020/02/04/apollo_calibration/home/jachin/space/myblog/blog/source/_posts/apollo_calibration/2.png"></p><p>其中相机状态(camera_status)主要包含以下信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CameraStatus</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> camera_ground_height = <span class="number">-1.f</span>;</span><br><span class="line">  <span class="keyword">float</span> pitch_angle = <span class="number">0.f</span>;</span><br><span class="line">  <span class="keyword">float</span> pitch_angle_diff = <span class="number">0.f</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; k_matrix = &#123;<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ground_plane = &#123;<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>LaneLineCalibrator主要初始化过程</strong>：</p><p><img src="/2020/02/04/apollo_calibration/3.png"></p><p><strong>LaneBasedCalibator初始化</strong>：</p><p><img src="/2020/02/04/apollo_calibration/4.png"></p><p><strong>HistogramEstimator初始化</strong>：(这个地方是直方图密度估计吗？存疑)</p><p><img src="/2020/02/04/apollo_calibration/5.png"></p><hr><h2 id="参考文章">参考文章</h2><blockquote><p>[1]崔洪柳. 基于车道线检测的车载摄像机在线标定算法[D].东北大学,2015.</p></blockquote><h3 id="单应性矩阵">单应性矩阵</h3><h3 id="相机畸变校正brown模型">相机畸变校正　Brown模型</h3><p>在摄影测量和计算机视觉中都需要对含有畸变的影像进行改正操作，常用到的模型是对透视影像改正的Brown模型</p>]]></content>
      
      
      <categories>
          
          <category> apollo </category>
          
          <category> perception </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
            <tag> 标定 </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客破壳日</title>
      <link href="/2020/02/04/hello-world/"/>
      <url>/2020/02/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>博客配置完工啦！今天是博客的破壳日o(￣ヘ￣o#) 2020 fighting!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最优估计 -- kalman and lsm</title>
      <link href="/2020/02/04/kalman_filter_and_lsm/"/>
      <url>/2020/02/04/kalman_filter_and_lsm/</url>
      
        <content type="html"><![CDATA[<p>kalman Filter 和 least square 目的均为最优化某一指标，指标是优化的关键：</p><a id="more"></a><p>[TOC]</p><p>常用的估计准则有：</p><ul><li><p>无偏估计：估计值的期望等于被估计参数的真实值。</p></li><li><p>线性最小方差估计：将估计量限制为观测值的线性函数，已知观测量Z和和被估计量X一二阶矩（EX,Var{X},EZ,Var{Z},Cov{X,Z}）,使估计误差的方差最小，即最小化<span class="math inline">\(tr\{E[\tilde{X}-E\tilde{X}][\tilde{X}-E\tilde{X}]^{T}\}\)</span> ,<span class="math inline">\(\tilde{X}\)</span>为估计误差（等价于最小化均方误差阵，若为无偏估计）可得其无偏估计值为<span class="math inline">\(\tilde{X}_{LMV}(Z)=EX+cov(X,Z)(var(Z))^{-1}[Z-EZ]\)</span>对于观测模型Z=HX+V，上述条件若已知</p><p><span class="math inline">\(\{EX=\mu_x,Var(X)=P_x,EV=0,Var(V)=R,E(XV^T)=0\}\)</span> 即可得到。</p></li><li><p>最小二乘估计：对数据（X、Z）的统计特性一无所知，但仍需对X进行估计，目标是最小化残差<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>平方和。</p><p>满足最小方差必满足残差平方和最小，反之则不成立。</p></li></ul><h4 id="经典最小二乘">1.经典最小二乘</h4><p>针对隐状态X，若其无法直接观测，但间接获取其观测值<span class="math inline">\(Z=[z_1,z_2,\dots,z_n]^T\)</span> ,若其观测值为状态值的线性函数： <span class="math display">\[Z_i=H_iX+V_i,i=1,\dots,n\]</span> <span class="math inline">\(z_i\)</span>为第i次测量的观测值，<span class="math inline">\(H_i\)</span>为第i次测量的观测模型(设计矩阵，实验的观测值)，<span class="math inline">\(V_i\)</span>为第i次测量的噪声（误差）。</p><p>则第i次测量的估计误差： <span class="math display">\[\hat{e_i}=z_i-H_i\hat{X}\]</span> 则n次测量的误差（残差）平方和为优化指标： <span class="math display">\[J(\hat{X})=\sum_{i=1}^{n}{(z_i-H_i\hat{X})^2}=(Z-H\hat{X})^T(Z-H\hat{X}) \\=tr[(Z-H\hat{X})(Z-H\hat{X})^T]\]</span> 令<span class="math inline">\(\frac{\partial{J}}{\partial{\hat{X}}}=0\)</span> ,可得最小二乘估计值： <span class="math display">\[\hat{X}_{LS}=(H^TH)^{-1}H^TZ\]</span> 将<span class="math inline">\(Z=HX+V\)</span>此时状态的估计误差： <span class="math display">\[\tilde{X}_{LS}=X-\hat{X}_{LS}=-(H^TH)^{-1}H^TV\]</span> 若测量噪声均值为0，则<span class="math inline">\(E(\tilde{X}_{LS})=0\)</span>,此时最小二乘估计为<strong><u>无偏估计</u></strong>，<strong>状态估计误差的（协）方差[^ 2] <span class="math inline">\(Var(\tilde{X}_{LS})=E[(\tilde{X}-E\tilde{X})(\tilde{X}-E\tilde{X})^T]\)</span>与估计量的均方误差矩阵<span class="math inline">\(E[X-\hat{X}][X-\hat{X}]^T\)</span>相等</strong>。可见标准最小二乘不需要噪声V的任何统计信息。</p><p>由(5)式可得： <span class="math display">\[\begin{align}Var(\tilde{X}_{LS})=E[X-\hat{X}][X-\hat{X}]^T &amp; = (H^TH)^{-1}H^TE(VV^T)H(H^TH)^{-1}\\&amp;=(H^TH)^{-1}H^TRH(H^TH)^{-1}\end{align}\]</span> 其中<span class="math inline">\(R=E(VV^T)\)</span>为测量误差（噪声）的（协）方差阵。</p><h4 id="加权最小二乘weighted-least-square">加权最小二乘（weighted least square）</h4><p>在经典最小二乘中，假定每一次测量的权重相同，但是一般来说近期数据比远期数据影响更大，因此引入加权最小二乘，其指标形式： <span class="math display">\[J_W(\hat{X})=\sum_{i=1}^{n}{(z_i-H_i\hat{X})^2}=(Z-H\hat{X})^TW(Z-H\hat{X})\]</span> 同样使其偏导数为0,可得 <span class="math display">\[\hat{X}_{LSW}=(H^TWH)^{-1}H^TWZ\]</span></p><hr><p>由附录<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>,若噪声不满足同方差，则普通最小二乘(4)并不是BLUE，此时噪声的协方差阵</p><p><span class="math inline">\(E[VV^T]=\sigma^2R,R\neq{I}\)</span> ,<span class="math inline">\(R=\begin{bmatrix}r_1\\&amp;\ddots\\&amp;&amp; r_n\end{bmatrix}\)</span>,即原模型存在异方差性。</p><p>设<span class="math inline">\(R=DD^T,D=\begin{bmatrix}\sqrt{r_1}\\&amp;\ddots\\&amp;&amp; \sqrt{r_n}\end{bmatrix}\)</span> ,用<span class="math inline">\(D^{-1}\)</span>同时左乘<span class="math inline">\(Z=HX+V\)</span>两端得到新的模型： <span class="math display">\[\begin{align}D^{-1}Z&amp;=D^{-1}HX+D^{-1}V \\Z^{\star}&amp;=H^{\star}X+V^{\star}\end{align}\]</span> 此时,原模型的加权最小二乘估计量为无偏的。 <span class="math display">\[\begin{align}E[V^{\star}V^{\star T}]&amp;=E[D^{-1}VV^TD^{-1\ T}]\\&amp;=D^{-1}E[VV^T]D^{-1\ T}\\&amp;=\sigma^2D^{-1}RD^{-1\ T}\\&amp;=\sigma^2I\end{align}\]</span> 此时得到的参数估计为： <span class="math display">\[\begin{align}\hat{X}_{LSW}&amp;=(H^{\star T}H^{\star})^{-1}H^{\star T}Z^{\star}\\&amp;=(H^TR^{-1}H)^{-1}H^TR^{-1}Z\end{align}\]</span> 可以证明（见附录），当<span class="math inline">\(W=R^{-1}\)</span>时，最小二乘估计时缺少初值条件下的<strong><u>线性无偏最小方差估计</u></strong>（BLUE,Best Linear Unbiased Estimation）——即能够使估计误差的方差阵最小，又称马尔可夫估计,其中 <span class="math display">\[R=E[VV^T]\]</span> 为随机噪声的（协）方差阵（对称正定阵）。</p><h4 id="递推最小二乘recursive-least-squarerls">2.递推最小二乘（Recursive Least Square,RLS）</h4><p>上述方法进行一次估计需要所有历史数据，不利于在线估计，考虑前n次测量： <span class="math display">\[Z_n=H_nX+V_n\]</span> 则加权的最小二乘估计为： <span class="math display">\[\hat{X}_{LSW}(n)=(H_{n}^TR_{n}^{-1}H_n)^{-1}H_{n}^TR_{n}^{-1}Z_n\]</span> 估计误差的（协）方差矩阵为： <span class="math display">\[\begin{align}P_n&amp;=E[\tilde{X}_{LSW}(n)\tilde{X}_{LSW}^T(n)]\\&amp;=E[-(H^TR^{-1}H)^{-1}]H^TR^{-1}VV^TR^{-1}H(H^TR^{-1}H)^{-1}\\&amp;=(H^TR^{-1}H)^{-1}H^TR^{-1}H(H^TR^{-1}H)^{-1}\\&amp;=(H^TR^{-1}H)^{-1}\end{align}\]</span> 结合上述两式，可得： <span class="math display">\[\hat{X}_{LSW}(n)=P_nH_{n}^TR_{n}^{-1}Z_n\]</span> 现得到一个新的测量值： <span class="math display">\[z_{n+1}=H_{n+1}X+v_{n+1}\]</span> 添加到矩阵中： <span class="math display">\[\hat{X}_{LSW}(n+1)=(H_{n+1}^TR_{n+1}^{-1}H_{n+1})^{-1}H_{n+1}^TR_{n+1}^{-1}Z_{n+1}\]</span> 将<u>新的测量噪声</u>加入到原本的测量噪声矩阵中：R阵应为对角阵： <span class="math display">\[R_{k+1}^{-1}=\begin{bmatrix}R_n^{-1} &amp; 0 \\0&amp;r^{-1}_{n+1}\end{bmatrix}\]</span> 将式子展开： <span class="math display">\[P_{n+1}^{-1}=H_{n+1}^TR_{n+1}^{-1}H_{n+1}=[H_n^T,h_{n+1}^T]\begin{bmatrix}R_n^{-1} &amp; 0 \\0&amp;r^{-1}_{n+1}\end{bmatrix}\begin{bmatrix}H_n\\h_{n+1}\end{bmatrix}=H_n^TR_n^{-1}H_n+h_{n+1}^Tr_{n+1}^{-1}h_{n+1}\]</span> 即： <span class="math display">\[P_{n+1}^{-1}=P_n^{-1}+h_{n+1}^Tr_{n+1}^{-1}h_{n+1}\]</span> 综上，可以推得： <span class="math display">\[\begin{align}P_{n+1}&amp;=P_n-P_nh_{n+1}^T[h_{n+1}P_nh_{n+1}^T+r_{n+1}]^{-1}h_{n+1}P_n\\K_{n+1} &amp;= P_{n+1}h_{n+1}^Tr_{n+1}^{-1}\\\hat{X}_{LSW}(n+1)&amp;=\hat{X}_{LSW}(n)+K_{n+1}[z_{n+1}-h_{n+1}\hat{X}_{LSW}(n)]\end{align}\]</span> 其中<span class="math inline">\(K_{n+1}\)</span>可将(31)代入展开为： <span class="math display">\[K_{n+1} = P_nh_{n+1}^T[h_{n+1}P_nh_{n+1}^T+r_{n+1}]^{-1}\]</span> 因此<span class="math inline">\(P_{n+1}\)</span>亦可表示为： <span class="math display">\[P_{n+1}=P_n-K_{n+1}h_{n+1}P_n\]</span></p><h4 id="卡尔曼滤波">3.卡尔曼滤波</h4><p>若被估计量X不随时间变化，或随时间缓慢变化则为“静态估计”，而被估计量随时间变化为“动态估计”。</p><h4 id="参考">4.参考</h4><blockquote><p>https://blog.csdn.net/qinruiyan/article/details/50793114</p><p>《最优估计理论》刘胜，张红梅，科学出版社</p><h6 id="最佳线性无偏估计gm假设">最佳线性无偏估计（GM假设）</h6><p>假设多元线性回归模型：<span class="math inline">\(Z=HX+V\)</span> <span class="math display">\[\begin{align}Z&amp;=(z_1,\dots,z_n)^T\\H&amp;=\begin{bmatrix}h_{ij}\end{bmatrix}_{n\times{p}}\\X&amp;=(x_o,\dots,x_p)\\V&amp;=(v_0,\dots,v_n)\end{align}\]</span> 则GM假设： <span class="math display">\[\begin{align}E(V|H)&amp;=0,\forall H\ (零均值)\\Var(V|H)&amp;=E(VV^T|H)=\sigma^2I_n\ (同方差且不相关)\end{align}\]</span> 则此时对参数X的最佳线性无偏估计为： <span class="math display">\[\hat{X}=(H^TH)^{-1}H^TZ\]</span></p><h6 id="最小二乘估计与最小方差估计等价条件证明">最小二乘估计与最小方差估计等价条件证明：</h6><figure><img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin%20Jac\AppData\Roaming\Typora\typora-user-images\image-20191216221314847.png" alt="image-20191216221314847"><figcaption>image-20191216221314847</figcaption></figure><h6 id="各种估计方法的比较">各种估计方法的比较：</h6><figure><img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin%20Jac\AppData\Roaming\Typora\typora-user-images\image-20191216221240802.png" alt="image-20191216221240802"><figcaption>image-20191216221240802</figcaption></figure></blockquote><section class="footnotes"><hr><ol><li id="fn1"><p>残差在数理统计中是指实际观察值和估计值之间的差。若设线性回归模型为<span class="math inline">\(Z=HX+V\)</span> ,其中Z为n维输出向量，H是<span class="math inline">\(n\times(p+1)\)</span> 阶设计矩阵，X是p+1维向量，V为n维随机变量(扰动)。则回归系数的估计值<span class="math inline">\(\hat{X}=(H^TH)^{-1}H^TZ\)</span> ，拟合值<span class="math inline">\(\hat{Z} = H\hat{X}=H(H^TH)^{-1}H^TZ\)</span>,残差为<span class="math inline">\(\hat{\epsilon}=z_i-\hat{z_i}=z_i-H_i\hat{X}\)</span> ，其由观测真值和H阵给出，不考虑噪声V。 [^ 2]: https://zh.wikipedia.org/wiki/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5<img src="/2020/02/04/kalman_filter_and_lsm/C:/Users\Jachin Jac\AppData\Roaming\Typora\typora-user-images\image-20191215194027795.png" alt="image-20191215194027795" style="zoom:50%;"><a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>在线性回归模型中，如果随机噪声（误差）满足<strong>零均值、同方差且互不相关</strong>，则回归系数的最优线性无偏估计（BLUE，Best Linear unbiased estimator）就是普通最小二乘估计。<a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 最优估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo感知代码阅读笔记</title>
      <link href="/2020/02/04/perception/"/>
      <url>/2020/02/04/perception/</url>
      
        <content type="html"><![CDATA[<p>apollo 感知部分代码阅读 <a id="more"></a></p><p>[TOC]</p><h2 id="主入口">主入口</h2><p><code>cyber/mainboard/mainboard.cc/int main(int argc,char** argv){...}</code></p><blockquote><p>解析配置参数；初始化cyber环境；由Moudule Controller类创建对象<code>controller</code>,调用<code>controller.Init()</code> 启动各功能模块；进入Cyber RT消息循环，等待<code>apollo::cyber::WaitForShutdown();</code> 返回Main函数，清理资源退出。</p></blockquote><p><code>controller.Init()</code> 调用 <code>ModuleController::LoadAll()</code></p><p><code>cyber/mainboard/module_controller.cc/bool ModuleController::LoadAll(){...}</code></p><blockquote><p>循环读取DAG配置文件列表，得到配置文件中所有<code>dag_conf</code> ,调用</p><p><code>bool ModuleController::LoadModule(const std::string&amp; path)</code> 加载模块功能</p></blockquote><p><code>cyber/mainboard/module_controller.cc/ModuleController::LoadModule(&amp;path)</code></p><blockquote><p>根据路径得到dag文件配置，调用<code>bool ModuleController::LoadModule(const DagConfig&amp; dag_config)</code> 实现加载模型。</p></blockquote><ul><li>component文件结构：<ul><li>头文件</li><li>实现文件</li><li>构建文件：BUILD</li><li>DAG配置文件</li><li>Launch启动文件</li></ul></li><li>实现Component（Compnent组件构建过程）<ul><li>基于模板类<code>cyber::Component</code> 派生各组件类</li><li>在派生类(<code>FusionComponent</code> )中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></li><li>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类</li></ul></li><li>消息接收发送的方式</li></ul><hr><h2 id="感知模块对象创建过程">感知模块对象创建过程</h2><p>apollo中对象的创建大多采用直接法，也有部分对象使用单例模式创建<code>DECLARE_SINGLETON(AdapterManager)</code>,还有部分对象采用工厂模式创建。</p><p>感知（perception）模块位于命名空间<code>apollo::perception</code> 中，创建过程</p><p>可能用到了<strong>工厂模式</strong> 动态创建<code>apollo::perception::FusionCameraDetectionComponent</code>类对象，首先生成一个与之对应的工厂类，并将其加入到工厂集合类 <code>std::map</code> 中 (参考planning模块，是否如此 存疑)</p><p>具体参考文件：</p><p><code>cyber/class_loader/utility/...</code></p><p>创建过程位于<code>bool ModuleController::LoadModule(const DagConfig&amp; dag_config)</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ModuleController::LoadModule</span><span class="params">(<span class="keyword">const</span> DagConfig&amp; dag_config)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> load_path;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    class_loader_manager_.LoadLibrary(load_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; component : module_config.components()) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; class_name = component.class_name();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ComponentBase&gt; base =</span><br><span class="line">          class_loader_manager_.CreateClassObj&lt;ComponentBase&gt;(class_name);</span><br><span class="line">      <span class="keyword">if</span> (base == <span class="literal">nullptr</span> || !base-&gt;Initialize(component.<span class="built_in">config</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      component_list_.emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(base));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类对象指针找到后使用<code>classobj = factory-&gt;CreateObj();</code>即可将PerceptionComponent 类对象创建。</p><hr><h2 id="功能模块构建">功能模块构建</h2><blockquote><p>基于模板类<code>Component</code> 派生各组件类</p><p>在派生类<code>FusionComponent</code> 中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></p><p>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类</p></blockquote><ul><li>基于模板类<code>Component</code> 派生各组件类</li></ul><p>模板类Component最多可接受4各模板参数，每个模板参数表示一种输入信息类型。</p><p><code>cyber/component/component.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M0 = NullType, <span class="keyword">typename</span> M1 = NullType,</span><br><span class="line">          <span class="keyword">typename</span> M2 = NullType, <span class="keyword">typename</span> M3 = NullType&gt;</span><br><span class="line">class Component : <span class="keyword">public</span> ComponentBase &#123;...&#125;</span><br></pre></td></tr></table></figure><p>感知模块各组件类（继承于基类cyber::Component):</p><p><code>FusionCameraDetectionComponent</code> ,<code>FusionComponent</code>, <code>LaneDetectionComponent</code>,<code>LidarOutputComponent</code>,<code>radar_detection_component</code>,<code>RecognitionComponent</code>,<code>SegmentationComponent</code>,<code>TrafficLightPerceptionComponent</code>.</p><p>以<code>FusionComponent</code>为例,继承自<code>cyber::Component&lt;SensorFrameMessage&gt;</code>，消息参数为<code>SensorFrameMessage</code>，这些消息将会在<code>Proc</code>函数中周期性接收并处理。</p><p><code>perception/onborad/component/fusion_component.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FusionComponent</span> :</span> <span class="keyword">public</span> cyber::Component&lt;SensorFrameMessage&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  ~FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Proc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt;&amp; message)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InitAlgorithmPlugin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InternalProc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage <span class="keyword">const</span>&gt;&amp; in_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PerceptionObstacles&gt; out_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; viz_message)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::mutex s_mutex_;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint32_t</span> s_seq_num_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_method_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_main_sensor_;</span><br><span class="line">  <span class="keyword">bool</span> object_in_roi_check_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">double</span> radius_for_roi_object_check_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;fusion::ObstacleMultiSensorFusion&gt; fusion_;</span><br><span class="line">  <span class="built_in">map</span>::HDMapInput* hdmap_input_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;PerceptionObstacles&gt;&gt; writer_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;SensorFrameMessage&gt;&gt; inner_writer_;</span><br><span class="line">&#125;;</span><br><span class="line">CYBER_REGISTER_COMPONENT(FusionComponent);</span><br></pre></td></tr></table></figure><ul><li><p>在派生类<code>FusionComponent</code> 中覆盖虚函数<code>Init()</code> 和<code>Proc()</code></p><p><code>Init()</code> 创建实际对象，创建消息处理回调函数，创建输出器writer</p><p><code>Proc()</code> 周期性接收消息，执行相关处理，并向其他模块输出消息。</p></li><li><p>使用宏<code>CYBER_REGISTER_COMPONENT(FusionComponent)</code> 注册组件类，使<code>Cyber RT</code> 能够正确创建和加载该类对象。</p></li><li><p>BUILD构建文件</p><p><code>perception/onboard/component/BUILD</code></p><p>基于<code>perception_component_inner_camera</code> 生成 <code>libperception_component_camera.so</code></p><p>基于<code>perception_component_inner_lidar</code> 生成 <code>libperception_component_lidar.so</code></p><p>生成的共享库文件由<code>Cyber RT</code> 调度程序mainboard动态加载运行。</p></li><li><p>DAG配置文件(有向无环图)：<code>perception/production/dag</code></p><p>DAG配置文件是Cyber RT 调度程序<code>mainboard</code> 动态加载<code>perception</code> 模块的最终配置文件。</p><p>加载命令：<code>/apollo/cyber/mainboard -d /apollo/modules/perception/production/dag/dag_streamimg_perception.dag</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module_config &#123;</span><br><span class="line">  #共享库文件路径</span><br><span class="line">  module_library : <span class="string">"/apollo/bazel-bin/modules/perception/onboard/component/libperception_component_lidar.so"</span></span><br><span class="line"></span><br><span class="line"> components &#123;</span><br><span class="line">    #组件名称，mainboard动态加载</span><br><span class="line">    class_name : <span class="string">"SegmentationComponent"</span></span><br><span class="line">    <span class="built_in">config</span> &#123;</span><br><span class="line">      #模块名</span><br><span class="line">      name: <span class="string">"Velodyne128Segmentation"</span></span><br><span class="line">      #绝对路径，配置文件路径</span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/lidar/velodyne128_segmentation_conf.pb.txt"</span></span><br><span class="line"></span><br><span class="line">      flag_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/perception_common.flag"</span></span><br><span class="line">      #组件proc()函数中使用的消息接收器</span><br><span class="line">      readers &#123;</span><br><span class="line">          channel: <span class="string">"/apollo/sensor/lidar128/compensator/PointCloud2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Launch 启动文件:<code>modules/perception/prodution/launch/perception_all.launch</code></p><p>Launch配置文件使用<code>Cyber RT</code> 提供的python工具程序<code>cyber_launch</code> 加载<code>Perception</code> 模块所需的配置文件，启动命令如下</p><p><code>cyber_launch start /apollo/launch/perception_all.launch</code></p><p>典型片段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;cyber&gt;  </span><br><span class="line">&lt;<span class="keyword">module</span>&gt;</span><br><span class="line">        &lt;name&gt;perception&lt;/name&gt;</span><br><span class="line">        &lt;dag_conf&gt;/apollo/modules/perception/production/dag</span><br><span class="line">      /dag_streaming_perception.dag&lt;/dag_conf&gt;</span><br><span class="line">        &lt;!-- <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">set</span>, use <span class="keyword">default</span> <span class="built_in">process</span> --&gt;</span><br><span class="line">        &lt;process_name&gt;perception&lt;/process_name&gt;</span><br><span class="line">        &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/module&gt;</span><br><span class="line">&lt;cyber&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收消息：</p><p>基于<code>Cyber RT</code>接收消息分为两种：</p><ul><li><p>虚函数：Proc()中处理指定的消息类型，周期性触发（接收），但最多只能接收4种消息类型（由cyber::Component的模板参数最多只有4个决定），一般用于模块主要输入信息的接收。</p></li><li><p>直接创建消息接收器，一般用于接收非周期性消息或模块的次要输入消息，例如：</p><p><code>modules/perception/onboard/component/fusion_camera_detection_component.cc</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> camera_reader = node_-&gt;CreateReader(channel_name, camera_callback);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>发布消息：</p><p>基于<code>Cyber RT</code> 发布消息</p><p><code>fusion_camera_detection_component.cc/FusionCameraDetectionComponent::Init()</code>定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sensorframe_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(prefused_channel_name_);</span><br></pre></td></tr></table></figure><p><code>FusionCameraDetectionComponent::OnReceiveImage</code>中发布消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> send_sensorframe_ret = sensorframe_writer_-&gt;Write(prefused_message);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="具体算法分析">具体算法分析：</h2><h2 id="消息发送接收类型">消息发送接收类型：</h2><p><code>FusionCameraDetectionComponent::Init(){}</code> 中以模板类的方式开头定义了四个writer:</p><p>其内容是<code>InitConfig()</code> 时导入的proto消息配置文件<code>&quot;fusion_camera_detection_component.proto&quot;</code> 信息 :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> output_obstacles_channel_name = <span class="number">10</span> [<span class="keyword">default</span> = <span class="string">"/perception/obstacles"</span>];</span><br><span class="line"><span class="built_in">string</span> prefused_channel_name = <span class="number">12</span> [<span class="keyword">default</span> = <span class="string">"/perception/inner/PrefusedObjects"</span>];</span><br><span class="line"><span class="built_in">string</span> camera_perception_viz_message_channel_name = <span class="number">11</span> [<span class="keyword">default</span> = <span class="string">"/perception/inner/camera_viz_msg"</span>]; <span class="comment">//3d?</span></span><br><span class="line"><span class="built_in">string</span> camera_debug_channel_name = <span class="number">20</span> [<span class="keyword">default</span> = <span class="string">"/perception/camera_debug"</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;PerceptionObstacles&gt;(output_obstacles_channel_name_); </span><br><span class="line">sensorframe_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(prefused_channel_name_);</span><br><span class="line">camera_viz_writer_ = node_-&gt;CreateWriter&lt;CameraPerceptionVizMessage&gt;(</span><br><span class="line">    camera_perception_viz_message_channel_name_);</span><br><span class="line">camera_debug_writer_ =</span><br><span class="line">    node_-&gt;CreateWriter&lt;apollo::perception::camera::CameraDebug&gt;(</span><br><span class="line">        camera_debug_channel_name_);</span><br></pre></td></tr></table></figure><h3 id="文件参数初始化的调用关系">文件参数初始化的调用关系：</h3><p><code>*.proto</code> 中包含的相关固定（默认）参数通过编译为对应<code>package</code> 命名空间下的类，然后<code>*.pt</code> 的文件通过<code>GetAbsolutePath()</code> 函数读取，最后通过<code>cyber::common::GetProtoFromFile()</code> 函数将<code>*.pt</code> 中的参数部分修改<code>*.proto</code> 中的默认参数，即得最终的配置参数，然后这些参数复制给对应的类成员属性。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app::PerceptionParam perception_param_; <span class="comment">//对应proto文件生成的类</span></span><br><span class="line">config_file = GetAbsolutePath(work_root, config_file); <span class="comment">//通过路径获取pt文件的路径(obstacle.pt)</span></span><br><span class="line">cyber::common::GetProtoFromFile(config_file, &amp;perception_param_);<span class="comment">//部分修改perception_param中的参数</span></span><br><span class="line">detector_init_options.gpu_id = perception_param_.gpu_id();<span class="comment">//将proto文件参数赋给具体类实例中的成员属性</span></span><br></pre></td></tr></table></figure><p>模型参数以及相关配置文件的修改位于：</p><p><code>modules/perception/production/data/perception/..</code>中，包含了各个传感器及其对应的功能模块的配置文件</p><hr><h2 id="文件调用结构">文件调用结构</h2><p><img src="/2020/02/04/perception/fusion_init.png"></p><hr><h2 id="目前待解决的问题">目前待解决的问题：</h2><p><code>Cyber RT</code> 的调度与通信机制，例如Component::Proc()是如何被周期性調用的</p><p>camera app中如何被fusion中调用的，消息的传送方向。</p><h3 id="proto文件解析与c开发">1. Proto文件解析与C++开发</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> apollo.perception.camera.yolo; <span class="comment">//对应命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">YoloParam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> ModelParam model_param = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> NetworkParam net_param = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">optional</span> NMSParam nms_param = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “yolo.pb.h” <span class="comment">//此文件编译后产生</span></span></span><br><span class="line">yolo::YoloParam yolo_param_;<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><blockquote><p>https://www.jianshu.com/p/d2bed3614259</p></blockquote><p>.proto 文件以 package 声明开头，这有助于防止不同项目之间的命名冲突。在 C++ 中，生成的类将放在与包名匹配的 namespace （命名空间）中。</p><h3 id="tensorrt-模型量化方法">2. TensorRT 模型量化方法</h3><h3 id="caffe-blobternsorrtcaffe-特征提取的c接口">caffe blob、TernsorRT、caffe 特征提取的C++接口:</h3><h3 id="网络推断模型-inference_factory.cc的建立和区别与上面问题存在关联">3. 网络推断模型 （inference_factory.cc）的建立和区别(与上面问题存在关联)</h3><blockquote><p>CaffeNet</p><p>RTNet</p><p>RTNetInt8</p><p>PaddleNet</p></blockquote><h3 id="视频目标跟踪和目标检测的统一框架">4. 视频目标跟踪和目标检测的统一框架：</h3><blockquote><p>Detect to Track and Track to Detect</p></blockquote><h4 id="roi-pooling-track">Roi pooling track ?</h4><h3 id="目标跟踪-匈牙利算法hungarian-algorithm与km算法kuhn-munkres-algorithm">5. 目标跟踪 匈牙利算法（Hungarian Algorithm）与KM算法（Kuhn-Munkres Algorithm）</h3><blockquote><p>https://blog.csdn.net/NIeson2012/article/details/94472313</p><p>https://blog.csdn.net/zziahgf/article/details/85344859</p><p>https://blog.csdn.net/xiao__run/article/details/84374959</p><p>Deep sort论文需要看一下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无人驾驶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
