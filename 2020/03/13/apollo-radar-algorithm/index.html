<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/bitbug_favicon32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/bitbug_favicon16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://zhxjia.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: 'JFFLKNTBOH',
      apiKey: '12c519466e9111e97c1a9fa4f29a7156',
      indexName: 'zhxjia',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="apollo中radar的目标检测与跟踪算法">
<meta property="og:type" content="article">
<meta property="og:title" content="Apollo中radar的相关算法">
<meta property="og:url" content="https://zhxjia.github.io/2020/03/13/apollo-radar-algorithm/index.html">
<meta property="og:site_name" content="ZhxJia&#39;s Blog">
<meta property="og:description" content="apollo中radar的目标检测与跟踪算法">
<meta property="og:image" content="https://zhxjia.github.io/2020/03/13/apollo-radar-algorithm/1.jpg">
<meta property="article:published_time" content="2020-03-13T13:33:42.827Z">
<meta property="article:modified_time" content="2020-03-16T08:47:45.523Z">
<meta property="article:author" content="ZhxJia">
<meta property="article:tag" content="perception">
<meta property="article:tag" content="radar">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhxjia.github.io/2020/03/13/apollo-radar-algorithm/1.jpg">

<link rel="canonical" href="https://zhxjia.github.io/2020/03/13/apollo-radar-algorithm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Apollo中radar的相关算法 | ZhxJia's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhxJia's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">半路出家</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://zhxjia.github.io/2020/03/13/apollo-radar-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/jd.png">
      <meta itemprop="name" content="ZhxJia">
      <meta itemprop="description" content="行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhxJia's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Apollo中radar的相关算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-13 21:33:42" itemprop="dateCreated datePublished" datetime="2020-03-13T21:33:42+08:00">2020-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-16 16:47:45" itemprop="dateModified" datetime="2020-03-16T16:47:45+08:00">2020-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/apollo/" itemprop="url" rel="index">
                    <span itemprop="name">apollo</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/apollo/perception/" itemprop="url" rel="index">
                    <span itemprop="name">perception</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/03/13/apollo-radar-algorithm/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/03/13/apollo-radar-algorithm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>apollo中radar的目标检测与跟踪算法</p>
<a id="more"></a>
<p>Apollo中<code>radar_detection_component</code>的算法处理入口为<code>Proc</code> ,根据该组件对应<code>dag</code>文件中的<code>reader</code>,在初始化组件时，<code>class RadarDetectionComponent : public cyber::Component&lt;ContiRadar&gt;</code>，该组件继承了含有一个message消息的<code>Component</code>基类，因此在该类初始化时，会创建接收<code>ContiRadar</code>消息类型的<code>reader</code>，回调函数为<code>Proc</code>。</p>
<p>Proc的输入信息(input_message)包括了：</p>
<ul>
<li><code>apollo::drivers::ContiRadar</code></li>
<li><code>apollo::localization::LocalizationEstimate</code></li>
</ul>
<p>输出信息(out_message)包括了：</p>
<ul>
<li><code>SensorFrameMessage</code></li>
</ul>
<h2 id="预处理">预处理</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: correct radar raw obstacles.</span></span><br><span class="line"><span class="comment">// @param [in]: raw obstacles from radar driver.</span></span><br><span class="line"><span class="comment">// @param [in]: options.</span></span><br><span class="line"><span class="comment">// @param [out]: corrected radar obstacles</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Preprocess</span><span class="params">(<span class="keyword">const</span> drivers::ContiRadar&amp; raw_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> PreprocessorOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                        drivers::ContiRadar* corrected_obstacles)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>SkipObjects</strong>(raw_obstacles,corrected_obstacles)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 根据时间戳过滤检测物体</span></span><br><span class="line"><span class="comment">// @param [in]: raw obstacles from radar driver.</span></span><br><span class="line"><span class="comment">// @param [out]: corrected radar obstacles</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ContiArsPreprocessor::SkipObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> drivers::ContiRadar&amp; raw_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">    drivers::ContiRadar* corrected_obstacles)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>判断每个原检测物体的时间戳，若该检测物体的时间戳在该数据帧时间戳的<code>(-1e6,0.074)</code>之间则进行处理。</p></li>
<li><p><strong>ExpandIds</strong>(corrected_obstacles)</p></li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 创建全局id</span></span><br><span class="line"><span class="comment">// @param [in]: corrected radar obstacles</span></span><br><span class="line"><span class="comment">// @param [out]: corrected radar obstacles</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ContiArsPreprocessor::ExpandIds</span><span class="params">(drivers::ContiRadar* corrected_obstacles)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>为corrected obstacles分配id:若目标的<code>meas_state</code>属性为<code>CONTI_NEW</code>即新创建的目标或者corrected obstacles的id未出现过，则为其添加一个，最终当所有的object_id都出现过<code>local2global_[ORIGIN_CONTI_MAX_ID_NUM]</code>将不再变化，同时每个object_id都对应一个固定的id。</p>
<ul>
<li><p><strong>CorrectTime</strong>(corrected_obstacles)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 校正时间戳延迟</span></span><br><span class="line"><span class="comment">// @param [in]: corrected radar obstacles</span></span><br><span class="line"><span class="comment">// @param [out]: corrected radar obstacles</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ContiArsPreprocessor::CorrectTime</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    drivers::ContiRadar* corrected_obstacles)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>通过初始化配置时的参数<code>delay_time_</code>(0.07)校正时间戳。</p></li>
</ul>
<h2 id="radar-perception">Radar Perception</h2>
<h3 id="initoptions">InitOptions</h3>
<p>初始化检测器配置:<code>DetectorOptions detector_options</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetectorOptions</span> &#123;</span></span><br><span class="line">  Eigen::Matrix4d* radar2world_pose = <span class="literal">nullptr</span>;	  <span class="comment">//到世界坐标系下的转换</span></span><br><span class="line">  Eigen::Matrix4d* radar2novatel_trans = <span class="literal">nullptr</span>; <span class="comment">//到定位模块的转换</span></span><br><span class="line">  Eigen::Vector3f car_linear_speed = Eigen::Vector3f::Zero(); <span class="comment">//车辆线速度</span></span><br><span class="line">  Eigen::Vector3f car_angular_speed = Eigen::Vector3f::Zero(); <span class="comment">//车辆角速度</span></span><br><span class="line">  base::HdmapStructPtr roi = <span class="literal">nullptr</span>; <span class="comment">//高清地图提供的roi</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过<code>TransoforWrapper</code>类根据当前的时间戳分别查询实时的转换矩阵<code>radar2worlld_pose</code> <code>radar2novatel_trans</code> 同时通过<code>GetCarLocalizatonSpeed</code>通过监听节点<code>localization_subscriber_</code>获取实时的车辆的线速度和角速度。</p>
<p>初始化<code>RoiFiler</code>的配置：<code>RoiFilterOptions roi_filter_options</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RoiFilterOptions</span> &#123;</span></span><br><span class="line">  base::HdmapStructPtr roi = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化一个指向<code>HdmapStruct</code>的指针:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">16</span>)</span> HdmapStruct </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RoadBoundary&gt; road_boundary; <span class="comment">//道路左右边界</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PointCloud&lt;PointD&gt;&gt; road_polygons; <span class="comment">//道路的区域</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PointCloud&lt;PointD&gt;&gt; hole_polygons; <span class="comment">//</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PointCloud&lt;PointD&gt;&gt; junction_polygons; <span class="comment">//道路交叉区域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据之前初始化时导入的<code>hd_map</code>文件，获取Roi区域:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 获取Roi区域(道路边界) 包含road_boundary,road_polygons,hole_polygons,junction_polygons</span></span><br><span class="line"><span class="comment">// @param [in]: pointd(radar相对于世界坐标系原点的位置)</span></span><br><span class="line"><span class="comment">// @param [in]: distance(radar前向探测距离 )</span></span><br><span class="line"><span class="comment">// @param [out]: hdmap_struct_ptr(对应于roi的hd_map数据结构)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HDMapInput::GetRoiHDMapStruct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> base::PointD&amp; pointd, <span class="keyword">const</span> <span class="keyword">double</span> distance,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::HdmapStruct&gt; hdmap_struct_ptr)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// @brief: 获取道路边界和交叉口</span></span><br><span class="line">	 <span class="comment">// @param [in]: point(radar相对于世界坐标系原点的位置)</span></span><br><span class="line">	 <span class="comment">// @param [in]: distance(radar前向探测距离 )</span></span><br><span class="line">	 <span class="comment">// @param [out]: road_boundary_vec </span></span><br><span class="line">     <span class="comment">// @param [out]: junctions_vec </span></span><br><span class="line">     <span class="keyword">if</span> (hdmap_-&gt;GetRoadBoundaries(<span class="built_in">point</span>, distance, &amp;road_boundary_vec,</span><br><span class="line">                                &amp;junctions_vec) != <span class="number">0</span>)&#123; .. &#125;</span><br><span class="line">     ...</span><br><span class="line">      <span class="comment">// Merge boundary and junction</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RoadBoundary&gt; road_boundaries;</span><br><span class="line">      MergeBoundaryJunction(road_boundary_vec, junctions_vec, &amp;road_boundaries,</span><br><span class="line">                            &amp;(hdmap_struct_ptr-&gt;road_polygons),</span><br><span class="line">                            &amp;(hdmap_struct_ptr-&gt;junction_polygons));</span><br><span class="line">      <span class="comment">// Filter road boundary by junction</span></span><br><span class="line">      GetRoadBoundaryFilteredByJunctions(road_boundaries,</span><br><span class="line">                                         hdmap_struct_ptr-&gt;junction_polygons,</span><br><span class="line">                                         &amp;(hdmap_struct_ptr-&gt;road_boundary));</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>到此，将detector的配置(主要是坐标的变换矩阵)和roi_filter的配置(主要是道路边界的获取)初始化完成，接下来是感知算法的实现。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 检测和跟踪算法的实现</span></span><br><span class="line"><span class="comment">// @param [in]: corrected_obstacles(经过preprocess之后的radar检测物体)</span></span><br><span class="line"><span class="comment">// @param [in]: options(detector,roifilter,tracker,sensor_name)等的初始化配置</span></span><br><span class="line"><span class="comment">// @param [out]: objects(最终得到的检测物体信息)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RadarObstaclePerception::Perceive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> drivers::ContiRadar&amp; corrected_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> RadarPerceptionOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt;* objects)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="detctor">Detctor:</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: 在预处理后的corrected_obstacle上检测物体</span></span><br><span class="line"><span class="comment">// @param [in]: corrected_obstacles(经过preprocess之后的radar检测物体)</span></span><br><span class="line"><span class="comment">// @param [in]: options(detector的初始化配置)</span></span><br><span class="line"><span class="comment">// @param [out]: radar_frame(带有所有障碍物信息的frame)</span></span><br><span class="line"><span class="comment">// @note: frame数据类型根据传感器类型和时间戳封装了object数据类型，而SensorFrameMessage又</span></span><br><span class="line"><span class="comment">// 进一步封装了frame数据类型用于各传感器相互之间的信息融合消息类型</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Detect</span><span class="params">(<span class="keyword">const</span> drivers::ContiRadar&amp; corrected_obstacles,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> DetectorOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">              base::FramePtr radar_frame)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @brief: 将检测物体添加到radar_frame中</span></span><br><span class="line">	<span class="comment">// @param [in]: corrected_obstacles(经过preprocess之后的radar检测物体)</span></span><br><span class="line">	<span class="comment">// @param [in]: options(detector的初始化配置)</span></span><br><span class="line">	<span class="comment">// @param [out]: radar_frame(带有所有障碍物信息的frame)	</span></span><br><span class="line">    RawObs2Frame(corrected_obstacles, options, radar_frame);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>RawObs2Frame</code>的具体算法中： 首先根据车辆角速度(novatel坐标系下)计算得到旋转矩阵<code>rotation_novatel</code>,然后再根据<code>novatel</code>和<code>radar</code>之间的旋转关系计算得到<code>radar</code>坐标系下的角速度矩阵,由于角速度是局部坐标系<code>东-北-天</code>下的，因此其角速度矩阵也为相对于该坐标系下。然后，对于<code>corrected_obstacles</code>中的每一个检测物体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                x axis  ^</span></span><br><span class="line"><span class="comment">//                        | longitude_dist</span></span><br><span class="line"><span class="comment">//                        |</span></span><br><span class="line"><span class="comment">//                        |</span></span><br><span class="line"><span class="comment">//                        |</span></span><br><span class="line"><span class="comment">//          lateral_dist  |</span></span><br><span class="line"><span class="comment">//          y axis        |</span></span><br><span class="line"><span class="comment">//        &lt;----------------</span></span><br><span class="line"><span class="comment">//        ooooooooooooo   //radar front surface</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>将目标在radar下的(x,y)坐标转换到统一的世界坐标系(UMT)下存储到object-&gt;center中 <code>radar_object-&gt;center = radar2world * local_loc</code> <code>radar_object-&gt;anchor_point = radar_object-&gt;center</code></p></li>
<li><p>将radar坐标系下的横轴和纵轴速度转换到世界(相对于东-北-天坐标系)下的速度:</p>
<p>不同坐标系下角速度或线速度的相互转换需要乘上对应的旋转矩阵，因此由于<code>radar</code>直接得到的是目标相对<code>radar</code>的相对速度，需要将其检测目标的速度转换到(东-北-天)坐标系下,首先得到<code>radar</code>在(东-北-天)坐标系下由于车辆角速度引起的旋转：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rotation_novatel &lt;&lt; <span class="number">0</span>, -angular_speed(<span class="number">2</span>), angular_speed(<span class="number">1</span>), angular_speed(<span class="number">2</span>),</span><br><span class="line">      <span class="number">0</span>, -angular_speed(<span class="number">0</span>), -angular_speed(<span class="number">1</span>), angular_speed(<span class="number">0</span>), <span class="number">0</span>; <span class="comment">//角速度矢量的反对称阵</span></span><br><span class="line">rotation_radar = radar2novatel.topLeftCorner(<span class="number">3</span>, <span class="number">3</span>).inverse() *</span><br><span class="line">                                   rotation_novatel *</span><br><span class="line">                                   radar2novatel.topLeftCorner(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">angular_trans_speed = rotation_radar * local_loc.topLeftCorner(<span class="number">3</span>, <span class="number">1</span>);<span class="comment">//</span></span><br><span class="line">world_vel = radar2world_rotate * (local_vel + angular_trans_speed);</span><br><span class="line">vel_temp =  world_vel + options.car_linear_speed.cast&lt;<span class="keyword">double</span>&gt;();</span><br></pre></td></tr></table></figure>
<p><code>radar_object-&gt;velocity = vel_temp</code> <strong>注意线速度等于角速度叉乘失径，此处叉乘通过矩阵相乘实现，即为:</strong> <span class="math display">\[
\vec{a}\times\vec{b}=
\begin{bmatrix}
0&amp;-a_3&amp;a_2\\
a_3 &amp; 0 &amp;-a_1\\
-a_2 &amp; a_1 &amp; 0
\end{bmatrix}\vec{b}\triangleq a^{\land}\vec{b}
\]</span></p></li>
<li><p>将<code>corrected_obstacles</code>中的横纵向距离和速度的标准差(<code>dist_rms/vel_res</code>)作为位置和速度不确定度： <code>radar_object-&gt;center_uncertainty = radar2world_rotate * dist_rms * dist_rms.transpose() * radar2world_rotate.transpose()</code> <code>radar_object-&gt;velocity_uncertainty =</code>radar2world_rotate * vel_rms * vel_rms.transpose() *<code>radar2world_rotate.transpose()</code></p></li>
<li><p>将原检测信息中目标的旋转角度(单位为度，逆时针旋转为正方向)转为弧度，并转换为方向向量,然后将此方向向量转换到世界坐标系下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> local_obj_theta = radar_obs.oritation_angle() / <span class="number">180.0</span> * PI;</span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">direction</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">cos</span>(local_obj_theta)),</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sin</span>(local_obj_theta)), <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">direction = radar2world_rotate.cast&lt;<span class="keyword">float</span>&gt;() * direction;</span><br></pre></td></tr></table></figure>
<p><code>radar_object-&gt;direction = direction</code> <code>radar_object-&gt;theta = std::atan2(direction(1),direction(0))</code></p>
<p>角度的不确定度由检测信息中的<code>oritation_angle_rms</code>标准差确定，也是将角度改为弧度： <code>radar_object-&gt;theta_variance = (radar_obs.oritation_angle_rms() / 180.0 * PI)</code></p></li>
<li><p>置信度设置为原检测信息中的<code>probexist</code>,即目标存在的概率： <code>radar_object-&gt;confidence = radar_obs.probexist()</code></p></li>
<li><p>根据原检测信息中的<code>dynprop</code>属性进行确定目标的运动状态(相对于东-北-天坐标系(或者说相对于地面))是运动，静止，还是未知的,若是静止的，将速度置零。</p></li>
<li><p>根据原检测信息中的<code>obstacle_class</code>确定目标的类别。</p></li>
<li><p>根据原检测信息中的<code>length</code>,<code>width</code>确定目标的长度和宽度，因为<code>radar</code>无法检测高度信息，将此值设置为车辆模板 2m ,同时对于物体类别未知的点<code>CONTI_POINT</code>，将size设置为1.0m 。</p></li>
<li><p>最后根据相对<code>radar</code>的物体的x,y坐标，计算距离<span class="math inline">\(local\_range\sqrt{(x^2+y^2)}\)</span> ，即角度<span class="math inline">\(local\_angle = arctan(y/x)\)</span>作为radar检测目标的补充参数<code>radar_supplement</code>。</p></li>
</ul>
<h3 id="roifilterhdmapradarroifilter">RoiFilter(HdmapRadarRoiFilter)</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// @brief: fliter the objects outside the ROI 过滤出roi区域之外的物体</span></span><br><span class="line"><span class="comment">// @param [in]: options.(hdmap_input信息)</span></span><br><span class="line"><span class="comment">// @param [in / out]: origin total objects / the objects in the ROI.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RoiFilter</span><span class="params">(<span class="keyword">const</span> RoiFilterOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                 base::FramePtr radar_frame)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
<p>若<code>roimap</code>中存在有效信息，该函数根据目前检测物体的中心点坐标判断是否位于roi 的<code>road</code> 或者<code>juction</code>的polygons中,若目标中心点位于ROI的polygons中，则将该物体添加到<code>valid_objects</code>中。</p>
<h3 id="track">Track()</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief: </span></span><br><span class="line"><span class="comment">// @param [in]: options.</span></span><br><span class="line"><span class="comment">// @param [in]: detected_frame(the objects in the ROI)</span></span><br><span class="line"><span class="comment">// @param [in / out]: tracked_frame (被跟踪物体的信息)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Track</span><span class="params">(<span class="keyword">const</span> base::Frame &amp;detected_frame, <span class="keyword">const</span> TrackerOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">             base::FramePtr tracked_frame)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>TrackObjects(detected_frame)</strong> 获取跟踪目标tracks</p>
<p>首先跟踪目标的基本信息单位由封装<code>object</code>的<code>RadarTrack</code>定义，而该单元的删除和创建由封装了<code>RadarTrack</code>的<code>RadarTrackManager</code>管理(获取,改变,添加,删除track)，算法的具体由<code>ContiArsTracker</code>实现。</p>
<ol type="1">
<li><p><strong>获取当前跟踪的物体</strong> GetTracks()</p></li>
<li><p><strong>匹配</strong> matcher_-&gt;Match 由hm_matcher进行检测物体与跟踪物体的关联。</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @brief match radar objects to tracks</span></span><br><span class="line"><span class="comment">// @params[IN] radar_tracks: global tracks</span></span><br><span class="line"><span class="comment">// @params[IN] radar_frame: current radar frame</span></span><br><span class="line"><span class="comment">// @params[IN] options: matcher options for future use</span></span><br><span class="line"><span class="comment">// @params[OUT] assignments: matched pair of tracks and measurements</span></span><br><span class="line"><span class="comment">// @params[OUT] unassigned_tracks: unmatched tracks</span></span><br><span class="line"><span class="comment">// @params[OUT] unassigned_objects: unmatched objects</span></span><br><span class="line"><span class="comment">// @return nothing</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RadarTrackPtr&gt; &amp;radar_tracks,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> base::Frame &amp;radar_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> TrackObjectMatcherOptions &amp;options,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrackObjectPair&gt; *assignments,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; *unassigned_tracks,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; *unassigned_objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法是首先由于radar原始输出信息中包含了object_id(注意原始radar信息同一id不一定是同一物体)，但是作为一项判断依据，即进行<code>IDMatch</code>的匹配，同时还要求object和track的距离小于一定阈值,其中<span class="math inline">\(c_2\)</span> <span class="math inline">\(c_1\)</span>分别表示object和track的中心点位置,<span class="math inline">\(f(c)=\sqrt{x^2+y^2+z^2}\)</span> <span class="math display">\[
0.5*f\{(c_2-(c_1+v_1\times\triangle t))\}+0.5*f\{(c_1-(c_2+v_2\times\triangle t))\}&lt;2.5m
\]</span> 满足上述两个条件将对应索引的object关联到track中保存到<code>assignments</code>，并将未匹配的object或track的索引保存到 <code>unassigned_objects</code>和<code>unassigned_tracks</code>中。</p>
<p>然后将剩下的未分配的object和track建立<code>association_matrix</code>通过<code>gated_hungarian_matcher</code>进行进一步匹配，并将索引保存到<code>assignments</code>中，将此时未分配的<code>track</code>和<code>object</code>索引分别保存到<code>unassigned_tracks</code>和 <code>assigned_objects</code>中。</p>
<ol start="3" type="1">
<li><p><strong>更新已匹配的tracks</strong> <code>UpdateAssignedTracks</code> 将已经有了新的匹配的tracks信息更新到当前新检测的object,更新信息包括目标的中心位置(x,y)速度(<span class="math inline">\(v_x,v_y\)</span>),时间戳，如果采用<code>Adaptive_Kalman_filter</code>,则先经过卡尔曼滤波器的校正然后再更新信息,最后将<code>tracked_times</code>加1,以及跟踪的生命周期<code>tracking_time_+=time_diff</code></p></li>
<li><p><strong>更新未匹配的tracks</strong> <code>UpdateUnassignedTracks</code> 对于所有未匹配<code>object</code>的<code>track</code>，判断其与当前帧的时间戳之差是否大于0.06s(即超过0.06s未有检测匹配),若是则将其<code>SetDead</code>,当然，若此未分配的<code>track</code>是一个空壳(没有跟踪目标信息),也将其设置为<code>dead</code>。</p></li>
<li><p><strong>删除跟丢的tracks</strong> <code>DeleteLostTracks</code> 判断当前所有的<code>tracks</code>，若其<code>is_dead</code>则将其从<code>tracks</code>列表中删除。</p></li>
<li><p><strong>创建新的track</strong> <code>CreateNewTracks</code> 对于剩下的未分配的<code>object</code>,将其创建新的<code>track</code>加入到<code>tracks</code>中。</p></li>
</ol></li>
<li><p><strong>CollectTrackedFrame(tracked_frame)</strong> 将<code>RadarTrack</code>数据类型中的对应数据转换到<code>Frame</code>数据结构中</p>
<ol type="1">
<li><p><strong>跟踪确认</strong> <code>ConfirmTrack</code> 对于<code>tracked_times&gt;=3</code>的track,即有超过三次匹配到<code>object</code>，则认为是有一定可靠度的进行下一步处理</p></li>
<li><p><strong>添加到tracked_frame</strong> 将<code>RadarTrack</code>中的对应信息复制到<code>tracked_frame</code>帧数据结构中，以进行传输。</p></li>
</ol></li>
</ul>
<h2 id="radar-algorithm-supplement">Radar algorithm supplement</h2>
<h3 id="adaptive-kalman-filter">1.Adaptive Kalman Filter</h3>
<p><code>radar</code>或<code>camera</code>在进行目标检测时，由于外界环境的突然变化(光照，路面剧烈波动，上下坡等)导致传感器的检测精度受到影响，由于传统的KalmanFilter的更新依赖于先验的量测噪声协方差阵<span class="math inline">\(R\)</span>和过程噪声协方差阵<span class="math inline">\(Q\)</span>,那么此时传感器检测受到影响，而<code>Q,R</code>却并没有改变，即此时系统模型不准确，那么KalmanFilter的结果必然是存在问题的。 对于自适应卡尔曼滤波，</p>
状态向量: <span class="math display">\[
X=
\begin{bmatrix}
c_x\\
c_y\\
v_x\\
v_y
\end{bmatrix}
\]</span> 状态转移矩阵: $$ F=
<span class="math display">\[\begin{bmatrix}
1 &amp; 0 &amp; \triangle t &amp; 0\\
0 &amp; 1 &amp; 0 &amp; \triangle t \\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1

\end{bmatrix}\]</span>
<span class="math display">\[
过程噪声协方差矩阵：
\]</span> Q=
<span class="math display">\[\begin{bmatrix}
0.074 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0.074 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0.074 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0.074
\end{bmatrix}\]</span>
<p>$$ 量测噪声协方差矩阵：根据radar返回的横纵向速度和位置的标准差rms计算得到世界坐标系下的协方差。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dist_rms(<span class="number">0</span>, <span class="number">0</span>) = radar_obs.longitude_dist_rms(); <span class="comment">//纵向距离的标准差</span></span><br><span class="line">    dist_rms(<span class="number">1</span>, <span class="number">1</span>) = radar_obs.lateral_dist_rms(); <span class="comment">//横向距离标准差</span></span><br><span class="line">    vel_rms(<span class="number">0</span>, <span class="number">0</span>) = radar_obs.longitude_vel_rms(); <span class="comment">//纵向速度的标准差</span></span><br><span class="line">    vel_rms(<span class="number">1</span>, <span class="number">1</span>) = radar_obs.lateral_vel_rms(); <span class="comment">//横向速度标准差</span></span><br><span class="line">    radar_object-&gt;center_uncertainty =</span><br><span class="line">        (radar2world_rotate * dist_rms * dist_rms.transpose() *</span><br><span class="line">         <span class="keyword">radar2world_rotate_t</span>) <span class="comment">//世界坐标系下的协方差(R*rms)(R*rms)^T</span></span><br><span class="line">            .cast&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line"></span><br><span class="line">radar_object-&gt;velocity_uncertainty =</span><br><span class="line">    (radar2world_rotate * vel_rms * vel_rms.transpose() *</span><br><span class="line">     <span class="keyword">radar2world_rotate_t</span>)</span><br><span class="line">    .cast&lt;<span class="keyword">float</span>&gt;();</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
R=
\begin{bmatrix}
c_{x\ uncertainty} &amp; 0 &amp; 0 &amp; 0\\
0 &amp; c_{y\ uncertainty} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; v_{x\ uncertainty} &amp; 0\\
0 &amp; 0 &amp; 0 &amp; v_{y\ uncertainty}
\end{bmatrix}
\]</span></p>
<p><strong>预测部分</strong>: <span class="math display">\[
x&#39;=Fx\\
P&#39;=FPF^T+Q
\]</span> <strong>更新部分</strong>: 首先根据该帧检测物体的位置速度的不确定性协方差阵更新<code>R</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r_matrix_.topLeftCorner(<span class="number">2</span>, <span class="number">2</span>) =</span><br><span class="line">    new_object.center_uncertainty.topLeftCorner(<span class="number">2</span>, <span class="number">2</span>).cast&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">r_matrix_.block&lt;<span class="number">2</span>, <span class="number">2</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) =</span><br><span class="line">    new_object.velocity_uncertainty.topLeftCorner(<span class="number">2</span>, <span class="number">2</span>).cast&lt;<span class="keyword">double</span>&gt;();</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
y = z-Hx&#39;\\
S = HP&#39;H^T+R\\
K=P&#39;H^TS^{-1}\\
x=x&#39;+Ky\\
P=(I-KH)P&#39;(I-KH)^T+KRK^T
\]</span></p>
<p>其中<span class="math inline">\(P=(I-KH)P&#39;(I-KH)^T+KRK^T\)</span>与<span class="math inline">\(P=(I-KH)P&#39;\)</span>等价，但是能够保证正定性。</p>
<p><img src="/2020/03/13/apollo-radar-algorithm/1.jpg" style="zoom:50%;"></p>
<p>可以看出毫米波雷达的卡尔曼滤波相较于传统的滤波器，<strong>在于其<code>R</code>阵会根据<code>radar</code>提供的标准差实时更新</strong>。</p>
<h3 id="gatedhungarianmatcher">2. GatedHungarianMatcher</h3>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/perception/" rel="tag"># perception</a>
              <a href="/tags/radar/" rel="tag"># radar</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/11/apollo-radar-init/" rel="prev" title="Apollo中毫米波雷达的初始化配置">
      <i class="fa fa-chevron-left"></i> Apollo中毫米波雷达的初始化配置
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/04/apollo-cyber_bash/" rel="next" title="Apollo中Cyber RT脚本启动流程">
      Apollo中Cyber RT脚本启动流程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#预处理"><span class="nav-number">1.</span> <span class="nav-text">预处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#radar-perception"><span class="nav-number">2.</span> <span class="nav-text">Radar Perception</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#initoptions"><span class="nav-number">2.1.</span> <span class="nav-text">InitOptions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#detctor"><span class="nav-number">2.2.</span> <span class="nav-text">Detctor:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#roifilterhdmapradarroifilter"><span class="nav-number">2.3.</span> <span class="nav-text">RoiFilter(HdmapRadarRoiFilter)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#track"><span class="nav-number">2.4.</span> <span class="nav-text">Track()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#radar-algorithm-supplement"><span class="nav-number">3.</span> <span class="nav-text">Radar algorithm supplement</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#adaptive-kalman-filter"><span class="nav-number">3.1.</span> <span class="nav-text">1.Adaptive Kalman Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gatedhungarianmatcher"><span class="nav-number">3.2.</span> <span class="nav-text">2. GatedHungarianMatcher</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhxJia"
      src="/images/jd.png">
  <p class="site-author-name" itemprop="name">ZhxJia</p>
  <div class="site-description" itemprop="description">行则将至</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ZhxJia" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZhxJia" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jachin9707@gmail.com" title="E-Mail → mailto:jachin9707@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

      
        <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
        <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
        <div class="widget-wrap">
          <h3 class="widget-title">Tag Cloud</h3>
          <div id="myCanvasContainer" class="widget tagcloud">
              <canvas width="250" height="250" id="resCanvas" style="width=100%">
                 <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apollo/" rel="tag">Apollo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MOT/" rel="tag">MOT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apollo/" rel="tag">apollo</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/build/" rel="tag">build</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/caffe/" rel="tag">caffe</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/detector/" rel="tag">detector</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lidar%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" rel="tag">lidar目标检测</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lidar%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/" rel="tag">lidar目标跟踪</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/perception/" rel="tag">perception</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/radar/" rel="tag">radar</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slam/" rel="tag">slam</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/track/" rel="tag">track</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/" rel="tag">传感器标定</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88/" rel="tag">传感器融合</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E8%A7%86%E5%9B%BE%E8%A1%A1%E9%87%8F/" rel="tag">单视图衡量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/" rel="tag">坐标转换</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88/" rel="tag">多传感器融合</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%84%9F%E7%9F%A5/" rel="tag">感知</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6/" rel="tag">无人驾驶</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%87%E5%AE%9A/" rel="tag">标定</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" rel="tag">概率论</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/" rel="tag">目标跟踪</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%86%E8%A7%89/" rel="tag">视觉</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%9C%E7%A2%8D%E7%89%A9%E6%A3%80%E6%B5%8B/" rel="tag">障碍物检测</a><span class="tag-list-count">1</span></li></ul>
        </canvas>
       </div>
     </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhxJia</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">302k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:23</span>
</div>

<span id="sitetime"></span>
<script language=javascript>
  function siteTime(){
    window.setTimeout("siteTime()", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
    year - 作为date对象的年份，为4位年份值
    month - 0-11之间的整数，做为date对象的月份
    day - 1-31之间的整数，做为date对象的天数
    hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
    minutes - 0-59之间的整数，做为date对象的分钟数
    seconds - 0-59之间的整数，做为date对象的秒数
    microseconds - 0-999之间的整数，做为date对象的毫秒数 */
    var t1 = Date.UTC(2020,01,28,00,00,00); //这里调整博客建站时间，时间：2019-05-14 00:00:00
    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = t2-t1;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
    document.getElementById("sitetime").innerHTML=" 已运行"+/*diffYears+" 年 "+*/diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
  siteTime();
</script>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e37e1f2e978cea8" async="async"></script>
  </div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://zhxjia.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://zhxjia.github.io/2020/03/13/apollo-radar-algorithm/";
    this.page.identifier = "2020/03/13/apollo-radar-algorithm/";
    this.page.title = "Apollo中radar的相关算法";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://zhxjia.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":true,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
